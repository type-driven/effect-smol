/**
 * @since 1.0.0
 */

import * as Data from "effect/Data"
import * as Effect from "effect/Effect"
import type { SchemaError } from "effect/Schema"
import * as Schema from "effect/Schema"
import * as Stream from "effect/Stream"
import * as Sse from "effect/unstable/encoding/Sse"
import * as HttpClient from "effect/unstable/http/HttpClient"
import * as HttpClientError from "effect/unstable/http/HttpClientError"
import * as HttpClientRequest from "effect/unstable/http/HttpClientRequest"
import * as HttpClientResponse from "effect/unstable/http/HttpClientResponse"
// non-recursive definitions
export type AddUploadPartRequest = { readonly "data": string }
export const AddUploadPartRequest = Schema.Struct({
  "data": Schema.String.annotate({ "description": "The chunk of bytes for this Part.\n", "format": "binary" })
})
export type AdminApiKey = {
  readonly "object": string
  readonly "id": string
  readonly "name": string
  readonly "redacted_value": string
  readonly "value"?: string
  readonly "created_at": number
  readonly "last_used_at": number | null
  readonly "owner": {
    readonly "type"?: string
    readonly "object"?: string
    readonly "id"?: string
    readonly "name"?: string
    readonly "created_at"?: number
    readonly "role"?: string
  }
}
export const AdminApiKey = Schema.Struct({
  "object": Schema.String.annotate({ "description": "The object type, which is always `organization.admin_api_key`" }),
  "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" }),
  "name": Schema.String.annotate({ "description": "The name of the API key" }),
  "redacted_value": Schema.String.annotate({ "description": "The redacted value of the API key" }),
  "value": Schema.optionalKey(
    Schema.String.annotate({ "description": "The value of the API key. Only shown on create." })
  ),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) of when the API key was created",
    "format": "int64"
  }).check(Schema.isInt()),
  "last_used_at": Schema.Union([
    Schema.Number.annotate({
      "description": "The Unix timestamp (in seconds) of when the API key was last used",
      "format": "int64"
    }).check(Schema.isInt()),
    Schema.Null
  ]),
  "owner": Schema.Struct({
    "type": Schema.optionalKey(Schema.String.annotate({ "description": "Always `user`" })),
    "object": Schema.optionalKey(
      Schema.String.annotate({ "description": "The object type, which is always organization.user" })
    ),
    "id": Schema.optionalKey(
      Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" })
    ),
    "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the user" })),
    "created_at": Schema.optionalKey(
      Schema.Number.annotate({
        "description": "The Unix timestamp (in seconds) of when the user was created",
        "format": "int64"
      }).check(Schema.isInt())
    ),
    "role": Schema.optionalKey(Schema.String.annotate({ "description": "Always `owner`" }))
  })
}).annotate({ "description": "Represents an individual Admin API key in an org." })
export type AssignedRoleDetails = {
  readonly "id": string
  readonly "name": string
  readonly "permissions": ReadonlyArray<string>
  readonly "resource_type": string
  readonly "predefined_role": boolean
  readonly "description": string | null
  readonly "created_at": number | null
  readonly "updated_at": number | null
  readonly "created_by": string | null
  readonly "created_by_user_obj": {} | null
  readonly "metadata": {} | null
}
export const AssignedRoleDetails = Schema.Struct({
  "id": Schema.String.annotate({ "description": "Identifier for the role." }),
  "name": Schema.String.annotate({ "description": "Name of the role." }),
  "permissions": Schema.Array(Schema.String).annotate({ "description": "Permissions associated with the role." }),
  "resource_type": Schema.String.annotate({ "description": "Resource type the role applies to." }),
  "predefined_role": Schema.Boolean.annotate({ "description": "Whether the role is predefined by OpenAI." }),
  "description": Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Description of the role." }),
  "created_at": Schema.Union([Schema.Number.annotate({ "format": "int64" }).check(Schema.isInt()), Schema.Null])
    .annotate({ "description": "When the role was created." }),
  "updated_at": Schema.Union([Schema.Number.annotate({ "format": "int64" }).check(Schema.isInt()), Schema.Null])
    .annotate({ "description": "When the role was last updated." }),
  "created_by": Schema.Union([Schema.String, Schema.Null]).annotate({
    "description": "Identifier of the actor who created the role."
  }),
  "created_by_user_obj": Schema.Union([Schema.Struct({}), Schema.Null]).annotate({
    "description": "User details for the actor that created the role, when available."
  }),
  "metadata": Schema.Union([Schema.Struct({}), Schema.Null]).annotate({
    "description": "Arbitrary metadata stored on the role."
  })
}).annotate({ "description": "Detailed information about a role assignment entry returned when listing assignments." })
export type AssistantSupportedModels =
  | "gpt-5"
  | "gpt-5-mini"
  | "gpt-5-nano"
  | "gpt-5-2025-08-07"
  | "gpt-5-mini-2025-08-07"
  | "gpt-5-nano-2025-08-07"
  | "gpt-4.1"
  | "gpt-4.1-mini"
  | "gpt-4.1-nano"
  | "gpt-4.1-2025-04-14"
  | "gpt-4.1-mini-2025-04-14"
  | "gpt-4.1-nano-2025-04-14"
  | "o3-mini"
  | "o3-mini-2025-01-31"
  | "o1"
  | "o1-2024-12-17"
  | "gpt-4o"
  | "gpt-4o-2024-11-20"
  | "gpt-4o-2024-08-06"
  | "gpt-4o-2024-05-13"
  | "gpt-4o-mini"
  | "gpt-4o-mini-2024-07-18"
  | "gpt-4.5-preview"
  | "gpt-4.5-preview-2025-02-27"
  | "gpt-4-turbo"
  | "gpt-4-turbo-2024-04-09"
  | "gpt-4-0125-preview"
  | "gpt-4-turbo-preview"
  | "gpt-4-1106-preview"
  | "gpt-4-vision-preview"
  | "gpt-4"
  | "gpt-4-0314"
  | "gpt-4-0613"
  | "gpt-4-32k"
  | "gpt-4-32k-0314"
  | "gpt-4-32k-0613"
  | "gpt-3.5-turbo"
  | "gpt-3.5-turbo-16k"
  | "gpt-3.5-turbo-0613"
  | "gpt-3.5-turbo-1106"
  | "gpt-3.5-turbo-0125"
  | "gpt-3.5-turbo-16k-0613"
export const AssistantSupportedModels = Schema.Literals([
  "gpt-5",
  "gpt-5-mini",
  "gpt-5-nano",
  "gpt-5-2025-08-07",
  "gpt-5-mini-2025-08-07",
  "gpt-5-nano-2025-08-07",
  "gpt-4.1",
  "gpt-4.1-mini",
  "gpt-4.1-nano",
  "gpt-4.1-2025-04-14",
  "gpt-4.1-mini-2025-04-14",
  "gpt-4.1-nano-2025-04-14",
  "o3-mini",
  "o3-mini-2025-01-31",
  "o1",
  "o1-2024-12-17",
  "gpt-4o",
  "gpt-4o-2024-11-20",
  "gpt-4o-2024-08-06",
  "gpt-4o-2024-05-13",
  "gpt-4o-mini",
  "gpt-4o-mini-2024-07-18",
  "gpt-4.5-preview",
  "gpt-4.5-preview-2025-02-27",
  "gpt-4-turbo",
  "gpt-4-turbo-2024-04-09",
  "gpt-4-0125-preview",
  "gpt-4-turbo-preview",
  "gpt-4-1106-preview",
  "gpt-4-vision-preview",
  "gpt-4",
  "gpt-4-0314",
  "gpt-4-0613",
  "gpt-4-32k",
  "gpt-4-32k-0314",
  "gpt-4-32k-0613",
  "gpt-3.5-turbo",
  "gpt-3.5-turbo-16k",
  "gpt-3.5-turbo-0613",
  "gpt-3.5-turbo-1106",
  "gpt-3.5-turbo-0125",
  "gpt-3.5-turbo-16k-0613"
])
export type AssistantToolsCode = { readonly "type": "code_interpreter" }
export const AssistantToolsCode = Schema.Struct({
  "type": Schema.Literal("code_interpreter").annotate({
    "description": "The type of tool being defined: `code_interpreter`"
  })
}).annotate({ "title": "Code interpreter tool" })
export type AssistantToolsFileSearchTypeOnly = { readonly "type": "file_search" }
export const AssistantToolsFileSearchTypeOnly = Schema.Struct({
  "type": Schema.Literal("file_search").annotate({ "description": "The type of tool being defined: `file_search`" })
}).annotate({ "title": "FileSearch tool" })
export type AssistantsNamedToolChoice = {
  readonly "type": "function" | "code_interpreter" | "file_search"
  readonly "function"?: { readonly "name": string }
}
export const AssistantsNamedToolChoice = Schema.Struct({
  "type": Schema.Literals(["function", "code_interpreter", "file_search"]).annotate({
    "description": "The type of the tool. If type is `function`, the function name must be set"
  }),
  "function": Schema.optionalKey(
    Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the function to call." }) })
  )
}).annotate({ "description": "Specifies a tool the model should use. Use to force the model to call a specific tool." })
export type AudioResponseFormat = "json" | "text" | "srt" | "verbose_json" | "vtt" | "diarized_json"
export const AudioResponseFormat = Schema.Literals(["json", "text", "srt", "verbose_json", "vtt", "diarized_json"])
  .annotate({
    "description":
      "The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, `vtt`, or `diarized_json`. For `gpt-4o-transcribe` and `gpt-4o-mini-transcribe`, the only supported format is `json`. For `gpt-4o-transcribe-diarize`, the supported formats are `json`, `text`, and `diarized_json`, with `diarized_json` required to receive speaker annotations.\n"
  })
export type AuditLogActorServiceAccount = { readonly "id"?: string }
export const AuditLogActorServiceAccount = Schema.Struct({
  "id": Schema.optionalKey(Schema.String.annotate({ "description": "The service account id." }))
}).annotate({ "description": "The service account that performed the audit logged action." })
export type AuditLogActorUser = { readonly "id"?: string; readonly "email"?: string }
export const AuditLogActorUser = Schema.Struct({
  "id": Schema.optionalKey(Schema.String.annotate({ "description": "The user id." })),
  "email": Schema.optionalKey(Schema.String.annotate({ "description": "The user email." }))
}).annotate({ "description": "The user who performed the audit logged action." })
export type AuditLogEventType =
  | "api_key.created"
  | "api_key.updated"
  | "api_key.deleted"
  | "certificate.created"
  | "certificate.updated"
  | "certificate.deleted"
  | "certificates.activated"
  | "certificates.deactivated"
  | "checkpoint.permission.created"
  | "checkpoint.permission.deleted"
  | "external_key.registered"
  | "external_key.removed"
  | "group.created"
  | "group.updated"
  | "group.deleted"
  | "invite.sent"
  | "invite.accepted"
  | "invite.deleted"
  | "ip_allowlist.created"
  | "ip_allowlist.updated"
  | "ip_allowlist.deleted"
  | "ip_allowlist.config.activated"
  | "ip_allowlist.config.deactivated"
  | "login.succeeded"
  | "login.failed"
  | "logout.succeeded"
  | "logout.failed"
  | "organization.updated"
  | "project.created"
  | "project.updated"
  | "project.archived"
  | "project.deleted"
  | "rate_limit.updated"
  | "rate_limit.deleted"
  | "resource.deleted"
  | "tunnel.created"
  | "tunnel.updated"
  | "tunnel.deleted"
  | "role.created"
  | "role.updated"
  | "role.deleted"
  | "role.assignment.created"
  | "role.assignment.deleted"
  | "scim.enabled"
  | "scim.disabled"
  | "service_account.created"
  | "service_account.updated"
  | "service_account.deleted"
  | "user.added"
  | "user.updated"
  | "user.deleted"
export const AuditLogEventType = Schema.Literals([
  "api_key.created",
  "api_key.updated",
  "api_key.deleted",
  "certificate.created",
  "certificate.updated",
  "certificate.deleted",
  "certificates.activated",
  "certificates.deactivated",
  "checkpoint.permission.created",
  "checkpoint.permission.deleted",
  "external_key.registered",
  "external_key.removed",
  "group.created",
  "group.updated",
  "group.deleted",
  "invite.sent",
  "invite.accepted",
  "invite.deleted",
  "ip_allowlist.created",
  "ip_allowlist.updated",
  "ip_allowlist.deleted",
  "ip_allowlist.config.activated",
  "ip_allowlist.config.deactivated",
  "login.succeeded",
  "login.failed",
  "logout.succeeded",
  "logout.failed",
  "organization.updated",
  "project.created",
  "project.updated",
  "project.archived",
  "project.deleted",
  "rate_limit.updated",
  "rate_limit.deleted",
  "resource.deleted",
  "tunnel.created",
  "tunnel.updated",
  "tunnel.deleted",
  "role.created",
  "role.updated",
  "role.deleted",
  "role.assignment.created",
  "role.assignment.deleted",
  "scim.enabled",
  "scim.disabled",
  "service_account.created",
  "service_account.updated",
  "service_account.deleted",
  "user.added",
  "user.updated",
  "user.deleted"
]).annotate({ "description": "The event type." })
export type AutoChunkingStrategyRequestParam = { readonly "type": "auto" }
export const AutoChunkingStrategyRequestParam = Schema.Struct({
  "type": Schema.Literal("auto").annotate({ "description": "Always `auto`." })
}).annotate({
  "title": "Auto Chunking Strategy",
  "description":
    "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."
})
export type BatchFileExpirationAfter = { readonly "anchor": "created_at"; readonly "seconds": number }
export const BatchFileExpirationAfter = Schema.Struct({
  "anchor": Schema.Literal("created_at").annotate({
    "description":
      "Anchor timestamp after which the expiration policy applies. Supported anchors: `created_at`. Note that the anchor is the file creation time, not the time the batch is created."
  }),
  "seconds": Schema.Number.annotate({
    "description":
      "The number of seconds after the anchor time that the file will expire. Must be between 3600 (1 hour) and 2592000 (30 days)."
  }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(3600)).check(Schema.isLessThanOrEqualTo(2592000))
}).annotate({
  "title": "File expiration policy",
  "description": "The expiration policy for the output and/or error file that are generated for a batch."
})
export type Certificate = {
  readonly "object": "certificate" | "organization.certificate" | "organization.project.certificate"
  readonly "id": string
  readonly "name": string
  readonly "created_at": number
  readonly "certificate_details": {
    readonly "valid_at"?: number
    readonly "expires_at"?: number
    readonly "content"?: string
  }
  readonly "active"?: boolean
}
export const Certificate = Schema.Struct({
  "object": Schema.Literals(["certificate", "organization.certificate", "organization.project.certificate"]).annotate({
    "description":
      "The object type.\n\n- If creating, updating, or getting a specific certificate, the object type is `certificate`.\n- If listing, activating, or deactivating certificates for the organization, the object type is `organization.certificate`.\n- If listing, activating, or deactivating certificates for a project, the object type is `organization.project.certificate`.\n"
  }),
  "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" }),
  "name": Schema.String.annotate({ "description": "The name of the certificate." }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) of when the certificate was uploaded."
  }).check(Schema.isInt()),
  "certificate_details": Schema.Struct({
    "valid_at": Schema.optionalKey(
      Schema.Number.annotate({
        "description": "The Unix timestamp (in seconds) of when the certificate becomes valid."
      }).check(Schema.isInt())
    ),
    "expires_at": Schema.optionalKey(
      Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the certificate expires." })
        .check(Schema.isInt())
    ),
    "content": Schema.optionalKey(
      Schema.String.annotate({ "description": "The content of the certificate in PEM format." })
    )
  }),
  "active": Schema.optionalKey(
    Schema.Boolean.annotate({
      "description":
        "Whether the certificate is currently active at the specified scope. Not returned when getting details for a specific certificate."
    })
  )
}).annotate({ "description": "Represents an individual `certificate` uploaded to the organization." })
export type ChatCompletionAllowedTools = { readonly "mode": "auto" | "required"; readonly "tools": ReadonlyArray<{}> }
export const ChatCompletionAllowedTools = Schema.Struct({
  "mode": Schema.Literals(["auto", "required"]).annotate({
    "description":
      "Constrains the tools available to the model to a pre-defined set.\n\n`auto` allows the model to pick from among the allowed tools and generate a\nmessage.\n\n`required` requires the model to call one or more of the allowed tools.\n"
  }),
  "tools": Schema.Array(
    Schema.Struct({}).annotate({ "description": "A tool definition that the model should be allowed to call.\n" })
  ).annotate({
    "description":
      "A list of tool definitions that the model should be allowed to call.\n\nFor the Chat Completions API, the list of tool definitions might look like:\n```json\n[\n  { \"type\": \"function\", \"function\": { \"name\": \"get_weather\" } },\n  { \"type\": \"function\", \"function\": { \"name\": \"get_time\" } }\n]\n```\n"
  })
}).annotate({
  "title": "Allowed tools",
  "description": "Constrains the tools available to the model to a pre-defined set.\n"
})
export type ChatCompletionDeleted = {
  readonly "object": "chat.completion.deleted"
  readonly "id": string
  readonly "deleted": boolean
}
export const ChatCompletionDeleted = Schema.Struct({
  "object": Schema.Literal("chat.completion.deleted").annotate({ "description": "The type of object being deleted." }),
  "id": Schema.String.annotate({ "description": "The ID of the chat completion that was deleted." }),
  "deleted": Schema.Boolean.annotate({ "description": "Whether the chat completion was deleted." })
})
export type ChatCompletionFunctionCallOption = { readonly "name": string }
export const ChatCompletionFunctionCallOption = Schema.Struct({
  "name": Schema.String.annotate({ "description": "The name of the function to call." })
}).annotate({
  "description":
    "Specifying a particular function via `{\"name\": \"my_function\"}` forces the model to call that function.\n"
})
export type ChatCompletionMessageCustomToolCall = {
  readonly "id": string
  readonly "type": "custom"
  readonly "custom": { readonly "name": string; readonly "input": string }
}
export const ChatCompletionMessageCustomToolCall = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The ID of the tool call." }),
  "type": Schema.Literal("custom").annotate({ "description": "The type of the tool. Always `custom`." }),
  "custom": Schema.Struct({
    "name": Schema.String.annotate({ "description": "The name of the custom tool to call." }),
    "input": Schema.String.annotate({ "description": "The input for the custom tool call generated by the model." })
  }).annotate({ "description": "The custom tool that the model called." })
}).annotate({ "title": "Custom tool call", "description": "A call to a custom tool created by the model.\n" })
export type ChatCompletionMessageToolCall = {
  readonly "id": string
  readonly "type": "function"
  readonly "function": { readonly "name": string; readonly "arguments": string }
}
export const ChatCompletionMessageToolCall = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The ID of the tool call." }),
  "type": Schema.Literal("function").annotate({
    "description": "The type of the tool. Currently, only `function` is supported."
  }),
  "function": Schema.Struct({
    "name": Schema.String.annotate({ "description": "The name of the function to call." }),
    "arguments": Schema.String.annotate({
      "description":
        "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."
    })
  }).annotate({ "description": "The function that the model called." })
}).annotate({ "title": "Function tool call", "description": "A call to a function tool created by the model.\n" })
export type ChatCompletionMessageToolCallChunk = {
  readonly "index": number
  readonly "id"?: string
  readonly "type"?: "function"
  readonly "function"?: { readonly "name"?: string; readonly "arguments"?: string }
}
export const ChatCompletionMessageToolCallChunk = Schema.Struct({
  "index": Schema.Number.check(Schema.isInt()),
  "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the tool call." })),
  "type": Schema.optionalKey(
    Schema.Literal("function").annotate({
      "description": "The type of the tool. Currently, only `function` is supported."
    })
  ),
  "function": Schema.optionalKey(Schema.Struct({
    "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the function to call." })),
    "arguments": Schema.optionalKey(Schema.String.annotate({
      "description":
        "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."
    }))
  }))
})
export type ChatCompletionNamedToolChoice = {
  readonly "type": "function"
  readonly "function": { readonly "name": string }
}
export const ChatCompletionNamedToolChoice = Schema.Struct({
  "type": Schema.Literal("function").annotate({
    "description": "For function calling, the type is always `function`."
  }),
  "function": Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the function to call." }) })
}).annotate({
  "title": "Function tool choice",
  "description": "Specifies a tool the model should use. Use to force the model to call a specific function."
})
export type ChatCompletionNamedToolChoiceCustom = {
  readonly "type": "custom"
  readonly "custom": { readonly "name": string }
}
export const ChatCompletionNamedToolChoiceCustom = Schema.Struct({
  "type": Schema.Literal("custom").annotate({ "description": "For custom tool calling, the type is always `custom`." }),
  "custom": Schema.Struct({
    "name": Schema.String.annotate({ "description": "The name of the custom tool to call." })
  })
}).annotate({
  "title": "Custom tool choice",
  "description": "Specifies a tool the model should use. Use to force the model to call a specific custom tool."
})
export type ChatCompletionRequestFunctionMessage = {
  readonly "role": "function"
  readonly "content": string | null
  readonly "name": string
}
export const ChatCompletionRequestFunctionMessage = Schema.Struct({
  "role": Schema.Literal("function").annotate({
    "description": "The role of the messages author, in this case `function`."
  }),
  "content": Schema.Union([
    Schema.String.annotate({ "description": "The contents of the function message." }),
    Schema.Null
  ]),
  "name": Schema.String.annotate({ "description": "The name of the function to call." })
}).annotate({ "title": "Function message" })
export type ChatCompletionRequestMessageContentPartAudio = {
  readonly "type": "input_audio"
  readonly "input_audio": { readonly "data": string; readonly "format": "wav" | "mp3" }
}
export const ChatCompletionRequestMessageContentPartAudio = Schema.Struct({
  "type": Schema.Literal("input_audio").annotate({
    "description": "The type of the content part. Always `input_audio`."
  }),
  "input_audio": Schema.Struct({
    "data": Schema.String.annotate({ "description": "Base64 encoded audio data." }),
    "format": Schema.Literals(["wav", "mp3"]).annotate({
      "description": "The format of the encoded audio data. Currently supports \"wav\" and \"mp3\".\n"
    })
  })
}).annotate({ "title": "Audio content part", "description": "Learn about [audio inputs](/docs/guides/audio).\n" })
export type ChatCompletionRequestMessageContentPartFile = {
  readonly "type": "file"
  readonly "file": { readonly "filename"?: string; readonly "file_data"?: string; readonly "file_id"?: string }
}
export const ChatCompletionRequestMessageContentPartFile = Schema.Struct({
  "type": Schema.Literal("file").annotate({ "description": "The type of the content part. Always `file`." }),
  "file": Schema.Struct({
    "filename": Schema.optionalKey(
      Schema.String.annotate({
        "description": "The name of the file, used when passing the file to the model as a \nstring.\n"
      })
    ),
    "file_data": Schema.optionalKey(
      Schema.String.annotate({
        "description": "The base64 encoded file data, used when passing the file to the model \nas a string.\n"
      })
    ),
    "file_id": Schema.optionalKey(
      Schema.String.annotate({ "description": "The ID of an uploaded file to use as input.\n" })
    )
  })
}).annotate({
  "title": "File content part",
  "description": "Learn about [file inputs](/docs/guides/text) for text generation.\n"
})
export type ChatCompletionRequestMessageContentPartImage = {
  readonly "type": "image_url"
  readonly "image_url": { readonly "url": string; readonly "detail"?: "auto" | "low" | "high" }
}
export const ChatCompletionRequestMessageContentPartImage = Schema.Struct({
  "type": Schema.Literal("image_url").annotate({ "description": "The type of the content part." }),
  "image_url": Schema.Struct({
    "url": Schema.String.annotate({
      "description": "Either a URL of the image or the base64 encoded image data.",
      "format": "uri"
    }),
    "detail": Schema.optionalKey(
      Schema.Literals(["auto", "low", "high"]).annotate({
        "description":
          "Specifies the detail level of the image. Learn more in the [Vision guide](/docs/guides/vision#low-or-high-fidelity-image-understanding)."
      })
    )
  })
}).annotate({ "title": "Image content part", "description": "Learn about [image inputs](/docs/guides/vision).\n" })
export type ChatCompletionRequestMessageContentPartRefusal = { readonly "type": "refusal"; readonly "refusal": string }
export const ChatCompletionRequestMessageContentPartRefusal = Schema.Struct({
  "type": Schema.Literal("refusal").annotate({ "description": "The type of the content part." }),
  "refusal": Schema.String.annotate({ "description": "The refusal message generated by the model." })
}).annotate({ "title": "Refusal content part" })
export type ChatCompletionRequestMessageContentPartText = { readonly "type": "text"; readonly "text": string }
export const ChatCompletionRequestMessageContentPartText = Schema.Struct({
  "type": Schema.Literal("text").annotate({ "description": "The type of the content part." }),
  "text": Schema.String.annotate({ "description": "The text content." })
}).annotate({
  "title": "Text content part",
  "description": "Learn about [text inputs](/docs/guides/text-generation).\n"
})
export type ChatCompletionStreamOptions = {
  readonly "include_usage"?: boolean
  readonly "include_obfuscation"?: boolean
} | null
export const ChatCompletionStreamOptions = Schema.Union([
  Schema.Struct({
    "include_usage": Schema.optionalKey(Schema.Boolean.annotate({
      "description":
        "If set, an additional chunk will be streamed before the `data: [DONE]`\nmessage. The `usage` field on this chunk shows the token usage statistics\nfor the entire request, and the `choices` field will always be an empty\narray.\n\nAll other chunks will also include a `usage` field, but with a null\nvalue. **NOTE:** If the stream is interrupted, you may not receive the\nfinal usage chunk which contains the total token usage for the request.\n"
    })),
    "include_obfuscation": Schema.optionalKey(Schema.Boolean.annotate({
      "description":
        "When true, stream obfuscation will be enabled. Stream obfuscation adds\nrandom characters to an `obfuscation` field on streaming delta events to\nnormalize payload sizes as a mitigation to certain side-channel attacks.\nThese obfuscation fields are included by default, but add a small amount\nof overhead to the data stream. You can set `include_obfuscation` to\nfalse to optimize for bandwidth if you trust the network links between\nyour application and the OpenAI API.\n"
    }))
  }).annotate({ "description": "Options for streaming response. Only set this when you set `stream: true`.\n" }),
  Schema.Null
])
export type ChatCompletionTokenLogprob = {
  readonly "token": string
  readonly "logprob": number
  readonly "bytes": ReadonlyArray<number> | null
  readonly "top_logprobs": ReadonlyArray<
    { readonly "token": string; readonly "logprob": number; readonly "bytes": ReadonlyArray<number> | null }
  >
}
export const ChatCompletionTokenLogprob = Schema.Struct({
  "token": Schema.String.annotate({ "description": "The token." }),
  "logprob": Schema.Number.annotate({
    "description":
      "The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely."
  }).check(Schema.isFinite()),
  "bytes": Schema.Union([
    Schema.Array(Schema.Number.check(Schema.isInt())).annotate({
      "description":
        "A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token."
    }),
    Schema.Null
  ]),
  "top_logprobs": Schema.Array(Schema.Struct({
    "token": Schema.String.annotate({ "description": "The token." }),
    "logprob": Schema.Number.annotate({
      "description":
        "The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely."
    }).check(Schema.isFinite()),
    "bytes": Schema.Union([
      Schema.Array(Schema.Number.check(Schema.isInt())).annotate({
        "description":
          "A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token."
      }),
      Schema.Null
    ])
  })).annotate({
    "description":
      "List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned."
  })
})
export type ComparisonFilter = {
  readonly "type": "eq" | "ne" | "gt" | "gte" | "lt" | "lte"
  readonly "key": string
  readonly "value": string | number | boolean | ReadonlyArray<string | number>
}
export const ComparisonFilter = Schema.Struct({
  "type": Schema.Literals(["eq", "ne", "gt", "gte", "lt", "lte"]).annotate({
    "description":
      "Specifies the comparison operator: `eq`, `ne`, `gt`, `gte`, `lt`, `lte`, `in`, `nin`.\n- `eq`: equals\n- `ne`: not equal\n- `gt`: greater than\n- `gte`: greater than or equal\n- `lt`: less than\n- `lte`: less than or equal\n- `in`: in\n- `nin`: not in\n"
  }),
  "key": Schema.String.annotate({ "description": "The key to compare against the value." }),
  "value": Schema.Union([
    Schema.String,
    Schema.Number.check(Schema.isFinite()),
    Schema.Boolean,
    Schema.Array(Schema.Union([Schema.String, Schema.Number.check(Schema.isFinite())], { mode: "oneOf" }))
  ], { mode: "oneOf" }).annotate({
    "description": "The value to compare against the attribute key; supports string, number, or boolean types."
  })
}).annotate({
  "title": "Comparison Filter",
  "description":
    "A filter used to compare a specified attribute key to a given value using a defined comparison operation.\n"
})
export type CompleteUploadRequest = { readonly "part_ids": ReadonlyArray<string>; readonly "md5"?: string }
export const CompleteUploadRequest = Schema.Struct({
  "part_ids": Schema.Array(Schema.String).annotate({ "description": "The ordered list of Part IDs.\n" }),
  "md5": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "The optional md5 checksum for the file contents to verify if the bytes uploaded matches what you expect.\n"
    })
  )
})
export type CompletionUsage = {
  readonly "completion_tokens": number
  readonly "prompt_tokens": number
  readonly "total_tokens": number
  readonly "completion_tokens_details"?: {
    readonly "accepted_prediction_tokens"?: number
    readonly "audio_tokens"?: number
    readonly "reasoning_tokens"?: number
    readonly "rejected_prediction_tokens"?: number
  }
  readonly "prompt_tokens_details"?: { readonly "audio_tokens"?: number; readonly "cached_tokens"?: number }
}
export const CompletionUsage = Schema.Struct({
  "completion_tokens": Schema.Number.annotate({ "description": "Number of tokens in the generated completion." }).check(
    Schema.isInt()
  ),
  "prompt_tokens": Schema.Number.annotate({ "description": "Number of tokens in the prompt." }).check(Schema.isInt()),
  "total_tokens": Schema.Number.annotate({
    "description": "Total number of tokens used in the request (prompt + completion)."
  }).check(Schema.isInt()),
  "completion_tokens_details": Schema.optionalKey(
    Schema.Struct({
      "accepted_prediction_tokens": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "When using Predicted Outputs, the number of tokens in the\nprediction that appeared in the completion.\n"
        }).check(Schema.isInt())
      ),
      "audio_tokens": Schema.optionalKey(
        Schema.Number.annotate({ "description": "Audio input tokens generated by the model." }).check(Schema.isInt())
      ),
      "reasoning_tokens": Schema.optionalKey(
        Schema.Number.annotate({ "description": "Tokens generated by the model for reasoning." }).check(Schema.isInt())
      ),
      "rejected_prediction_tokens": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "When using Predicted Outputs, the number of tokens in the\nprediction that did not appear in the completion. However, like\nreasoning tokens, these tokens are still counted in the total\ncompletion tokens for purposes of billing, output, and context window\nlimits.\n"
        }).check(Schema.isInt())
      )
    }).annotate({ "description": "Breakdown of tokens used in a completion." })
  ),
  "prompt_tokens_details": Schema.optionalKey(
    Schema.Struct({
      "audio_tokens": Schema.optionalKey(
        Schema.Number.annotate({ "description": "Audio input tokens present in the prompt." }).check(Schema.isInt())
      ),
      "cached_tokens": Schema.optionalKey(
        Schema.Number.annotate({ "description": "Cached tokens present in the prompt." }).check(Schema.isInt())
      )
    }).annotate({ "description": "Breakdown of tokens used in the prompt." })
  )
}).annotate({ "description": "Usage statistics for the completion request." })
export type ComputerScreenshotImage = {
  readonly "type": "computer_screenshot"
  readonly "image_url"?: string
  readonly "file_id"?: string
}
export const ComputerScreenshotImage = Schema.Struct({
  "type": Schema.Literal("computer_screenshot").annotate({
    "description":
      "Specifies the event type. For a computer screenshot, this property is \nalways set to `computer_screenshot`.\n"
  }),
  "image_url": Schema.optionalKey(Schema.String.annotate({ "description": "The URL of the screenshot image." })),
  "file_id": Schema.optionalKey(
    Schema.String.annotate({ "description": "The identifier of an uploaded file that contains the screenshot." })
  )
}).annotate({ "description": "A computer screenshot image used with the computer use tool.\n" })
export type ContainerFileResource = {
  readonly "id": string
  readonly "object": string
  readonly "container_id": string
  readonly "created_at": number
  readonly "bytes": number
  readonly "path": string
  readonly "source": string
}
export const ContainerFileResource = Schema.Struct({
  "id": Schema.String.annotate({ "description": "Unique identifier for the file." }),
  "object": Schema.String.annotate({ "description": "The type of this object (`container.file`)." }),
  "container_id": Schema.String.annotate({ "description": "The container this file belongs to." }),
  "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) when the file was created." })
    .check(Schema.isInt()),
  "bytes": Schema.Number.annotate({ "description": "Size of the file in bytes." }).check(Schema.isInt()),
  "path": Schema.String.annotate({ "description": "Path of the file in the container." }),
  "source": Schema.String.annotate({ "description": "Source of the file (e.g., `user`, `assistant`)." })
}).annotate({ "title": "The container file object" })
export type ContainerResource = {
  readonly "id": string
  readonly "object": string
  readonly "name": string
  readonly "created_at": number
  readonly "status": string
  readonly "last_active_at"?: number
  readonly "expires_after"?: { readonly "anchor"?: "last_active_at"; readonly "minutes"?: number }
  readonly "memory_limit"?: "1g" | "4g" | "16g" | "64g"
  readonly "network_policy"?: {
    readonly "type": "allowlist" | "disabled"
    readonly "allowed_domains"?: ReadonlyArray<string>
  }
}
export const ContainerResource = Schema.Struct({
  "id": Schema.String.annotate({ "description": "Unique identifier for the container." }),
  "object": Schema.String.annotate({ "description": "The type of this object." }),
  "name": Schema.String.annotate({ "description": "Name of the container." }),
  "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) when the container was created." })
    .check(Schema.isInt()),
  "status": Schema.String.annotate({ "description": "Status of the container (e.g., active, deleted)." }),
  "last_active_at": Schema.optionalKey(
    Schema.Number.annotate({ "description": "Unix timestamp (in seconds) when the container was last active." }).check(
      Schema.isInt()
    )
  ),
  "expires_after": Schema.optionalKey(
    Schema.Struct({
      "anchor": Schema.optionalKey(
        Schema.Literal("last_active_at").annotate({ "description": "The reference point for the expiration." })
      ),
      "minutes": Schema.optionalKey(
        Schema.Number.annotate({
          "description": "The number of minutes after the anchor before the container expires."
        }).check(Schema.isInt())
      )
    }).annotate({
      "description":
        "The container will expire after this time period.\nThe anchor is the reference point for the expiration.\nThe minutes is the number of minutes after the anchor before the container expires.\n"
    })
  ),
  "memory_limit": Schema.optionalKey(
    Schema.Literals(["1g", "4g", "16g", "64g"]).annotate({
      "description": "The memory limit configured for the container."
    })
  ),
  "network_policy": Schema.optionalKey(
    Schema.Struct({
      "type": Schema.Literals(["allowlist", "disabled"]).annotate({ "description": "The network policy mode." }),
      "allowed_domains": Schema.optionalKey(
        Schema.Array(Schema.String).annotate({ "description": "Allowed outbound domains when `type` is `allowlist`." })
      )
    }).annotate({ "description": "Network access policy for the container." })
  )
}).annotate({ "title": "The container object" })
export type CostsResult = {
  readonly "object": "organization.costs.result"
  readonly "amount"?: { readonly "value"?: number; readonly "currency"?: string }
  readonly "line_item"?: string | null
  readonly "project_id"?: string | null
}
export const CostsResult = Schema.Struct({
  "object": Schema.Literal("organization.costs.result"),
  "amount": Schema.optionalKey(
    Schema.Struct({
      "value": Schema.optionalKey(
        Schema.Number.annotate({ "description": "The numeric value of the cost." }).check(Schema.isFinite())
      ),
      "currency": Schema.optionalKey(
        Schema.String.annotate({ "description": "Lowercase ISO-4217 currency e.g. \"usd\"" })
      )
    }).annotate({ "description": "The monetary value in its associated currency." })
  ),
  "line_item": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=line_item`, this field provides the line item of the grouped costs result."
      }),
      Schema.Null
    ])
  ),
  "project_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=project_id`, this field provides the project ID of the grouped costs result."
      }),
      Schema.Null
    ])
  )
}).annotate({ "description": "The aggregated costs details of the specific time bucket." })
export type CreateContainerFileBody = { readonly "file_id"?: string; readonly "file"?: string }
export const CreateContainerFileBody = Schema.Struct({
  "file_id": Schema.optionalKey(Schema.String.annotate({ "description": "Name of the file to create." })),
  "file": Schema.optionalKey(
    Schema.String.annotate({ "description": "The File object (not file name) to be uploaded.\n", "format": "binary" })
  )
})
export type CreateEmbeddingRequest = {
  readonly "input": string | ReadonlyArray<string> | ReadonlyArray<number> | ReadonlyArray<ReadonlyArray<number>>
  readonly "model": string | "text-embedding-ada-002" | "text-embedding-3-small" | "text-embedding-3-large"
  readonly "encoding_format"?: "float" | "base64"
  readonly "dimensions"?: number
  readonly "user"?: string
}
export const CreateEmbeddingRequest = Schema.Struct({
  "input": Schema.Union([
    Schema.String.annotate({ "title": "string", "description": "The string that will be turned into an embedding." }),
    Schema.Array(Schema.String).annotate({
      "title": "array",
      "description": "The array of strings that will be turned into an embedding."
    }).check(Schema.isMinLength(1)).check(Schema.isMaxLength(2048)),
    Schema.Array(Schema.Number.check(Schema.isInt())).annotate({
      "title": "array",
      "description": "The array of integers that will be turned into an embedding."
    }).check(Schema.isMinLength(1)).check(Schema.isMaxLength(2048)),
    Schema.Array(Schema.Array(Schema.Number.check(Schema.isInt())).check(Schema.isMinLength(1))).annotate({
      "title": "array",
      "description": "The array of arrays containing integers that will be turned into an embedding."
    }).check(Schema.isMinLength(1)).check(Schema.isMaxLength(2048))
  ], { mode: "oneOf" }).annotate({
    "description":
      "Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for all embedding models), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. In addition to the per-input token limit, all embedding  models enforce a maximum of 300,000 tokens summed across all inputs in a  single request.\n"
  }),
  "model": Schema.Union([
    Schema.String,
    Schema.Literals(["text-embedding-ada-002", "text-embedding-3-small", "text-embedding-3-large"])
  ]).annotate({
    "description":
      "ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.\n"
  }),
  "encoding_format": Schema.optionalKey(
    Schema.Literals(["float", "base64"]).annotate({
      "description":
        "The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/)."
    })
  ),
  "dimensions": Schema.optionalKey(
    Schema.Number.annotate({
      "description":
        "The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models.\n"
    }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1))
  ),
  "user": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).\n"
    })
  )
})
export type CreateEvalCustomDataSourceConfig = {
  readonly "type": "custom"
  readonly "item_schema": {}
  readonly "include_sample_schema"?: boolean
}
export const CreateEvalCustomDataSourceConfig = Schema.Struct({
  "type": Schema.Literal("custom").annotate({ "description": "The type of data source. Always `custom`." }),
  "item_schema": Schema.Struct({}).annotate({ "description": "The json schema for each row in the data source." }),
  "include_sample_schema": Schema.optionalKey(
    Schema.Boolean.annotate({
      "description":
        "Whether the eval should expect you to populate the sample namespace (ie, by generating responses off of your data source)"
    })
  )
}).annotate({
  "title": "CustomDataSourceConfig",
  "description":
    "A CustomDataSourceConfig object that defines the schema for the data source used for the evaluation runs.\nThis schema is used to define the shape of the data that will be:\n- Used to define your testing criteria and\n- What data is required when creating a run\n"
})
export type CreateEvalLogsDataSourceConfig = { readonly "type": "logs"; readonly "metadata"?: {} }
export const CreateEvalLogsDataSourceConfig = Schema.Struct({
  "type": Schema.Literal("logs").annotate({ "description": "The type of data source. Always `logs`." }),
  "metadata": Schema.optionalKey(
    Schema.Struct({}).annotate({ "description": "Metadata filters for the logs data source." })
  )
}).annotate({
  "title": "LogsDataSourceConfig",
  "description":
    "A data source config which specifies the metadata property of your logs query.\nThis is usually metadata like `usecase=chatbot` or `prompt-version=v2`, etc.\n"
})
export type CreateEvalStoredCompletionsDataSourceConfig = {
  readonly "type": "stored_completions"
  readonly "metadata"?: {}
}
export const CreateEvalStoredCompletionsDataSourceConfig = Schema.Struct({
  "type": Schema.Literal("stored_completions").annotate({
    "description": "The type of data source. Always `stored_completions`."
  }),
  "metadata": Schema.optionalKey(
    Schema.Struct({}).annotate({ "description": "Metadata filters for the stored completions data source." })
  )
}).annotate({
  "title": "StoredCompletionsDataSourceConfig",
  "description": "Deprecated in favor of LogsDataSourceConfig.\n"
})
export type CreateFineTuningCheckpointPermissionRequest = { readonly "project_ids": ReadonlyArray<string> }
export const CreateFineTuningCheckpointPermissionRequest = Schema.Struct({
  "project_ids": Schema.Array(Schema.String).annotate({ "description": "The project identifiers to grant access to." })
})
export type CreateGroupBody = { readonly "name": string }
export const CreateGroupBody = Schema.Struct({
  "name": Schema.String.annotate({ "description": "Human readable name for the group." }).check(Schema.isMinLength(1))
    .check(Schema.isMaxLength(255))
}).annotate({ "description": "Request payload for creating a new group in the organization." })
export type CreateGroupUserBody = { readonly "user_id": string }
export const CreateGroupUserBody = Schema.Struct({
  "user_id": Schema.String.annotate({ "description": "Identifier of the user to add to the group." })
}).annotate({ "description": "Request payload for adding a user to a group." })
export type CreateImageVariationRequest = {
  readonly "image": string
  readonly "model"?: string | "dall-e-2" | null
  readonly "n"?: number | null
  readonly "response_format"?: "url" | "b64_json" | null
  readonly "size"?: "256x256" | "512x512" | "1024x1024" | null
  readonly "user"?: string
}
export const CreateImageVariationRequest = Schema.Struct({
  "image": Schema.String.annotate({
    "description":
      "The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.",
    "format": "binary"
  }),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.Union([Schema.String, Schema.Literal("dall-e-2")]).annotate({
        "description": "The model to use for image generation. Only `dall-e-2` is supported at this time."
      }),
      Schema.Null
    ])
  ),
  "n": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description": "The number of images to generate. Must be between 1 and 10."
    })
  ),
  "response_format": Schema.optionalKey(
    Schema.Union([Schema.Literal("url"), Schema.Literal("b64_json"), Schema.Null]).annotate({
      "description":
        "The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated."
    })
  ),
  "size": Schema.optionalKey(
    Schema.Union([Schema.Literal("256x256"), Schema.Literal("512x512"), Schema.Literal("1024x1024"), Schema.Null])
      .annotate({
        "description": "The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`."
      })
  ),
  "user": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).\n"
    })
  )
})
export type CreateModerationRequest = {
  readonly "input":
    | string
    | ReadonlyArray<string>
    | ReadonlyArray<
      { readonly "type": "image_url"; readonly "image_url": { readonly "url": string } } | {
        readonly "type": "text"
        readonly "text": string
      }
    >
  readonly "model"?:
    | string
    | "omni-moderation-latest"
    | "omni-moderation-2024-09-26"
    | "text-moderation-latest"
    | "text-moderation-stable"
}
export const CreateModerationRequest = Schema.Struct({
  "input": Schema.Union([
    Schema.String.annotate({ "description": "A string of text to classify for moderation." }),
    Schema.Array(Schema.String).annotate({ "description": "An array of strings to classify for moderation." }),
    Schema.Array(Schema.Union([
      Schema.Struct({
        "type": Schema.Literal("image_url").annotate({ "description": "Always `image_url`." }),
        "image_url": Schema.Struct({
          "url": Schema.String.annotate({
            "description": "Either a URL of the image or the base64 encoded image data.",
            "format": "uri"
          })
        }).annotate({ "description": "Contains either an image URL or a data URL for a base64 encoded image." })
      }).annotate({ "description": "An object describing an image to classify." }),
      Schema.Struct({
        "type": Schema.Literal("text").annotate({ "description": "Always `text`." }),
        "text": Schema.String.annotate({ "description": "A string of text to classify." })
      }).annotate({ "description": "An object describing text to classify." })
    ], { mode: "oneOf" })).annotate({ "description": "An array of multi-modal inputs to the moderation model." })
  ], { mode: "oneOf" }).annotate({
    "description":
      "Input (or inputs) to classify. Can be a single string, an array of strings, or\nan array of multi-modal input objects similar to other models.\n"
  }),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.String,
      Schema.Literals([
        "omni-moderation-latest",
        "omni-moderation-2024-09-26",
        "text-moderation-latest",
        "text-moderation-stable"
      ])
    ]).annotate({
      "description":
        "The content moderation model you would like to use. Learn more in\n[the moderation guide](/docs/guides/moderation), and learn about\navailable models [here](/docs/models#moderation).\n"
    })
  )
})
export type CreateModerationResponse = {
  readonly "id": string
  readonly "model": string
  readonly "results": ReadonlyArray<
    {
      readonly "flagged": boolean
      readonly "categories": {
        readonly "hate": boolean
        readonly "hate/threatening": boolean
        readonly "harassment": boolean
        readonly "harassment/threatening": boolean
        readonly "illicit": boolean | null
        readonly "illicit/violent": boolean | null
        readonly "self-harm": boolean
        readonly "self-harm/intent": boolean
        readonly "self-harm/instructions": boolean
        readonly "sexual": boolean
        readonly "sexual/minors": boolean
        readonly "violence": boolean
        readonly "violence/graphic": boolean
      }
      readonly "category_scores": {
        readonly "hate": number
        readonly "hate/threatening": number
        readonly "harassment": number
        readonly "harassment/threatening": number
        readonly "illicit": number
        readonly "illicit/violent": number
        readonly "self-harm": number
        readonly "self-harm/intent": number
        readonly "self-harm/instructions": number
        readonly "sexual": number
        readonly "sexual/minors": number
        readonly "violence": number
        readonly "violence/graphic": number
      }
      readonly "category_applied_input_types": {
        readonly "hate": ReadonlyArray<"text">
        readonly "hate/threatening": ReadonlyArray<"text">
        readonly "harassment": ReadonlyArray<"text">
        readonly "harassment/threatening": ReadonlyArray<"text">
        readonly "illicit": ReadonlyArray<"text">
        readonly "illicit/violent": ReadonlyArray<"text">
        readonly "self-harm": ReadonlyArray<"text" | "image">
        readonly "self-harm/intent": ReadonlyArray<"text" | "image">
        readonly "self-harm/instructions": ReadonlyArray<"text" | "image">
        readonly "sexual": ReadonlyArray<"text" | "image">
        readonly "sexual/minors": ReadonlyArray<"text">
        readonly "violence": ReadonlyArray<"text" | "image">
        readonly "violence/graphic": ReadonlyArray<"text" | "image">
      }
    }
  >
}
export const CreateModerationResponse = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The unique identifier for the moderation request." }),
  "model": Schema.String.annotate({ "description": "The model used to generate the moderation results." }),
  "results": Schema.Array(Schema.Struct({
    "flagged": Schema.Boolean.annotate({ "description": "Whether any of the below categories are flagged." }),
    "categories": Schema.Struct({
      "hate": Schema.Boolean.annotate({
        "description":
          "Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment."
      }),
      "hate/threatening": Schema.Boolean.annotate({
        "description":
          "Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste."
      }),
      "harassment": Schema.Boolean.annotate({
        "description": "Content that expresses, incites, or promotes harassing language towards any target."
      }),
      "harassment/threatening": Schema.Boolean.annotate({
        "description": "Harassment content that also includes violence or serious harm towards any target."
      }),
      "illicit": Schema.Union([
        Schema.Boolean.annotate({
          "description":
            "Content that includes instructions or advice that facilitate the planning or execution of wrongdoing, or that gives advice or instruction on how to commit illicit acts. For example, \"how to shoplift\" would fit this category."
        }),
        Schema.Null
      ]),
      "illicit/violent": Schema.Union([
        Schema.Boolean.annotate({
          "description":
            "Content that includes instructions or advice that facilitate the planning or execution of wrongdoing that also includes violence, or that gives advice or instruction on the procurement of any weapon."
        }),
        Schema.Null
      ]),
      "self-harm": Schema.Boolean.annotate({
        "description":
          "Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders."
      }),
      "self-harm/intent": Schema.Boolean.annotate({
        "description":
          "Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders."
      }),
      "self-harm/instructions": Schema.Boolean.annotate({
        "description":
          "Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts."
      }),
      "sexual": Schema.Boolean.annotate({
        "description":
          "Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness)."
      }),
      "sexual/minors": Schema.Boolean.annotate({
        "description": "Sexual content that includes an individual who is under 18 years old."
      }),
      "violence": Schema.Boolean.annotate({
        "description": "Content that depicts death, violence, or physical injury."
      }),
      "violence/graphic": Schema.Boolean.annotate({
        "description": "Content that depicts death, violence, or physical injury in graphic detail."
      })
    }).annotate({ "description": "A list of the categories, and whether they are flagged or not." }),
    "category_scores": Schema.Struct({
      "hate": Schema.Number.annotate({ "description": "The score for the category 'hate'." }).check(Schema.isFinite()),
      "hate/threatening": Schema.Number.annotate({ "description": "The score for the category 'hate/threatening'." })
        .check(Schema.isFinite()),
      "harassment": Schema.Number.annotate({ "description": "The score for the category 'harassment'." }).check(
        Schema.isFinite()
      ),
      "harassment/threatening": Schema.Number.annotate({
        "description": "The score for the category 'harassment/threatening'."
      }).check(Schema.isFinite()),
      "illicit": Schema.Number.annotate({ "description": "The score for the category 'illicit'." }).check(
        Schema.isFinite()
      ),
      "illicit/violent": Schema.Number.annotate({ "description": "The score for the category 'illicit/violent'." })
        .check(Schema.isFinite()),
      "self-harm": Schema.Number.annotate({ "description": "The score for the category 'self-harm'." }).check(
        Schema.isFinite()
      ),
      "self-harm/intent": Schema.Number.annotate({ "description": "The score for the category 'self-harm/intent'." })
        .check(Schema.isFinite()),
      "self-harm/instructions": Schema.Number.annotate({
        "description": "The score for the category 'self-harm/instructions'."
      }).check(Schema.isFinite()),
      "sexual": Schema.Number.annotate({ "description": "The score for the category 'sexual'." }).check(
        Schema.isFinite()
      ),
      "sexual/minors": Schema.Number.annotate({ "description": "The score for the category 'sexual/minors'." }).check(
        Schema.isFinite()
      ),
      "violence": Schema.Number.annotate({ "description": "The score for the category 'violence'." }).check(
        Schema.isFinite()
      ),
      "violence/graphic": Schema.Number.annotate({ "description": "The score for the category 'violence/graphic'." })
        .check(Schema.isFinite())
    }).annotate({ "description": "A list of the categories along with their scores as predicted by model." }),
    "category_applied_input_types": Schema.Struct({
      "hate": Schema.Array(Schema.Literal("text")).annotate({
        "description": "The applied input type(s) for the category 'hate'."
      }),
      "hate/threatening": Schema.Array(Schema.Literal("text")).annotate({
        "description": "The applied input type(s) for the category 'hate/threatening'."
      }),
      "harassment": Schema.Array(Schema.Literal("text")).annotate({
        "description": "The applied input type(s) for the category 'harassment'."
      }),
      "harassment/threatening": Schema.Array(Schema.Literal("text")).annotate({
        "description": "The applied input type(s) for the category 'harassment/threatening'."
      }),
      "illicit": Schema.Array(Schema.Literal("text")).annotate({
        "description": "The applied input type(s) for the category 'illicit'."
      }),
      "illicit/violent": Schema.Array(Schema.Literal("text")).annotate({
        "description": "The applied input type(s) for the category 'illicit/violent'."
      }),
      "self-harm": Schema.Array(Schema.Literals(["text", "image"])).annotate({
        "description": "The applied input type(s) for the category 'self-harm'."
      }),
      "self-harm/intent": Schema.Array(Schema.Literals(["text", "image"])).annotate({
        "description": "The applied input type(s) for the category 'self-harm/intent'."
      }),
      "self-harm/instructions": Schema.Array(Schema.Literals(["text", "image"])).annotate({
        "description": "The applied input type(s) for the category 'self-harm/instructions'."
      }),
      "sexual": Schema.Array(Schema.Literals(["text", "image"])).annotate({
        "description": "The applied input type(s) for the category 'sexual'."
      }),
      "sexual/minors": Schema.Array(Schema.Literal("text")).annotate({
        "description": "The applied input type(s) for the category 'sexual/minors'."
      }),
      "violence": Schema.Array(Schema.Literals(["text", "image"])).annotate({
        "description": "The applied input type(s) for the category 'violence'."
      }),
      "violence/graphic": Schema.Array(Schema.Literals(["text", "image"])).annotate({
        "description": "The applied input type(s) for the category 'violence/graphic'."
      })
    }).annotate({ "description": "A list of the categories along with the input type(s) that the score applies to." })
  })).annotate({ "description": "A list of moderation objects." })
}).annotate({ "description": "Represents if a given text input is potentially harmful." })
export type CreateSpeechRequest = {
  readonly "model": string | "tts-1" | "tts-1-hd" | "gpt-4o-mini-tts" | "gpt-4o-mini-tts-2025-12-15"
  readonly "input": string
  readonly "instructions"?: string
  readonly "voice":
    | string
    | "alloy"
    | "ash"
    | "ballad"
    | "coral"
    | "echo"
    | "sage"
    | "shimmer"
    | "verse"
    | "marin"
    | "cedar"
    | { readonly "id": string }
  readonly "response_format"?: "mp3" | "opus" | "aac" | "flac" | "wav" | "pcm"
  readonly "speed"?: number
  readonly "stream_format"?: "sse" | "audio"
}
export const CreateSpeechRequest = Schema.Struct({
  "model": Schema.Union([
    Schema.String,
    Schema.Literals(["tts-1", "tts-1-hd", "gpt-4o-mini-tts", "gpt-4o-mini-tts-2025-12-15"])
  ]).annotate({
    "description":
      "One of the available [TTS models](/docs/models#tts): `tts-1`, `tts-1-hd`, `gpt-4o-mini-tts`, or `gpt-4o-mini-tts-2025-12-15`.\n"
  }),
  "input": Schema.String.annotate({
    "description": "The text to generate audio for. The maximum length is 4096 characters."
  }).check(Schema.isMaxLength(4096)),
  "instructions": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "Control the voice of your generated audio with additional instructions. Does not work with `tts-1` or `tts-1-hd`."
    }).check(Schema.isMaxLength(4096))
  ),
  "voice": Schema.Union([
    Schema.Union([
      Schema.String,
      Schema.Literals(["alloy", "ash", "ballad", "coral", "echo", "sage", "shimmer", "verse", "marin", "cedar"])
    ]),
    Schema.Struct({ "id": Schema.String.annotate({ "description": "The custom voice ID, e.g. `voice_1234`." }) })
      .annotate({ "description": "Custom voice reference." })
  ]).annotate({
    "title": "Voice",
    "description":
      "The voice to use when generating the audio. Supported built-in voices are `alloy`, `ash`, `ballad`, `coral`, `echo`, `fable`, `onyx`, `nova`, `sage`, `shimmer`, `verse`, `marin`, and `cedar`. You may also provide a custom voice object with an `id`, for example `{ \"id\": \"voice_1234\" }`. Previews of the voices are available in the [Text to speech guide](/docs/guides/text-to-speech#voice-options)."
  }),
  "response_format": Schema.optionalKey(
    Schema.Literals(["mp3", "opus", "aac", "flac", "wav", "pcm"]).annotate({
      "description": "The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`."
    })
  ),
  "speed": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "The speed of the generated audio. Select a value from `0.25` to `4.0`. `1.0` is the default."
    }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0.25)).check(Schema.isLessThanOrEqualTo(4))
  ),
  "stream_format": Schema.optionalKey(
    Schema.Literals(["sse", "audio"]).annotate({
      "description":
        "The format to stream the audio in. Supported formats are `sse` and `audio`. `sse` is not supported for `tts-1` or `tts-1-hd`."
    })
  )
})
export type CreateTranscriptionResponseJson = {
  readonly "text": string
  readonly "logprobs"?: ReadonlyArray<
    { readonly "token"?: string; readonly "logprob"?: number; readonly "bytes"?: ReadonlyArray<number> }
  >
  readonly "usage"?: {
    readonly "type": "tokens"
    readonly "input_tokens": number
    readonly "input_token_details"?: { readonly "text_tokens"?: number; readonly "audio_tokens"?: number }
    readonly "output_tokens": number
    readonly "total_tokens": number
  } | { readonly "type": "duration"; readonly "seconds": number }
}
export const CreateTranscriptionResponseJson = Schema.Struct({
  "text": Schema.String.annotate({ "description": "The transcribed text." }),
  "logprobs": Schema.optionalKey(
    Schema.Array(Schema.Struct({
      "token": Schema.optionalKey(Schema.String.annotate({ "description": "The token in the transcription." })),
      "logprob": Schema.optionalKey(
        Schema.Number.annotate({ "description": "The log probability of the token." }).check(Schema.isFinite())
      ),
      "bytes": Schema.optionalKey(
        Schema.Array(Schema.Number.check(Schema.isFinite())).annotate({ "description": "The bytes of the token." })
      )
    })).annotate({
      "description":
        "The log probabilities of the tokens in the transcription. Only returned with the models `gpt-4o-transcribe` and `gpt-4o-mini-transcribe` if `logprobs` is added to the `include` array.\n"
    })
  ),
  "usage": Schema.optionalKey(
    Schema.Union([
      Schema.Struct({
        "type": Schema.Literal("tokens").annotate({
          "description": "The type of the usage object. Always `tokens` for this variant."
        }),
        "input_tokens": Schema.Number.annotate({ "description": "Number of input tokens billed for this request." })
          .check(Schema.isInt()),
        "input_token_details": Schema.optionalKey(
          Schema.Struct({
            "text_tokens": Schema.optionalKey(
              Schema.Number.annotate({ "description": "Number of text tokens billed for this request." }).check(
                Schema.isInt()
              )
            ),
            "audio_tokens": Schema.optionalKey(
              Schema.Number.annotate({ "description": "Number of audio tokens billed for this request." }).check(
                Schema.isInt()
              )
            )
          }).annotate({ "description": "Details about the input tokens billed for this request." })
        ),
        "output_tokens": Schema.Number.annotate({ "description": "Number of output tokens generated." }).check(
          Schema.isInt()
        ),
        "total_tokens": Schema.Number.annotate({ "description": "Total number of tokens used (input + output)." })
          .check(Schema.isInt())
      }).annotate({ "title": "Token Usage", "description": "Usage statistics for models billed by token usage." }),
      Schema.Struct({
        "type": Schema.Literal("duration").annotate({
          "description": "The type of the usage object. Always `duration` for this variant."
        }),
        "seconds": Schema.Number.annotate({ "description": "Duration of the input audio in seconds." }).check(
          Schema.isFinite()
        )
      }).annotate({
        "title": "Duration Usage",
        "description": "Usage statistics for models billed by audio input duration."
      })
    ], { mode: "oneOf" }).annotate({ "description": "Token usage statistics for the request." })
  )
}).annotate({ "description": "Represents a transcription response returned by model, based on the provided input." })
export type CreateTranslationRequest = {
  readonly "file": string
  readonly "model": string | "whisper-1"
  readonly "prompt"?: string
  readonly "response_format"?: "json" | "text" | "srt" | "verbose_json" | "vtt"
  readonly "temperature"?: number
}
export const CreateTranslationRequest = Schema.Struct({
  "file": Schema.String.annotate({
    "description":
      "The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.\n",
    "format": "binary"
  }),
  "model": Schema.Union([Schema.String, Schema.Literal("whisper-1")]).annotate({
    "description":
      "ID of the model to use. Only `whisper-1` (which is powered by our open source Whisper V2 model) is currently available.\n"
  }),
  "prompt": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "An optional text to guide the model's style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should be in English.\n"
    })
  ),
  "response_format": Schema.optionalKey(
    Schema.Literals(["json", "text", "srt", "verbose_json", "vtt"]).annotate({
      "description":
        "The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.\n"
    })
  ),
  "temperature": Schema.optionalKey(
    Schema.Number.annotate({
      "description":
        "The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.\n"
    }).check(Schema.isFinite())
  )
})
export type CreateTranslationResponseJson = { readonly "text": string }
export const CreateTranslationResponseJson = Schema.Struct({ "text": Schema.String })
export type CreateVectorStoreFileBatchRequest = { readonly "file_ids": unknown; readonly [x: string]: unknown } | {
  readonly "files": unknown
  readonly [x: string]: unknown
}
export const CreateVectorStoreFileBatchRequest = Schema.Union([
  Schema.StructWithRest(Schema.Struct({ "file_ids": Schema.Unknown }), [Schema.Record(Schema.String, Schema.Json)]),
  Schema.StructWithRest(Schema.Struct({ "files": Schema.Unknown }), [Schema.Record(Schema.String, Schema.Json)])
])
export type CreateVoiceConsentRequest = {
  readonly "name": string
  readonly "recording": string
  readonly "language": string
}
export const CreateVoiceConsentRequest = Schema.Struct({
  "name": Schema.String.annotate({ "description": "The label to use for this consent recording." }),
  "recording": Schema.String.annotate({
    "description":
      "The consent audio recording file. Maximum size is 10 MiB.\n\nSupported MIME types:\n`audio/mpeg`, `audio/wav`, `audio/x-wav`, `audio/ogg`, `audio/aac`, `audio/flac`, `audio/webm`, `audio/mp4`.\n",
    "format": "binary"
  }),
  "language": Schema.String.annotate({
    "description": "The BCP 47 language tag for the consent phrase (for example, `en-US`)."
  })
})
export type CreateVoiceRequest = {
  readonly "name": string
  readonly "audio_sample": string
  readonly "consent": string
}
export const CreateVoiceRequest = Schema.Struct({
  "name": Schema.String.annotate({ "description": "The name of the new voice." }),
  "audio_sample": Schema.String.annotate({
    "description":
      "The sample audio recording file. Maximum size is 10 MiB.\n\nSupported MIME types:\n`audio/mpeg`, `audio/wav`, `audio/x-wav`, `audio/ogg`, `audio/aac`, `audio/flac`, `audio/webm`, `audio/mp4`.\n",
    "format": "binary"
  }),
  "consent": Schema.String.annotate({ "description": "The consent recording ID (for example, `cons_1234`)." })
})
export type CustomToolCall = {
  readonly "type": "custom_tool_call"
  readonly "id"?: string
  readonly "call_id": string
  readonly "name": string
  readonly "input": string
}
export const CustomToolCall = Schema.Struct({
  "type": Schema.Literal("custom_tool_call").annotate({
    "description": "The type of the custom tool call. Always `custom_tool_call`.\n"
  }),
  "id": Schema.optionalKey(
    Schema.String.annotate({ "description": "The unique ID of the custom tool call in the OpenAI platform.\n" })
  ),
  "call_id": Schema.String.annotate({
    "description": "An identifier used to map this custom tool call to a tool call output.\n"
  }),
  "name": Schema.String.annotate({ "description": "The name of the custom tool being called.\n" }),
  "input": Schema.String.annotate({ "description": "The input for the custom tool call generated by the model.\n" })
}).annotate({ "title": "Custom tool call", "description": "A call to a custom tool created by the model.\n" })
export type CustomToolChatCompletions = {
  readonly "type": "custom"
  readonly "custom": {
    readonly "name": string
    readonly "description"?: string
    readonly "format"?: { readonly "type": "text" } | {
      readonly "type": "grammar"
      readonly "grammar": { readonly "definition": string; readonly "syntax": "lark" | "regex" }
    }
  }
}
export const CustomToolChatCompletions = Schema.Struct({
  "type": Schema.Literal("custom").annotate({ "description": "The type of the custom tool. Always `custom`." }),
  "custom": Schema.Struct({
    "name": Schema.String.annotate({
      "description": "The name of the custom tool, used to identify it in tool calls."
    }),
    "description": Schema.optionalKey(
      Schema.String.annotate({
        "description": "Optional description of the custom tool, used to provide more context.\n"
      })
    ),
    "format": Schema.optionalKey(
      Schema.Union([
        Schema.Struct({
          "type": Schema.Literal("text").annotate({ "description": "Unconstrained text format. Always `text`." })
        }).annotate({ "title": "Text format", "description": "Unconstrained free-form text." }),
        Schema.Struct({
          "type": Schema.Literal("grammar").annotate({ "description": "Grammar format. Always `grammar`." }),
          "grammar": Schema.Struct({
            "definition": Schema.String.annotate({ "description": "The grammar definition." }),
            "syntax": Schema.Literals(["lark", "regex"]).annotate({
              "description": "The syntax of the grammar definition. One of `lark` or `regex`."
            })
          }).annotate({ "title": "Grammar format", "description": "Your chosen grammar." })
        }).annotate({ "title": "Grammar format", "description": "A grammar defined by the user." })
      ], { mode: "oneOf" }).annotate({
        "description": "The input format for the custom tool. Default is unconstrained text.\n"
      })
    )
  }).annotate({ "title": "Custom tool properties", "description": "Properties of the custom tool.\n" })
}).annotate({ "title": "Custom tool", "description": "A custom tool that processes input using a specified format.\n" })
export type DeleteAssistantResponse = {
  readonly "id": string
  readonly "deleted": boolean
  readonly "object": "assistant.deleted"
}
export const DeleteAssistantResponse = Schema.Struct({
  "id": Schema.String,
  "deleted": Schema.Boolean,
  "object": Schema.Literal("assistant.deleted")
})
export type DeleteCertificateResponse = { readonly "object": "certificate.deleted"; readonly "id": string }
export const DeleteCertificateResponse = Schema.Struct({
  "object": Schema.Literal("certificate.deleted").annotate({
    "description": "The object type, must be `certificate.deleted`."
  }),
  "id": Schema.String.annotate({ "description": "The ID of the certificate that was deleted." })
})
export type DeleteFileResponse = { readonly "id": string; readonly "object": "file"; readonly "deleted": boolean }
export const DeleteFileResponse = Schema.Struct({
  "id": Schema.String,
  "object": Schema.Literal("file"),
  "deleted": Schema.Boolean
})
export type DeleteFineTuningCheckpointPermissionResponse = {
  readonly "id": string
  readonly "object": "checkpoint.permission"
  readonly "deleted": boolean
}
export const DeleteFineTuningCheckpointPermissionResponse = Schema.Struct({
  "id": Schema.String.annotate({
    "description": "The ID of the fine-tuned model checkpoint permission that was deleted."
  }),
  "object": Schema.Literal("checkpoint.permission").annotate({
    "description": "The object type, which is always \"checkpoint.permission\"."
  }),
  "deleted": Schema.Boolean.annotate({
    "description": "Whether the fine-tuned model checkpoint permission was successfully deleted."
  })
})
export type DeleteMessageResponse = {
  readonly "id": string
  readonly "deleted": boolean
  readonly "object": "thread.message.deleted"
}
export const DeleteMessageResponse = Schema.Struct({
  "id": Schema.String,
  "deleted": Schema.Boolean,
  "object": Schema.Literal("thread.message.deleted")
})
export type DeleteModelResponse = { readonly "id": string; readonly "deleted": boolean; readonly "object": string }
export const DeleteModelResponse = Schema.Struct({
  "id": Schema.String,
  "deleted": Schema.Boolean,
  "object": Schema.String
})
export type DeleteThreadResponse = {
  readonly "id": string
  readonly "deleted": boolean
  readonly "object": "thread.deleted"
}
export const DeleteThreadResponse = Schema.Struct({
  "id": Schema.String,
  "deleted": Schema.Boolean,
  "object": Schema.Literal("thread.deleted")
})
export type DeleteVectorStoreFileResponse = {
  readonly "id": string
  readonly "deleted": boolean
  readonly "object": "vector_store.file.deleted"
}
export const DeleteVectorStoreFileResponse = Schema.Struct({
  "id": Schema.String,
  "deleted": Schema.Boolean,
  "object": Schema.Literal("vector_store.file.deleted")
})
export type DeleteVectorStoreResponse = {
  readonly "id": string
  readonly "deleted": boolean
  readonly "object": "vector_store.deleted"
}
export const DeleteVectorStoreResponse = Schema.Struct({
  "id": Schema.String,
  "deleted": Schema.Boolean,
  "object": Schema.Literal("vector_store.deleted")
})
export type DeletedRoleAssignmentResource = { readonly "object": string; readonly "deleted": boolean }
export const DeletedRoleAssignmentResource = Schema.Struct({
  "object": Schema.String.annotate({
    "description": "Identifier for the deleted assignment, such as `group.role.deleted` or `user.role.deleted`."
  }),
  "deleted": Schema.Boolean.annotate({ "description": "Whether the assignment was removed." })
}).annotate({ "description": "Confirmation payload returned after unassigning a role." })
export type DoneEvent = { readonly "event": "done"; readonly "data": "[DONE]" }
export const DoneEvent = Schema.Struct({ "event": Schema.Literal("done"), "data": Schema.Literal("[DONE]") }).annotate({
  "description": "Occurs when a stream ends."
})
export type Embedding = {
  readonly "index": number
  readonly "embedding": ReadonlyArray<number>
  readonly "object": "embedding"
}
export const Embedding = Schema.Struct({
  "index": Schema.Number.annotate({ "description": "The index of the embedding in the list of embeddings." }).check(
    Schema.isInt()
  ),
  "embedding": Schema.Array(Schema.Number.annotate({ "format": "float" }).check(Schema.isFinite())).annotate({
    "description":
      "The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](/docs/guides/embeddings).\n"
  }),
  "object": Schema.Literal("embedding").annotate({ "description": "The object type, which is always \"embedding\"." })
}).annotate({ "description": "Represents an embedding vector returned by embedding endpoint.\n" })
export type Error = {
  readonly "code": string | null
  readonly "message": string
  readonly "param": string | null
  readonly "type": string
}
export const Error = Schema.Struct({
  "code": Schema.Union([Schema.String, Schema.Null]),
  "message": Schema.String,
  "param": Schema.Union([Schema.String, Schema.Null]),
  "type": Schema.String
})
export type EvalApiError = { readonly "code": string; readonly "message": string }
export const EvalApiError = Schema.Struct({
  "code": Schema.String.annotate({ "description": "The error code." }),
  "message": Schema.String.annotate({ "description": "The error message." })
}).annotate({ "title": "EvalApiError", "description": "An object representing an error response from the Eval API.\n" })
export type EvalCustomDataSourceConfig = { readonly "type": "custom"; readonly "schema": {} }
export const EvalCustomDataSourceConfig = Schema.Struct({
  "type": Schema.Literal("custom").annotate({ "description": "The type of data source. Always `custom`." }),
  "schema": Schema.Struct({}).annotate({
    "description":
      "The json schema for the run data source items.\nLearn how to build JSON schemas [here](https://json-schema.org/).\n"
  })
}).annotate({
  "title": "CustomDataSourceConfig",
  "description":
    "A CustomDataSourceConfig which specifies the schema of your `item` and optionally `sample` namespaces.\nThe response schema defines the shape of the data that will be:\n- Used to define your testing criteria and\n- What data is required when creating a run\n"
})
export type EvalGraderPython = {
  readonly "type": "python"
  readonly "name": string
  readonly "source": string
  readonly "image_tag"?: string
  readonly "pass_threshold"?: number
}
export const EvalGraderPython = Schema.Struct({
  "type": Schema.Literal("python").annotate({ "description": "The object type, which is always `python`." }),
  "name": Schema.String.annotate({ "description": "The name of the grader." }),
  "source": Schema.String.annotate({ "description": "The source code of the python script." }),
  "image_tag": Schema.optionalKey(
    Schema.String.annotate({ "description": "The image tag to use for the python script." })
  ),
  "pass_threshold": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The threshold for the score." }).check(Schema.isFinite())
  )
}).annotate({
  "title": "PythonGrader",
  "description": "A PythonGrader object that runs a python script on the input.\n"
})
export type EvalGraderStringCheck = {
  readonly "type": "string_check"
  readonly "name": string
  readonly "input": string
  readonly "reference": string
  readonly "operation": "eq" | "ne" | "like" | "ilike"
}
export const EvalGraderStringCheck = Schema.Struct({
  "type": Schema.Literal("string_check").annotate({
    "description": "The object type, which is always `string_check`."
  }),
  "name": Schema.String.annotate({ "description": "The name of the grader." }),
  "input": Schema.String.annotate({ "description": "The input text. This may include template strings." }),
  "reference": Schema.String.annotate({ "description": "The reference text. This may include template strings." }),
  "operation": Schema.Literals(["eq", "ne", "like", "ilike"]).annotate({
    "description": "The string check operation to perform. One of `eq`, `ne`, `like`, or `ilike`."
  })
}).annotate({
  "title": "StringCheckGrader",
  "description":
    "A StringCheckGrader object that performs a string comparison between input and reference using a specified operation.\n"
})
export type EvalGraderTextSimilarity = {
  readonly "type": "text_similarity"
  readonly "name": string
  readonly "input": string
  readonly "reference": string
  readonly "evaluation_metric":
    | "cosine"
    | "fuzzy_match"
    | "bleu"
    | "gleu"
    | "meteor"
    | "rouge_1"
    | "rouge_2"
    | "rouge_3"
    | "rouge_4"
    | "rouge_5"
    | "rouge_l"
  readonly "pass_threshold": number
}
export const EvalGraderTextSimilarity = Schema.Struct({
  "type": Schema.Literal("text_similarity").annotate({ "description": "The type of grader." }),
  "name": Schema.String.annotate({ "description": "The name of the grader." }),
  "input": Schema.String.annotate({ "description": "The text being graded." }),
  "reference": Schema.String.annotate({ "description": "The text being graded against." }),
  "evaluation_metric": Schema.Literals([
    "cosine",
    "fuzzy_match",
    "bleu",
    "gleu",
    "meteor",
    "rouge_1",
    "rouge_2",
    "rouge_3",
    "rouge_4",
    "rouge_5",
    "rouge_l"
  ]).annotate({
    "description":
      "The evaluation metric to use. One of `cosine`, `fuzzy_match`, `bleu`, \n`gleu`, `meteor`, `rouge_1`, `rouge_2`, `rouge_3`, `rouge_4`, `rouge_5`, \nor `rouge_l`.\n"
  }),
  "pass_threshold": Schema.Number.annotate({ "description": "The threshold for the score." }).check(Schema.isFinite())
}).annotate({
  "title": "TextSimilarityGrader",
  "description": "A TextSimilarityGrader object which grades text based on similarity metrics.\n"
})
export type EvalItemContentOutputText = { readonly "type": "output_text"; readonly "text": string }
export const EvalItemContentOutputText = Schema.Struct({
  "type": Schema.Literal("output_text").annotate({
    "description": "The type of the output text. Always `output_text`.\n"
  }),
  "text": Schema.String.annotate({ "description": "The text output from the model.\n" })
}).annotate({ "title": "Output text", "description": "A text output from the model.\n" })
export type EvalItemContentText = string
export const EvalItemContentText = Schema.String.annotate({
  "title": "Text input",
  "description": "A text input to the model.\n"
})
export type EvalItemInputImage = {
  readonly "type": "input_image"
  readonly "image_url": string
  readonly "detail"?: string
}
export const EvalItemInputImage = Schema.Struct({
  "type": Schema.Literal("input_image").annotate({
    "description": "The type of the image input. Always `input_image`.\n"
  }),
  "image_url": Schema.String.annotate({ "description": "The URL of the image input.\n" }),
  "detail": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`.\n"
    })
  )
}).annotate({ "title": "Input image", "description": "An image input block used within EvalItem content arrays." })
export type EvalJsonlFileContentSource = {
  readonly "type": "file_content"
  readonly "content": ReadonlyArray<{ readonly "item": {}; readonly "sample"?: {} }>
}
export const EvalJsonlFileContentSource = Schema.Struct({
  "type": Schema.Literal("file_content").annotate({
    "description": "The type of jsonl source. Always `file_content`."
  }),
  "content": Schema.Array(Schema.Struct({ "item": Schema.Struct({}), "sample": Schema.optionalKey(Schema.Struct({})) }))
    .annotate({ "description": "The content of the jsonl file." })
}).annotate({ "title": "EvalJsonlFileContentSource" })
export type EvalJsonlFileIdSource = { readonly "type": "file_id"; readonly "id": string }
export const EvalJsonlFileIdSource = Schema.Struct({
  "type": Schema.Literal("file_id").annotate({ "description": "The type of jsonl source. Always `file_id`." }),
  "id": Schema.String.annotate({ "description": "The identifier of the file." })
}).annotate({ "title": "EvalJsonlFileIdSource" })
export type EvalResponsesSource = {
  readonly "type": "responses"
  readonly "metadata"?: {} | null
  readonly "model"?: string | null
  readonly "instructions_search"?: string | null
  readonly "created_after"?: number | null
  readonly "created_before"?: number | null
  readonly "reasoning_effort"?: "none" | "minimal" | "low" | "medium" | "high" | "xhigh" | null | null
  readonly "temperature"?: number | null
  readonly "top_p"?: number | null
  readonly "users"?: ReadonlyArray<string> | null
  readonly "tools"?: ReadonlyArray<string> | null
}
export const EvalResponsesSource = Schema.Struct({
  "type": Schema.Literal("responses").annotate({ "description": "The type of run data source. Always `responses`." }),
  "metadata": Schema.optionalKey(
    Schema.Union([
      Schema.Struct({}).annotate({
        "description": "Metadata filter for the responses. This is a query parameter used to select responses."
      }),
      Schema.Null
    ])
  ),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "The name of the model to find responses for. This is a query parameter used to select responses."
      }),
      Schema.Null
    ])
  ),
  "instructions_search": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "Optional string to search the 'instructions' field. This is a query parameter used to select responses."
      }),
      Schema.Null
    ])
  ),
  "created_after": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "Only include items created after this timestamp (inclusive). This is a query parameter used to select responses."
      }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)),
      Schema.Null
    ])
  ),
  "created_before": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "Only include items created before this timestamp (inclusive). This is a query parameter used to select responses."
      }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)),
      Schema.Null
    ])
  ),
  "reasoning_effort": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        Schema.Literals(["none", "minimal", "low", "medium", "high", "xhigh"]).annotate({
          "description":
            "Constrains effort on reasoning for\n[reasoning models](https://platform.openai.com/docs/guides/reasoning).\nCurrently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing\nreasoning effort can result in faster responses and fewer tokens used\non reasoning in a response.\n\n- `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.\n- All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.\n- The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.\n- `xhigh` is supported for all models after `gpt-5.1-codex-max`.\n"
        }),
        Schema.Null
      ]).annotate({
        "description": "Optional reasoning effort parameter. This is a query parameter used to select responses."
      }),
      Schema.Null
    ])
  ),
  "temperature": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description": "Sampling temperature. This is a query parameter used to select responses."
      }).check(Schema.isFinite()),
      Schema.Null
    ])
  ),
  "top_p": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description": "Nucleus sampling parameter. This is a query parameter used to select responses."
      }).check(Schema.isFinite()),
      Schema.Null
    ])
  ),
  "users": Schema.optionalKey(
    Schema.Union([
      Schema.Array(Schema.String).annotate({
        "description": "List of user identifiers. This is a query parameter used to select responses."
      }),
      Schema.Null
    ])
  ),
  "tools": Schema.optionalKey(
    Schema.Union([
      Schema.Array(Schema.String).annotate({
        "description": "List of tool names. This is a query parameter used to select responses."
      }),
      Schema.Null
    ])
  )
}).annotate({
  "title": "EvalResponsesSource",
  "description": "A EvalResponsesSource object describing a run data source configuration.\n"
})
export type EvalRunOutputItemResult = {
  readonly "name": string
  readonly "type"?: string
  readonly "score": number
  readonly "passed": boolean
  readonly "sample"?: {} | null
}
export const EvalRunOutputItemResult = Schema.Struct({
  "name": Schema.String.annotate({ "description": "The name of the grader." }),
  "type": Schema.optionalKey(
    Schema.String.annotate({ "description": "The grader type (for example, \"string-check-grader\")." })
  ),
  "score": Schema.Number.annotate({ "description": "The numeric score produced by the grader." }).check(
    Schema.isFinite()
  ),
  "passed": Schema.Boolean.annotate({ "description": "Whether the grader considered the output a pass." }),
  "sample": Schema.optionalKey(
    Schema.Union([Schema.Struct({}), Schema.Null]).annotate({
      "description": "Optional sample or intermediate data produced by the grader."
    })
  )
}).annotate({
  "title": "EvalRunOutputItemResult",
  "description": "A single grader result for an evaluation run output item.\n"
})
export type FileExpirationAfter = { readonly "anchor": "created_at"; readonly "seconds": number }
export const FileExpirationAfter = Schema.Struct({
  "anchor": Schema.Literal("created_at").annotate({
    "description": "Anchor timestamp after which the expiration policy applies. Supported anchors: `created_at`."
  }),
  "seconds": Schema.Number.annotate({
    "description":
      "The number of seconds after the anchor time that the file will expire. Must be between 3600 (1 hour) and 2592000 (30 days)."
  }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(3600)).check(Schema.isLessThanOrEqualTo(2592000))
}).annotate({
  "title": "File expiration policy",
  "description":
    "The expiration policy for a file. By default, files with `purpose=batch` expire after 30 days and all other files are persisted until they are manually deleted."
})
export type FilePath = { readonly "type": "file_path"; readonly "file_id": string; readonly "index": number }
export const FilePath = Schema.Struct({
  "type": Schema.Literal("file_path").annotate({ "description": "The type of the file path. Always `file_path`.\n" }),
  "file_id": Schema.String.annotate({ "description": "The ID of the file.\n" }),
  "index": Schema.Number.annotate({ "description": "The index of the file in the list of files.\n" }).check(
    Schema.isInt()
  )
}).annotate({ "title": "File path", "description": "A path to a file.\n" })
export type FileSearchRanker = "auto" | "default_2024_08_21"
export const FileSearchRanker = Schema.Literals(["auto", "default_2024_08_21"]).annotate({
  "description": "The ranker to use for the file search. If not specified will use the `auto` ranker."
})
export type FineTuneDPOHyperparameters = {
  readonly "beta"?: "auto" | number
  readonly "batch_size"?: "auto" | number
  readonly "learning_rate_multiplier"?: "auto" | number
  readonly "n_epochs"?: "auto" | number
}
export const FineTuneDPOHyperparameters = Schema.Struct({
  "beta": Schema.optionalKey(
    Schema.Union([
      Schema.Literal("auto"),
      Schema.Number.check(Schema.isFinite()).check(Schema.isLessThanOrEqualTo(2)).check(Schema.isGreaterThan(0))
    ], { mode: "oneOf" }).annotate({
      "description":
        "The beta value for the DPO method. A higher beta value will increase the weight of the penalty between the policy and reference model.\n"
    })
  ),
  "batch_size": Schema.optionalKey(
    Schema.Union([
      Schema.Literal("auto"),
      Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(Schema.isLessThanOrEqualTo(256))
    ], { mode: "oneOf" }).annotate({
      "description":
        "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"
    })
  ),
  "learning_rate_multiplier": Schema.optionalKey(
    Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isFinite()).check(Schema.isGreaterThan(0))], {
      mode: "oneOf"
    }).annotate({
      "description":
        "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"
    })
  ),
  "n_epochs": Schema.optionalKey(
    Schema.Union([
      Schema.Literal("auto"),
      Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(Schema.isLessThanOrEqualTo(50))
    ], { mode: "oneOf" }).annotate({
      "description":
        "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"
    })
  )
}).annotate({ "description": "The hyperparameters used for the DPO fine-tuning job." })
export type FineTuneReinforcementHyperparameters = {
  readonly "batch_size"?: "auto" | number
  readonly "learning_rate_multiplier"?: "auto" | number
  readonly "n_epochs"?: "auto" | number
  readonly "reasoning_effort"?: "default" | "low" | "medium" | "high"
  readonly "compute_multiplier"?: "auto" | number
  readonly "eval_interval"?: "auto" | number
  readonly "eval_samples"?: "auto" | number
}
export const FineTuneReinforcementHyperparameters = Schema.Struct({
  "batch_size": Schema.optionalKey(
    Schema.Union([
      Schema.Literal("auto"),
      Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(Schema.isLessThanOrEqualTo(256))
    ], { mode: "oneOf" }).annotate({
      "description":
        "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"
    })
  ),
  "learning_rate_multiplier": Schema.optionalKey(
    Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isFinite()).check(Schema.isGreaterThan(0))], {
      mode: "oneOf"
    }).annotate({
      "description":
        "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"
    })
  ),
  "n_epochs": Schema.optionalKey(
    Schema.Union([
      Schema.Literal("auto"),
      Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(Schema.isLessThanOrEqualTo(50))
    ], { mode: "oneOf" }).annotate({
      "description":
        "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"
    })
  ),
  "reasoning_effort": Schema.optionalKey(
    Schema.Literals(["default", "low", "medium", "high"]).annotate({ "description": "Level of reasoning effort.\n" })
  ),
  "compute_multiplier": Schema.optionalKey(
    Schema.Union([
      Schema.Literal("auto"),
      Schema.Number.check(Schema.isFinite()).check(Schema.isLessThanOrEqualTo(10)).check(Schema.isGreaterThan(0.00001))
    ], { mode: "oneOf" }).annotate({
      "description": "Multiplier on amount of compute used for exploring search space during training.\n"
    })
  ),
  "eval_interval": Schema.optionalKey(
    Schema.Union(
      [Schema.Literal("auto"), Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1))],
      { mode: "oneOf" }
    ).annotate({ "description": "The number of training steps between evaluation runs.\n" })
  ),
  "eval_samples": Schema.optionalKey(
    Schema.Union(
      [Schema.Literal("auto"), Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1))],
      { mode: "oneOf" }
    ).annotate({ "description": "Number of evaluation samples to generate per training step.\n" })
  )
}).annotate({ "description": "The hyperparameters used for the reinforcement fine-tuning job." })
export type FineTuneSupervisedHyperparameters = {
  readonly "batch_size"?: "auto" | number
  readonly "learning_rate_multiplier"?: "auto" | number
  readonly "n_epochs"?: "auto" | number
}
export const FineTuneSupervisedHyperparameters = Schema.Struct({
  "batch_size": Schema.optionalKey(
    Schema.Union([
      Schema.Literal("auto"),
      Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(Schema.isLessThanOrEqualTo(256))
    ], { mode: "oneOf" }).annotate({
      "description":
        "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"
    })
  ),
  "learning_rate_multiplier": Schema.optionalKey(
    Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isFinite()).check(Schema.isGreaterThan(0))], {
      mode: "oneOf"
    }).annotate({
      "description":
        "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"
    })
  ),
  "n_epochs": Schema.optionalKey(
    Schema.Union([
      Schema.Literal("auto"),
      Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(Schema.isLessThanOrEqualTo(50))
    ], { mode: "oneOf" }).annotate({
      "description":
        "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"
    })
  )
}).annotate({ "description": "The hyperparameters used for the fine-tuning job." })
export type FineTuningCheckpointPermission = {
  readonly "id": string
  readonly "created_at": number
  readonly "project_id": string
  readonly "object": "checkpoint.permission"
}
export const FineTuningCheckpointPermission = Schema.Struct({
  "id": Schema.String.annotate({
    "description": "The permission identifier, which can be referenced in the API endpoints."
  }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the permission was created."
  }).check(Schema.isInt()),
  "project_id": Schema.String.annotate({ "description": "The project identifier that the permission is for." }),
  "object": Schema.Literal("checkpoint.permission").annotate({
    "description": "The object type, which is always \"checkpoint.permission\"."
  })
}).annotate({
  "title": "FineTuningCheckpointPermission",
  "description": "The `checkpoint.permission` object represents a permission for a fine-tuned model checkpoint.\n"
})
export type FineTuningIntegration = {
  readonly "type": "wandb"
  readonly "wandb": {
    readonly "project": string
    readonly "name"?: string | null
    readonly "entity"?: string | null
    readonly "tags"?: ReadonlyArray<string>
  }
}
export const FineTuningIntegration = Schema.Struct({
  "type": Schema.Literal("wandb").annotate({
    "description": "The type of the integration being enabled for the fine-tuning job"
  }),
  "wandb": Schema.Struct({
    "project": Schema.String.annotate({
      "description": "The name of the project that the new run will be created under.\n"
    }),
    "name": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description": "A display name to set for the run. If not set, we will use the Job ID as the name.\n"
        }),
        Schema.Null
      ])
    ),
    "entity": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description":
            "The entity to use for the run. This allows you to set the team or username of the WandB user that you would\nlike associated with the run. If not set, the default entity for the registered WandB API key is used.\n"
        }),
        Schema.Null
      ])
    ),
    "tags": Schema.optionalKey(
      Schema.Array(Schema.String).annotate({
        "description":
          "A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some\ndefault tags are generated by OpenAI: \"openai/finetune\", \"openai/{base-model}\", \"openai/{ftjob-abcdef}\".\n"
      })
    )
  }).annotate({
    "description":
      "The settings for your integration with Weights and Biases. This payload specifies the project that\nmetrics will be sent to. Optionally, you can set an explicit display name for your run, add tags\nto your run, and set a default entity (team, username, etc) to be associated with your run.\n"
  })
}).annotate({ "title": "Fine-Tuning Job Integration" })
export type FineTuningJobCheckpoint = {
  readonly "id": string
  readonly "created_at": number
  readonly "fine_tuned_model_checkpoint": string
  readonly "step_number": number
  readonly "metrics": {
    readonly "step"?: number
    readonly "train_loss"?: number
    readonly "train_mean_token_accuracy"?: number
    readonly "valid_loss"?: number
    readonly "valid_mean_token_accuracy"?: number
    readonly "full_valid_loss"?: number
    readonly "full_valid_mean_token_accuracy"?: number
  }
  readonly "fine_tuning_job_id": string
  readonly "object": "fine_tuning.job.checkpoint"
}
export const FineTuningJobCheckpoint = Schema.Struct({
  "id": Schema.String.annotate({
    "description": "The checkpoint identifier, which can be referenced in the API endpoints."
  }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the checkpoint was created."
  }).check(Schema.isInt()),
  "fine_tuned_model_checkpoint": Schema.String.annotate({
    "description": "The name of the fine-tuned checkpoint model that is created."
  }),
  "step_number": Schema.Number.annotate({ "description": "The step number that the checkpoint was created at." }).check(
    Schema.isInt()
  ),
  "metrics": Schema.Struct({
    "step": Schema.optionalKey(Schema.Number.check(Schema.isFinite())),
    "train_loss": Schema.optionalKey(Schema.Number.check(Schema.isFinite())),
    "train_mean_token_accuracy": Schema.optionalKey(Schema.Number.check(Schema.isFinite())),
    "valid_loss": Schema.optionalKey(Schema.Number.check(Schema.isFinite())),
    "valid_mean_token_accuracy": Schema.optionalKey(Schema.Number.check(Schema.isFinite())),
    "full_valid_loss": Schema.optionalKey(Schema.Number.check(Schema.isFinite())),
    "full_valid_mean_token_accuracy": Schema.optionalKey(Schema.Number.check(Schema.isFinite()))
  }).annotate({ "description": "Metrics at the step number during the fine-tuning job." }),
  "fine_tuning_job_id": Schema.String.annotate({
    "description": "The name of the fine-tuning job that this checkpoint was created from."
  }),
  "object": Schema.Literal("fine_tuning.job.checkpoint").annotate({
    "description": "The object type, which is always \"fine_tuning.job.checkpoint\"."
  })
}).annotate({
  "title": "FineTuningJobCheckpoint",
  "description":
    "The `fine_tuning.job.checkpoint` object represents a model checkpoint for a fine-tuning job that is ready to use.\n"
})
export type FineTuningJobEvent = {
  readonly "object": "fine_tuning.job.event"
  readonly "id": string
  readonly "created_at": number
  readonly "level": "info" | "warn" | "error"
  readonly "message": string
  readonly "type"?: "message" | "metrics"
  readonly "data"?: {}
}
export const FineTuningJobEvent = Schema.Struct({
  "object": Schema.Literal("fine_tuning.job.event").annotate({
    "description": "The object type, which is always \"fine_tuning.job.event\"."
  }),
  "id": Schema.String.annotate({ "description": "The object identifier." }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the fine-tuning job was created."
  }).check(Schema.isInt()),
  "level": Schema.Literals(["info", "warn", "error"]).annotate({ "description": "The log level of the event." }),
  "message": Schema.String.annotate({ "description": "The message of the event." }),
  "type": Schema.optionalKey(Schema.Literals(["message", "metrics"]).annotate({ "description": "The type of event." })),
  "data": Schema.optionalKey(Schema.Struct({}).annotate({ "description": "The data associated with the event." }))
}).annotate({ "description": "Fine-tuning job event object" })
export type FunctionParameters = {}
export const FunctionParameters = Schema.Struct({}).annotate({
  "description":
    "The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format. \n\nOmitting `parameters` defines a function with an empty parameter list."
})
export type FunctionToolCall = {
  readonly "id"?: string
  readonly "type": "function_call"
  readonly "call_id": string
  readonly "name": string
  readonly "arguments": string
  readonly "status"?: "in_progress" | "completed" | "incomplete"
}
export const FunctionToolCall = Schema.Struct({
  "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the function tool call.\n" })),
  "type": Schema.Literal("function_call").annotate({
    "description": "The type of the function tool call. Always `function_call`.\n"
  }),
  "call_id": Schema.String.annotate({
    "description": "The unique ID of the function tool call generated by the model.\n"
  }),
  "name": Schema.String.annotate({ "description": "The name of the function to run.\n" }),
  "arguments": Schema.String.annotate({ "description": "A JSON string of the arguments to pass to the function.\n" }),
  "status": Schema.optionalKey(
    Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
      "description":
        "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"
    })
  )
}).annotate({
  "title": "Function tool call",
  "description":
    "A tool call to run a function. See the \n[function calling guide](/docs/guides/function-calling) for more information.\n"
})
export type FunctionToolCallResource = {
  readonly "id": string
  readonly "type": "function_call"
  readonly "call_id": string
  readonly "name": string
  readonly "arguments": string
  readonly "status"?: "in_progress" | "completed" | "incomplete"
}
export const FunctionToolCallResource = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The unique ID of the function tool call.\n" }),
  "type": Schema.Literal("function_call").annotate({
    "description": "The type of the function tool call. Always `function_call`.\n"
  }),
  "call_id": Schema.String.annotate({
    "description": "The unique ID of the function tool call generated by the model.\n"
  }),
  "name": Schema.String.annotate({ "description": "The name of the function to run.\n" }),
  "arguments": Schema.String.annotate({ "description": "A JSON string of the arguments to pass to the function.\n" }),
  "status": Schema.optionalKey(
    Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
      "description":
        "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"
    })
  )
}).annotate({
  "title": "Function tool call",
  "description":
    "A tool call to run a function. See the \n[function calling guide](/docs/guides/function-calling) for more information.\n"
})
export type GraderPython = {
  readonly "type": "python"
  readonly "name": string
  readonly "source": string
  readonly "image_tag"?: string
}
export const GraderPython = Schema.Struct({
  "type": Schema.Literal("python").annotate({ "description": "The object type, which is always `python`." }),
  "name": Schema.String.annotate({ "description": "The name of the grader." }),
  "source": Schema.String.annotate({ "description": "The source code of the python script." }),
  "image_tag": Schema.optionalKey(
    Schema.String.annotate({ "description": "The image tag to use for the python script." })
  )
}).annotate({
  "title": "PythonGrader",
  "description": "A PythonGrader object that runs a python script on the input.\n"
})
export type GraderStringCheck = {
  readonly "type": "string_check"
  readonly "name": string
  readonly "input": string
  readonly "reference": string
  readonly "operation": "eq" | "ne" | "like" | "ilike"
}
export const GraderStringCheck = Schema.Struct({
  "type": Schema.Literal("string_check").annotate({
    "description": "The object type, which is always `string_check`."
  }),
  "name": Schema.String.annotate({ "description": "The name of the grader." }),
  "input": Schema.String.annotate({ "description": "The input text. This may include template strings." }),
  "reference": Schema.String.annotate({ "description": "The reference text. This may include template strings." }),
  "operation": Schema.Literals(["eq", "ne", "like", "ilike"]).annotate({
    "description": "The string check operation to perform. One of `eq`, `ne`, `like`, or `ilike`."
  })
}).annotate({
  "title": "StringCheckGrader",
  "description":
    "A StringCheckGrader object that performs a string comparison between input and reference using a specified operation.\n"
})
export type GraderTextSimilarity = {
  readonly "type": "text_similarity"
  readonly "name": string
  readonly "input": string
  readonly "reference": string
  readonly "evaluation_metric":
    | "cosine"
    | "fuzzy_match"
    | "bleu"
    | "gleu"
    | "meteor"
    | "rouge_1"
    | "rouge_2"
    | "rouge_3"
    | "rouge_4"
    | "rouge_5"
    | "rouge_l"
}
export const GraderTextSimilarity = Schema.Struct({
  "type": Schema.Literal("text_similarity").annotate({ "description": "The type of grader." }),
  "name": Schema.String.annotate({ "description": "The name of the grader." }),
  "input": Schema.String.annotate({ "description": "The text being graded." }),
  "reference": Schema.String.annotate({ "description": "The text being graded against." }),
  "evaluation_metric": Schema.Literals([
    "cosine",
    "fuzzy_match",
    "bleu",
    "gleu",
    "meteor",
    "rouge_1",
    "rouge_2",
    "rouge_3",
    "rouge_4",
    "rouge_5",
    "rouge_l"
  ]).annotate({
    "description":
      "The evaluation metric to use. One of `cosine`, `fuzzy_match`, `bleu`, \n`gleu`, `meteor`, `rouge_1`, `rouge_2`, `rouge_3`, `rouge_4`, `rouge_5`, \nor `rouge_l`.\n"
  })
}).annotate({
  "title": "TextSimilarityGrader",
  "description": "A TextSimilarityGrader object which grades text based on similarity metrics.\n"
})
export type Group = {
  readonly "object": "group"
  readonly "id": string
  readonly "name": string
  readonly "created_at": number
  readonly "scim_managed": boolean
}
export const Group = Schema.Struct({
  "object": Schema.Literal("group").annotate({ "description": "Always `group`." }),
  "id": Schema.String.annotate({ "description": "Identifier for the group." }),
  "name": Schema.String.annotate({ "description": "Display name of the group." }),
  "created_at": Schema.Number.annotate({
    "description": "Unix timestamp (in seconds) when the group was created.",
    "format": "int64"
  }).check(Schema.isInt()),
  "scim_managed": Schema.Boolean.annotate({ "description": "Whether the group is managed through SCIM." })
}).annotate({ "description": "Summary information about a group returned in role assignment responses." })
export type GroupDeletedResource = {
  readonly "object": "group.deleted"
  readonly "id": string
  readonly "deleted": boolean
}
export const GroupDeletedResource = Schema.Struct({
  "object": Schema.Literal("group.deleted").annotate({ "description": "Always `group.deleted`." }),
  "id": Schema.String.annotate({ "description": "Identifier of the deleted group." }),
  "deleted": Schema.Boolean.annotate({ "description": "Whether the group was deleted." })
}).annotate({ "description": "Confirmation payload returned after deleting a group." })
export type GroupResourceWithSuccess = {
  readonly "id": string
  readonly "name": string
  readonly "created_at": number
  readonly "is_scim_managed": boolean
}
export const GroupResourceWithSuccess = Schema.Struct({
  "id": Schema.String.annotate({ "description": "Identifier for the group." }),
  "name": Schema.String.annotate({ "description": "Updated display name for the group." }),
  "created_at": Schema.Number.annotate({
    "description": "Unix timestamp (in seconds) when the group was created.",
    "format": "int64"
  }).check(Schema.isInt()),
  "is_scim_managed": Schema.Boolean.annotate({
    "description": "Whether the group is managed through SCIM and controlled by your identity provider."
  })
}).annotate({ "description": "Response returned after updating a group." })
export type GroupResponse = {
  readonly "id": string
  readonly "name": string
  readonly "created_at": number
  readonly "is_scim_managed": boolean
}
export const GroupResponse = Schema.Struct({
  "id": Schema.String.annotate({ "description": "Identifier for the group." }),
  "name": Schema.String.annotate({ "description": "Display name of the group." }),
  "created_at": Schema.Number.annotate({
    "description": "Unix timestamp (in seconds) when the group was created.",
    "format": "int64"
  }).check(Schema.isInt()),
  "is_scim_managed": Schema.Boolean.annotate({
    "description": "Whether the group is managed through SCIM and controlled by your identity provider."
  })
}).annotate({ "description": "Details about an organization group." })
export type GroupUserAssignment = {
  readonly "object": "group.user"
  readonly "user_id": string
  readonly "group_id": string
}
export const GroupUserAssignment = Schema.Struct({
  "object": Schema.Literal("group.user").annotate({ "description": "Always `group.user`." }),
  "user_id": Schema.String.annotate({ "description": "Identifier of the user that was added." }),
  "group_id": Schema.String.annotate({ "description": "Identifier of the group the user was added to." })
}).annotate({ "description": "Confirmation payload returned after adding a user to a group." })
export type GroupUserDeletedResource = { readonly "object": "group.user.deleted"; readonly "deleted": boolean }
export const GroupUserDeletedResource = Schema.Struct({
  "object": Schema.Literal("group.user.deleted").annotate({ "description": "Always `group.user.deleted`." }),
  "deleted": Schema.Boolean.annotate({ "description": "Whether the group membership was removed." })
}).annotate({ "description": "Confirmation payload returned after removing a user from a group." })
export type Image = { readonly "b64_json"?: string; readonly "url"?: string; readonly "revised_prompt"?: string }
export const Image = Schema.Struct({
  "b64_json": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "The base64-encoded JSON of the generated image. Returned by default for the GPT image models, and only present if `response_format` is set to `b64_json` for `dall-e-2` and `dall-e-3`."
    })
  ),
  "url": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "When using `dall-e-2` or `dall-e-3`, the URL of the generated image if `response_format` is set to `url` (default value). Unsupported for the GPT image models."
    })
  ),
  "revised_prompt": Schema.optionalKey(
    Schema.String.annotate({
      "description": "For `dall-e-3` only, the revised prompt that was used to generate the image."
    })
  )
}).annotate({ "description": "Represents the content or the URL of an image generated by the OpenAI API." })
export type ImageEditPartialImageEvent = {
  readonly "type": "image_edit.partial_image"
  readonly "b64_json": string
  readonly "created_at": number
  readonly "size": "1024x1024" | "1024x1536" | "1536x1024" | "auto"
  readonly "quality": "low" | "medium" | "high" | "auto"
  readonly "background": "transparent" | "opaque" | "auto"
  readonly "output_format": "png" | "webp" | "jpeg"
  readonly "partial_image_index": number
}
export const ImageEditPartialImageEvent = Schema.Struct({
  "type": Schema.Literal("image_edit.partial_image").annotate({
    "description": "The type of the event. Always `image_edit.partial_image`.\n"
  }),
  "b64_json": Schema.String.annotate({
    "description": "Base64-encoded partial image data, suitable for rendering as an image.\n"
  }),
  "created_at": Schema.Number.annotate({ "description": "The Unix timestamp when the event was created.\n" }).check(
    Schema.isInt()
  ),
  "size": Schema.Literals(["1024x1024", "1024x1536", "1536x1024", "auto"]).annotate({
    "description": "The size of the requested edited image.\n"
  }),
  "quality": Schema.Literals(["low", "medium", "high", "auto"]).annotate({
    "description": "The quality setting for the requested edited image.\n"
  }),
  "background": Schema.Literals(["transparent", "opaque", "auto"]).annotate({
    "description": "The background setting for the requested edited image.\n"
  }),
  "output_format": Schema.Literals(["png", "webp", "jpeg"]).annotate({
    "description": "The output format for the requested edited image.\n"
  }),
  "partial_image_index": Schema.Number.annotate({ "description": "0-based index for the partial image (streaming).\n" })
    .check(Schema.isInt())
}).annotate({ "description": "Emitted when a partial image is available during image editing streaming.\n" })
export type ImageGenPartialImageEvent = {
  readonly "type": "image_generation.partial_image"
  readonly "b64_json": string
  readonly "created_at": number
  readonly "size": "1024x1024" | "1024x1536" | "1536x1024" | "auto"
  readonly "quality": "low" | "medium" | "high" | "auto"
  readonly "background": "transparent" | "opaque" | "auto"
  readonly "output_format": "png" | "webp" | "jpeg"
  readonly "partial_image_index": number
}
export const ImageGenPartialImageEvent = Schema.Struct({
  "type": Schema.Literal("image_generation.partial_image").annotate({
    "description": "The type of the event. Always `image_generation.partial_image`.\n"
  }),
  "b64_json": Schema.String.annotate({
    "description": "Base64-encoded partial image data, suitable for rendering as an image.\n"
  }),
  "created_at": Schema.Number.annotate({ "description": "The Unix timestamp when the event was created.\n" }).check(
    Schema.isInt()
  ),
  "size": Schema.Literals(["1024x1024", "1024x1536", "1536x1024", "auto"]).annotate({
    "description": "The size of the requested image.\n"
  }),
  "quality": Schema.Literals(["low", "medium", "high", "auto"]).annotate({
    "description": "The quality setting for the requested image.\n"
  }),
  "background": Schema.Literals(["transparent", "opaque", "auto"]).annotate({
    "description": "The background setting for the requested image.\n"
  }),
  "output_format": Schema.Literals(["png", "webp", "jpeg"]).annotate({
    "description": "The output format for the requested image.\n"
  }),
  "partial_image_index": Schema.Number.annotate({ "description": "0-based index for the partial image (streaming).\n" })
    .check(Schema.isInt())
}).annotate({ "description": "Emitted when a partial image is available during image generation streaming.\n" })
export type ImageGenToolCall = {
  readonly "type": "image_generation_call"
  readonly "id": string
  readonly "status": "in_progress" | "completed" | "generating" | "failed"
  readonly "result": string | null
}
export const ImageGenToolCall = Schema.Struct({
  "type": Schema.Literal("image_generation_call").annotate({
    "description": "The type of the image generation call. Always `image_generation_call`.\n"
  }),
  "id": Schema.String.annotate({ "description": "The unique ID of the image generation call.\n" }),
  "status": Schema.Literals(["in_progress", "completed", "generating", "failed"]).annotate({
    "description": "The status of the image generation call.\n"
  }),
  "result": Schema.Union([
    Schema.String.annotate({ "description": "The generated image encoded in base64.\n" }),
    Schema.Null
  ])
}).annotate({ "title": "Image generation call", "description": "An image generation request made by the model.\n" })
export type ImageRefParam = { readonly "image_url": unknown; readonly [x: string]: unknown } | {
  readonly "file_id": unknown
  readonly [x: string]: unknown
}
export const ImageRefParam = Schema.Union([
  Schema.StructWithRest(Schema.Struct({ "image_url": Schema.Unknown }), [Schema.Record(Schema.String, Schema.Json)]),
  Schema.StructWithRest(Schema.Struct({ "file_id": Schema.Unknown }), [Schema.Record(Schema.String, Schema.Json)])
]).annotate({
  "description":
    "Reference an input image by either URL or uploaded file ID.\nProvide exactly one of `image_url` or `file_id`.\n"
})
export type ImagesUsage = {
  readonly "total_tokens": number
  readonly "input_tokens": number
  readonly "output_tokens": number
  readonly "input_tokens_details": { readonly "text_tokens": number; readonly "image_tokens": number }
}
export const ImagesUsage = Schema.Struct({
  "total_tokens": Schema.Number.annotate({
    "description": "The total number of tokens (images and text) used for the image generation.\n"
  }).check(Schema.isInt()),
  "input_tokens": Schema.Number.annotate({
    "description": "The number of tokens (images and text) in the input prompt."
  }).check(Schema.isInt()),
  "output_tokens": Schema.Number.annotate({ "description": "The number of image tokens in the output image." }).check(
    Schema.isInt()
  ),
  "input_tokens_details": Schema.Struct({
    "text_tokens": Schema.Number.annotate({ "description": "The number of text tokens in the input prompt." }).check(
      Schema.isInt()
    ),
    "image_tokens": Schema.Number.annotate({ "description": "The number of image tokens in the input prompt." }).check(
      Schema.isInt()
    )
  }).annotate({ "description": "The input tokens detailed information for the image generation." })
}).annotate({ "description": "For the GPT image models only, the token usage information for the image generation.\n" })
export type InputAudio = {
  readonly "type": "input_audio"
  readonly "input_audio": { readonly "data": string; readonly "format": "mp3" | "wav" }
}
export const InputAudio = Schema.Struct({
  "type": Schema.Literal("input_audio").annotate({
    "description": "The type of the input item. Always `input_audio`.\n"
  }),
  "input_audio": Schema.Struct({
    "data": Schema.String.annotate({ "description": "Base64-encoded audio data.\n" }),
    "format": Schema.Literals(["mp3", "wav"]).annotate({
      "description": "The format of the audio data. Currently supported formats are `mp3` and\n`wav`.\n"
    })
  })
}).annotate({ "title": "Input audio", "description": "An audio input to the model.\n" })
export type Invite = {
  readonly "object": "organization.invite"
  readonly "id": string
  readonly "email": string
  readonly "role": "owner" | "reader"
  readonly "status": "accepted" | "expired" | "pending"
  readonly "invited_at": number
  readonly "expires_at": number
  readonly "accepted_at"?: number
  readonly "projects"?: ReadonlyArray<{ readonly "id"?: string; readonly "role"?: "member" | "owner" }>
}
export const Invite = Schema.Struct({
  "object": Schema.Literal("organization.invite").annotate({
    "description": "The object type, which is always `organization.invite`"
  }),
  "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" }),
  "email": Schema.String.annotate({ "description": "The email address of the individual to whom the invite was sent" }),
  "role": Schema.Literals(["owner", "reader"]).annotate({ "description": "`owner` or `reader`" }),
  "status": Schema.Literals(["accepted", "expired", "pending"]).annotate({
    "description": "`accepted`,`expired`, or `pending`"
  }),
  "invited_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) of when the invite was sent."
  }).check(Schema.isInt()),
  "expires_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the invite expires." })
    .check(Schema.isInt()),
  "accepted_at": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the invite was accepted." }).check(
      Schema.isInt()
    )
  ),
  "projects": Schema.optionalKey(
    Schema.Array(
      Schema.Struct({
        "id": Schema.optionalKey(Schema.String.annotate({ "description": "Project's public ID" })),
        "role": Schema.optionalKey(
          Schema.Literals(["member", "owner"]).annotate({ "description": "Project membership role" })
        )
      })
    ).annotate({ "description": "The projects that were granted membership upon acceptance of the invite." })
  )
}).annotate({ "description": "Represents an individual `invite` to the organization." })
export type InviteDeleteResponse = {
  readonly "object": "organization.invite.deleted"
  readonly "id": string
  readonly "deleted": boolean
}
export const InviteDeleteResponse = Schema.Struct({
  "object": Schema.Literal("organization.invite.deleted").annotate({
    "description": "The object type, which is always `organization.invite.deleted`"
  }),
  "id": Schema.String,
  "deleted": Schema.Boolean
})
export type InviteProjectGroupBody = { readonly "group_id": string; readonly "role": string }
export const InviteProjectGroupBody = Schema.Struct({
  "group_id": Schema.String.annotate({ "description": "Identifier of the group to add to the project." }),
  "role": Schema.String.annotate({ "description": "Identifier of the project role to grant to the group." })
}).annotate({ "description": "Request payload for granting a group access to a project." })
export type InviteRequest = {
  readonly "email": string
  readonly "role": "reader" | "owner"
  readonly "projects"?: ReadonlyArray<{ readonly "id": string; readonly "role": "member" | "owner" }>
}
export const InviteRequest = Schema.Struct({
  "email": Schema.String.annotate({ "description": "Send an email to this address" }),
  "role": Schema.Literals(["reader", "owner"]).annotate({ "description": "`owner` or `reader`" }),
  "projects": Schema.optionalKey(
    Schema.Array(
      Schema.Struct({
        "id": Schema.String.annotate({ "description": "Project's public ID" }),
        "role": Schema.Literals(["member", "owner"]).annotate({ "description": "Project membership role" })
      })
    ).annotate({
      "description":
        "An array of projects to which membership is granted at the same time the org invite is accepted. If omitted, the user will be invited to the default project for compatibility with legacy behavior."
    })
  )
})
export type LocalShellToolCallOutput = {
  readonly "type": "local_shell_call_output"
  readonly "id": string
  readonly "output": string
  readonly "status"?: "in_progress" | "completed" | "incomplete" | null
  readonly "call_id": unknown
}
export const LocalShellToolCallOutput = Schema.Struct({
  "type": Schema.Literal("local_shell_call_output").annotate({
    "description": "The type of the local shell tool call output. Always `local_shell_call_output`.\n"
  }),
  "id": Schema.String.annotate({
    "description": "The unique ID of the local shell tool call generated by the model.\n"
  }),
  "output": Schema.String.annotate({ "description": "A JSON string of the output of the local shell tool call.\n" }),
  "status": Schema.optionalKey(
    Schema.Union([
      Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
        "description": "The status of the item. One of `in_progress`, `completed`, or `incomplete`.\n"
      }),
      Schema.Null
    ])
  ),
  "call_id": Schema.Unknown
}).annotate({ "title": "Local shell call output", "description": "The output of a local shell tool call.\n" })
export type LogProbProperties = {
  readonly "token": string
  readonly "logprob": number
  readonly "bytes": ReadonlyArray<number>
}
export const LogProbProperties = Schema.Struct({
  "token": Schema.String.annotate({ "description": "The token that was used to generate the log probability.\n" }),
  "logprob": Schema.Number.annotate({ "description": "The log probability of the token.\n" }).check(Schema.isFinite()),
  "bytes": Schema.Array(Schema.Number.check(Schema.isInt())).annotate({
    "description": "The bytes that were used to generate the log probability.\n"
  })
}).annotate({ "description": "A log probability object.\n" })
export type MCPApprovalRequest = {
  readonly "type": "mcp_approval_request"
  readonly "id": string
  readonly "server_label": string
  readonly "name": string
  readonly "arguments": string
}
export const MCPApprovalRequest = Schema.Struct({
  "type": Schema.Literal("mcp_approval_request").annotate({
    "description": "The type of the item. Always `mcp_approval_request`.\n"
  }),
  "id": Schema.String.annotate({ "description": "The unique ID of the approval request.\n" }),
  "server_label": Schema.String.annotate({ "description": "The label of the MCP server making the request.\n" }),
  "name": Schema.String.annotate({ "description": "The name of the tool to run.\n" }),
  "arguments": Schema.String.annotate({ "description": "A JSON string of arguments for the tool.\n" })
}).annotate({ "title": "MCP approval request", "description": "A request for human approval of a tool invocation.\n" })
export type MCPApprovalResponse = {
  readonly "type": "mcp_approval_response"
  readonly "id"?: string | null
  readonly "approval_request_id": string
  readonly "approve": boolean
  readonly "reason"?: string | null
  readonly "request_id": unknown
}
export const MCPApprovalResponse = Schema.Struct({
  "type": Schema.Literal("mcp_approval_response").annotate({
    "description": "The type of the item. Always `mcp_approval_response`.\n"
  }),
  "id": Schema.optionalKey(
    Schema.Union([Schema.String.annotate({ "description": "The unique ID of the approval response\n" }), Schema.Null])
  ),
  "approval_request_id": Schema.String.annotate({ "description": "The ID of the approval request being answered.\n" }),
  "approve": Schema.Boolean.annotate({ "description": "Whether the request was approved.\n" }),
  "reason": Schema.optionalKey(
    Schema.Union([Schema.String.annotate({ "description": "Optional reason for the decision.\n" }), Schema.Null])
  ),
  "request_id": Schema.Unknown
}).annotate({ "title": "MCP approval response", "description": "A response to an MCP approval request.\n" })
export type MCPApprovalResponseResource = {
  readonly "type": "mcp_approval_response"
  readonly "id": string
  readonly "approval_request_id": string
  readonly "approve": boolean
  readonly "reason"?: string | null
  readonly "request_id": unknown
}
export const MCPApprovalResponseResource = Schema.Struct({
  "type": Schema.Literal("mcp_approval_response").annotate({
    "description": "The type of the item. Always `mcp_approval_response`.\n"
  }),
  "id": Schema.String.annotate({ "description": "The unique ID of the approval response\n" }),
  "approval_request_id": Schema.String.annotate({ "description": "The ID of the approval request being answered.\n" }),
  "approve": Schema.Boolean.annotate({ "description": "Whether the request was approved.\n" }),
  "reason": Schema.optionalKey(
    Schema.Union([Schema.String.annotate({ "description": "Optional reason for the decision.\n" }), Schema.Null])
  ),
  "request_id": Schema.Unknown
}).annotate({ "title": "MCP approval response", "description": "A response to an MCP approval request.\n" })
export type MCPListToolsTool = {
  readonly "name": string
  readonly "description"?: string | null
  readonly "input_schema": {}
  readonly "annotations"?: {} | null
}
export const MCPListToolsTool = Schema.Struct({
  "name": Schema.String.annotate({ "description": "The name of the tool.\n" }),
  "description": Schema.optionalKey(
    Schema.Union([Schema.String.annotate({ "description": "The description of the tool.\n" }), Schema.Null])
  ),
  "input_schema": Schema.Struct({}).annotate({ "description": "The JSON schema describing the tool's input.\n" }),
  "annotations": Schema.optionalKey(
    Schema.Union([
      Schema.Struct({}).annotate({ "description": "Additional annotations about the tool.\n" }),
      Schema.Null
    ])
  )
}).annotate({ "title": "MCP list tools tool", "description": "A tool available on an MCP server.\n" })
export type MCPToolCall = {
  readonly "type": "mcp_call"
  readonly "id": string
  readonly "server_label": string
  readonly "name": string
  readonly "arguments": string
  readonly "output"?: string | null
  readonly "error"?: string | null
  readonly "status"?: "in_progress" | "completed" | "incomplete" | "calling" | "failed"
  readonly "approval_request_id"?: string | null
}
export const MCPToolCall = Schema.Struct({
  "type": Schema.Literal("mcp_call").annotate({ "description": "The type of the item. Always `mcp_call`.\n" }),
  "id": Schema.String.annotate({ "description": "The unique ID of the tool call.\n" }),
  "server_label": Schema.String.annotate({ "description": "The label of the MCP server running the tool.\n" }),
  "name": Schema.String.annotate({ "description": "The name of the tool that was run.\n" }),
  "arguments": Schema.String.annotate({ "description": "A JSON string of the arguments passed to the tool.\n" }),
  "output": Schema.optionalKey(
    Schema.Union([Schema.String.annotate({ "description": "The output from the tool call.\n" }), Schema.Null])
  ),
  "error": Schema.optionalKey(
    Schema.Union([Schema.String.annotate({ "description": "The error from the tool call, if any.\n" }), Schema.Null])
  ),
  "status": Schema.optionalKey(
    Schema.Literals(["in_progress", "completed", "incomplete", "calling", "failed"]).annotate({
      "description":
        "The status of the tool call. One of `in_progress`, `completed`, `incomplete`, `calling`, or `failed`.\n"
    })
  ),
  "approval_request_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "Unique identifier for the MCP tool call approval request.\nInclude this value in a subsequent `mcp_approval_response` input to approve or reject the corresponding tool call.\n"
      }),
      Schema.Null
    ])
  )
}).annotate({ "title": "MCP tool call", "description": "An invocation of a tool on an MCP server.\n" })
export type MCPToolFilter = { readonly "tool_names"?: ReadonlyArray<string>; readonly "read_only"?: boolean }
export const MCPToolFilter = Schema.Struct({
  "tool_names": Schema.optionalKey(
    Schema.Array(Schema.String).annotate({ "title": "MCP allowed tools", "description": "List of allowed tool names." })
  ),
  "read_only": Schema.optionalKey(
    Schema.Boolean.annotate({
      "description":
        "Indicates whether or not a tool modifies data or is read-only. If an\nMCP server is [annotated with `readOnlyHint`](https://modelcontextprotocol.io/specification/2025-06-18/schema#toolannotations-readonlyhint),\nit will match this filter.\n"
    })
  )
}).annotate({ "title": "MCP tool filter", "description": "A filter object to specify which tools are allowed.\n" })
export type MessageContentImageFileObject = {
  readonly "type": "image_file"
  readonly "image_file": { readonly "file_id": string; readonly "detail"?: "auto" | "low" | "high" }
}
export const MessageContentImageFileObject = Schema.Struct({
  "type": Schema.Literal("image_file").annotate({ "description": "Always `image_file`." }),
  "image_file": Schema.Struct({
    "file_id": Schema.String.annotate({
      "description":
        "The [File](/docs/api-reference/files) ID of the image in the message content. Set `purpose=\"vision\"` when uploading the File if you need to later display the file content."
    }),
    "detail": Schema.optionalKey(
      Schema.Literals(["auto", "low", "high"]).annotate({
        "description":
          "Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`."
      })
    )
  })
}).annotate({
  "title": "Image file",
  "description": "References an image [File](/docs/api-reference/files) in the content of a message."
})
export type MessageContentImageUrlObject = {
  readonly "type": "image_url"
  readonly "image_url": { readonly "url": string; readonly "detail"?: "auto" | "low" | "high" }
}
export const MessageContentImageUrlObject = Schema.Struct({
  "type": Schema.Literal("image_url").annotate({ "description": "The type of the content part." }),
  "image_url": Schema.Struct({
    "url": Schema.String.annotate({
      "description": "The external URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp.",
      "format": "uri"
    }),
    "detail": Schema.optionalKey(
      Schema.Literals(["auto", "low", "high"]).annotate({
        "description":
          "Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`. Default value is `auto`"
      })
    )
  })
}).annotate({ "title": "Image URL", "description": "References an image URL in the content of a message." })
export type MessageContentRefusalObject = { readonly "type": "refusal"; readonly "refusal": string }
export const MessageContentRefusalObject = Schema.Struct({
  "type": Schema.Literal("refusal").annotate({ "description": "Always `refusal`." }),
  "refusal": Schema.String
}).annotate({ "title": "Refusal", "description": "The refusal content generated by the assistant." })
export type MessageContentTextAnnotationsFileCitationObject = {
  readonly "type": "file_citation"
  readonly "text": string
  readonly "file_citation": { readonly "file_id": string }
  readonly "start_index": number
  readonly "end_index": number
}
export const MessageContentTextAnnotationsFileCitationObject = Schema.Struct({
  "type": Schema.Literal("file_citation").annotate({ "description": "Always `file_citation`." }),
  "text": Schema.String.annotate({ "description": "The text in the message content that needs to be replaced." }),
  "file_citation": Schema.Struct({
    "file_id": Schema.String.annotate({ "description": "The ID of the specific File the citation is from." })
  }),
  "start_index": Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)),
  "end_index": Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0))
}).annotate({
  "title": "File citation",
  "description":
    "A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"file_search\" tool to search files."
})
export type MessageContentTextAnnotationsFilePathObject = {
  readonly "type": "file_path"
  readonly "text": string
  readonly "file_path": { readonly "file_id": string }
  readonly "start_index": number
  readonly "end_index": number
}
export const MessageContentTextAnnotationsFilePathObject = Schema.Struct({
  "type": Schema.Literal("file_path").annotate({ "description": "Always `file_path`." }),
  "text": Schema.String.annotate({ "description": "The text in the message content that needs to be replaced." }),
  "file_path": Schema.Struct({
    "file_id": Schema.String.annotate({ "description": "The ID of the file that was generated." })
  }),
  "start_index": Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)),
  "end_index": Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0))
}).annotate({
  "title": "File path",
  "description":
    "A URL for the file that's generated when the assistant used the `code_interpreter` tool to generate a file."
})
export type MessageDeltaContentImageFileObject = {
  readonly "index": number
  readonly "type": "image_file"
  readonly "image_file"?: { readonly "file_id"?: string; readonly "detail"?: "auto" | "low" | "high" }
}
export const MessageDeltaContentImageFileObject = Schema.Struct({
  "index": Schema.Number.annotate({ "description": "The index of the content part in the message." }).check(
    Schema.isInt()
  ),
  "type": Schema.Literal("image_file").annotate({ "description": "Always `image_file`." }),
  "image_file": Schema.optionalKey(Schema.Struct({
    "file_id": Schema.optionalKey(
      Schema.String.annotate({
        "description":
          "The [File](/docs/api-reference/files) ID of the image in the message content. Set `purpose=\"vision\"` when uploading the File if you need to later display the file content."
      })
    ),
    "detail": Schema.optionalKey(
      Schema.Literals(["auto", "low", "high"]).annotate({
        "description":
          "Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`."
      })
    )
  }))
}).annotate({
  "title": "Image file",
  "description": "References an image [File](/docs/api-reference/files) in the content of a message."
})
export type MessageDeltaContentImageUrlObject = {
  readonly "index": number
  readonly "type": "image_url"
  readonly "image_url"?: { readonly "url"?: string; readonly "detail"?: "auto" | "low" | "high" }
}
export const MessageDeltaContentImageUrlObject = Schema.Struct({
  "index": Schema.Number.annotate({ "description": "The index of the content part in the message." }).check(
    Schema.isInt()
  ),
  "type": Schema.Literal("image_url").annotate({ "description": "Always `image_url`." }),
  "image_url": Schema.optionalKey(Schema.Struct({
    "url": Schema.optionalKey(
      Schema.String.annotate({
        "description": "The URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp."
      })
    ),
    "detail": Schema.optionalKey(
      Schema.Literals(["auto", "low", "high"]).annotate({
        "description":
          "Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`."
      })
    )
  }))
}).annotate({ "title": "Image URL", "description": "References an image URL in the content of a message." })
export type MessageDeltaContentRefusalObject = {
  readonly "index": number
  readonly "type": "refusal"
  readonly "refusal"?: string
}
export const MessageDeltaContentRefusalObject = Schema.Struct({
  "index": Schema.Number.annotate({ "description": "The index of the refusal part in the message." }).check(
    Schema.isInt()
  ),
  "type": Schema.Literal("refusal").annotate({ "description": "Always `refusal`." }),
  "refusal": Schema.optionalKey(Schema.String)
}).annotate({ "title": "Refusal", "description": "The refusal content that is part of a message." })
export type MessageDeltaContentTextAnnotationsFileCitationObject = {
  readonly "index": number
  readonly "type": "file_citation"
  readonly "text"?: string
  readonly "file_citation"?: { readonly "file_id"?: string; readonly "quote"?: string }
  readonly "start_index"?: number
  readonly "end_index"?: number
}
export const MessageDeltaContentTextAnnotationsFileCitationObject = Schema.Struct({
  "index": Schema.Number.annotate({ "description": "The index of the annotation in the text content part." }).check(
    Schema.isInt()
  ),
  "type": Schema.Literal("file_citation").annotate({ "description": "Always `file_citation`." }),
  "text": Schema.optionalKey(
    Schema.String.annotate({ "description": "The text in the message content that needs to be replaced." })
  ),
  "file_citation": Schema.optionalKey(
    Schema.Struct({
      "file_id": Schema.optionalKey(
        Schema.String.annotate({ "description": "The ID of the specific File the citation is from." })
      ),
      "quote": Schema.optionalKey(Schema.String.annotate({ "description": "The specific quote in the file." }))
    })
  ),
  "start_index": Schema.optionalKey(Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0))),
  "end_index": Schema.optionalKey(Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)))
}).annotate({
  "title": "File citation",
  "description":
    "A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"file_search\" tool to search files."
})
export type MessageDeltaContentTextAnnotationsFilePathObject = {
  readonly "index": number
  readonly "type": "file_path"
  readonly "text"?: string
  readonly "file_path"?: { readonly "file_id"?: string }
  readonly "start_index"?: number
  readonly "end_index"?: number
}
export const MessageDeltaContentTextAnnotationsFilePathObject = Schema.Struct({
  "index": Schema.Number.annotate({ "description": "The index of the annotation in the text content part." }).check(
    Schema.isInt()
  ),
  "type": Schema.Literal("file_path").annotate({ "description": "Always `file_path`." }),
  "text": Schema.optionalKey(
    Schema.String.annotate({ "description": "The text in the message content that needs to be replaced." })
  ),
  "file_path": Schema.optionalKey(
    Schema.Struct({
      "file_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the file that was generated." }))
    })
  ),
  "start_index": Schema.optionalKey(Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0))),
  "end_index": Schema.optionalKey(Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)))
}).annotate({
  "title": "File path",
  "description":
    "A URL for the file that's generated when the assistant used the `code_interpreter` tool to generate a file."
})
export type MessagePhase = "commentary" | "final_answer"
export const MessagePhase = Schema.Literals(["commentary", "final_answer"]).annotate({
  "description":
    "Labels an `assistant` message as intermediate commentary (`commentary`) or the final answer (`final_answer`). For models like `gpt-5.3-codex` and beyond, when sending follow-up requests, preserve and resend phase on all assistant messages  dropping it can degrade performance. Not used for user messages.\n\nUse `commentary` for an intermediate assistant message and `final_answer` for\nthe final assistant message. For follow-up requests with models like\n`gpt-5.3-codex` and later, preserve and resend phase on all assistant\nmessages. Omitting it can degrade performance. Not used for user messages.\n"
})
export type MessageRequestContentTextObject = { readonly "type": "text"; readonly "text": string }
export const MessageRequestContentTextObject = Schema.Struct({
  "type": Schema.Literal("text").annotate({ "description": "Always `text`." }),
  "text": Schema.String.annotate({ "description": "Text content to be sent to the model" })
}).annotate({ "title": "Text", "description": "The text content that is part of a message." })
export type Metadata = {} | null
export const Metadata = Schema.Union([
  Schema.Struct({}).annotate({
    "description":
      "Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard.\n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n"
  }),
  Schema.Null
])
export type Model = {
  readonly "id": string
  readonly "created": number
  readonly "object": "model"
  readonly "owned_by": string
  readonly [x: string]: unknown
}
export const Model = Schema.StructWithRest(
  Schema.Struct({
    "id": Schema.String.annotate({
      "description": "The model identifier, which can be referenced in the API endpoints."
    }),
    "created": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) when the model was created." })
      .check(Schema.isInt()),
    "object": Schema.Literal("model").annotate({ "description": "The object type, which is always \"model\"." }),
    "owned_by": Schema.String.annotate({ "description": "The organization that owns the model." })
  }),
  [Schema.Record(Schema.String, Schema.Json)]
).annotate({ "title": "Model", "description": "Describes an OpenAI model offering that can be used with the API." })
export type ModelIdsShared =
  | string
  | "gpt-5.2"
  | "gpt-5.2-2025-12-11"
  | "gpt-5.2-chat-latest"
  | "gpt-5.2-pro"
  | "gpt-5.2-pro-2025-12-11"
  | "gpt-5.1"
  | "gpt-5.1-2025-11-13"
  | "gpt-5.1-codex"
  | "gpt-5.1-mini"
  | "gpt-5.1-chat-latest"
  | "gpt-5"
  | "gpt-5-mini"
  | "gpt-5-nano"
  | "gpt-5-2025-08-07"
  | "gpt-5-mini-2025-08-07"
  | "gpt-5-nano-2025-08-07"
  | "gpt-5-chat-latest"
  | "gpt-4.1"
  | "gpt-4.1-mini"
  | "gpt-4.1-nano"
  | "gpt-4.1-2025-04-14"
  | "gpt-4.1-mini-2025-04-14"
  | "gpt-4.1-nano-2025-04-14"
  | "o4-mini"
  | "o4-mini-2025-04-16"
  | "o3"
  | "o3-2025-04-16"
  | "o3-mini"
  | "o3-mini-2025-01-31"
  | "o1"
  | "o1-2024-12-17"
  | "o1-preview"
  | "o1-preview-2024-09-12"
  | "o1-mini"
  | "o1-mini-2024-09-12"
  | "gpt-4o"
  | "gpt-4o-2024-11-20"
  | "gpt-4o-2024-08-06"
  | "gpt-4o-2024-05-13"
  | "gpt-4o-audio-preview"
  | "gpt-4o-audio-preview-2024-10-01"
  | "gpt-4o-audio-preview-2024-12-17"
  | "gpt-4o-audio-preview-2025-06-03"
  | "gpt-4o-mini-audio-preview"
  | "gpt-4o-mini-audio-preview-2024-12-17"
  | "gpt-4o-search-preview"
  | "gpt-4o-mini-search-preview"
  | "gpt-4o-search-preview-2025-03-11"
  | "gpt-4o-mini-search-preview-2025-03-11"
  | "chatgpt-4o-latest"
  | "codex-mini-latest"
  | "gpt-4o-mini"
  | "gpt-4o-mini-2024-07-18"
  | "gpt-4-turbo"
  | "gpt-4-turbo-2024-04-09"
  | "gpt-4-0125-preview"
  | "gpt-4-turbo-preview"
  | "gpt-4-1106-preview"
  | "gpt-4-vision-preview"
  | "gpt-4"
  | "gpt-4-0314"
  | "gpt-4-0613"
  | "gpt-4-32k"
  | "gpt-4-32k-0314"
  | "gpt-4-32k-0613"
  | "gpt-3.5-turbo"
  | "gpt-3.5-turbo-16k"
  | "gpt-3.5-turbo-0301"
  | "gpt-3.5-turbo-0613"
  | "gpt-3.5-turbo-1106"
  | "gpt-3.5-turbo-0125"
  | "gpt-3.5-turbo-16k-0613"
export const ModelIdsShared = Schema.Union([
  Schema.String,
  Schema.Literals([
    "gpt-5.2",
    "gpt-5.2-2025-12-11",
    "gpt-5.2-chat-latest",
    "gpt-5.2-pro",
    "gpt-5.2-pro-2025-12-11",
    "gpt-5.1",
    "gpt-5.1-2025-11-13",
    "gpt-5.1-codex",
    "gpt-5.1-mini",
    "gpt-5.1-chat-latest",
    "gpt-5",
    "gpt-5-mini",
    "gpt-5-nano",
    "gpt-5-2025-08-07",
    "gpt-5-mini-2025-08-07",
    "gpt-5-nano-2025-08-07",
    "gpt-5-chat-latest",
    "gpt-4.1",
    "gpt-4.1-mini",
    "gpt-4.1-nano",
    "gpt-4.1-2025-04-14",
    "gpt-4.1-mini-2025-04-14",
    "gpt-4.1-nano-2025-04-14",
    "o4-mini",
    "o4-mini-2025-04-16",
    "o3",
    "o3-2025-04-16",
    "o3-mini",
    "o3-mini-2025-01-31",
    "o1",
    "o1-2024-12-17",
    "o1-preview",
    "o1-preview-2024-09-12",
    "o1-mini",
    "o1-mini-2024-09-12",
    "gpt-4o",
    "gpt-4o-2024-11-20",
    "gpt-4o-2024-08-06",
    "gpt-4o-2024-05-13",
    "gpt-4o-audio-preview",
    "gpt-4o-audio-preview-2024-10-01",
    "gpt-4o-audio-preview-2024-12-17",
    "gpt-4o-audio-preview-2025-06-03",
    "gpt-4o-mini-audio-preview",
    "gpt-4o-mini-audio-preview-2024-12-17",
    "gpt-4o-search-preview",
    "gpt-4o-mini-search-preview",
    "gpt-4o-search-preview-2025-03-11",
    "gpt-4o-mini-search-preview-2025-03-11",
    "chatgpt-4o-latest",
    "codex-mini-latest",
    "gpt-4o-mini",
    "gpt-4o-mini-2024-07-18",
    "gpt-4-turbo",
    "gpt-4-turbo-2024-04-09",
    "gpt-4-0125-preview",
    "gpt-4-turbo-preview",
    "gpt-4-1106-preview",
    "gpt-4-vision-preview",
    "gpt-4",
    "gpt-4-0314",
    "gpt-4-0613",
    "gpt-4-32k",
    "gpt-4-32k-0314",
    "gpt-4-32k-0613",
    "gpt-3.5-turbo",
    "gpt-3.5-turbo-16k",
    "gpt-3.5-turbo-0301",
    "gpt-3.5-turbo-0613",
    "gpt-3.5-turbo-1106",
    "gpt-3.5-turbo-0125",
    "gpt-3.5-turbo-16k-0613"
  ])
])
export type ModifyCertificateRequest = { readonly "name": string }
export const ModifyCertificateRequest = Schema.Struct({
  "name": Schema.String.annotate({ "description": "The updated name for the certificate" })
})
export type NoiseReductionType = "near_field" | "far_field"
export const NoiseReductionType = Schema.Literals(["near_field", "far_field"]).annotate({
  "description":
    "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"
})
export type OpenAIFile = {
  readonly "id": string
  readonly "bytes": number
  readonly "created_at": number
  readonly "expires_at"?: number
  readonly "filename": string
  readonly "object": "file"
  readonly "purpose":
    | "assistants"
    | "assistants_output"
    | "batch"
    | "batch_output"
    | "fine-tune"
    | "fine-tune-results"
    | "vision"
    | "user_data"
  readonly "status": "uploaded" | "processed" | "error"
  readonly "status_details"?: string
  readonly [x: string]: unknown
}
export const OpenAIFile = Schema.StructWithRest(
  Schema.Struct({
    "id": Schema.String.annotate({
      "description": "The file identifier, which can be referenced in the API endpoints."
    }),
    "bytes": Schema.Number.annotate({ "description": "The size of the file, in bytes." }).check(Schema.isInt()),
    "created_at": Schema.Number.annotate({
      "description": "The Unix timestamp (in seconds) for when the file was created."
    }).check(Schema.isInt()),
    "expires_at": Schema.optionalKey(
      Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the file will expire." }).check(
        Schema.isInt()
      )
    ),
    "filename": Schema.String.annotate({ "description": "The name of the file." }),
    "object": Schema.Literal("file").annotate({ "description": "The object type, which is always `file`." }),
    "purpose": Schema.Literals([
      "assistants",
      "assistants_output",
      "batch",
      "batch_output",
      "fine-tune",
      "fine-tune-results",
      "vision",
      "user_data"
    ]).annotate({
      "description":
        "The intended purpose of the file. Supported values are `assistants`, `assistants_output`, `batch`, `batch_output`, `fine-tune`, `fine-tune-results`, `vision`, and `user_data`."
    }),
    "status": Schema.Literals(["uploaded", "processed", "error"]).annotate({
      "description":
        "Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`."
    }),
    "status_details": Schema.optionalKey(
      Schema.String.annotate({
        "description":
          "Deprecated. For details on why a fine-tuning training file failed validation, see the `error` field on `fine_tuning.job`."
      })
    )
  }),
  [Schema.Record(Schema.String, Schema.Json)]
).annotate({
  "title": "OpenAIFile",
  "description": "The `File` object represents a document that has been uploaded to OpenAI."
})
export type OtherChunkingStrategyResponseParam = { readonly "type": "other" }
export const OtherChunkingStrategyResponseParam = Schema.Struct({
  "type": Schema.Literal("other").annotate({ "description": "Always `other`." })
}).annotate({
  "title": "Other Chunking Strategy",
  "description":
    "This is returned when the chunking strategy is unknown. Typically, this is because the file was indexed before the `chunking_strategy` concept was introduced in the API."
})
export type ParallelToolCalls = boolean
export const ParallelToolCalls = Schema.Boolean.annotate({
  "description":
    "Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use."
})
export type PartialImages = number | null
export const PartialImages = Schema.Union([
  Schema.Number.annotate({
    "description":
      "The number of partial images to generate. This parameter is used for\nstreaming responses that return partial images. Value must be between 0 and 3.\nWhen set to 0, the response will be a single image sent in one streaming event.\n\nNote that the final image may be sent before the full number of partial images\nare generated if the full image is generated more quickly.\n"
  }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(3)),
  Schema.Null
])
export type Project = {
  readonly "id": string
  readonly "object": "organization.project"
  readonly "name": string
  readonly "created_at": number
  readonly "archived_at"?: number | null
  readonly "status": "active" | "archived"
}
export const Project = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" }),
  "object": Schema.Literal("organization.project").annotate({
    "description": "The object type, which is always `organization.project`"
  }),
  "name": Schema.String.annotate({ "description": "The name of the project. This appears in reporting." }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) of when the project was created."
  }).check(Schema.isInt()),
  "archived_at": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description": "The Unix timestamp (in seconds) of when the project was archived or `null`."
      }).check(Schema.isInt()),
      Schema.Null
    ])
  ),
  "status": Schema.Literals(["active", "archived"]).annotate({ "description": "`active` or `archived`" })
}).annotate({ "description": "Represents an individual project." })
export type ProjectApiKeyDeleteResponse = {
  readonly "object": "organization.project.api_key.deleted"
  readonly "id": string
  readonly "deleted": boolean
}
export const ProjectApiKeyDeleteResponse = Schema.Struct({
  "object": Schema.Literal("organization.project.api_key.deleted"),
  "id": Schema.String,
  "deleted": Schema.Boolean
})
export type ProjectCreateRequest = {
  readonly "name": string
  readonly "geography"?: "US" | "EU" | "JP" | "IN" | "KR" | "CA" | "AU" | "SG"
}
export const ProjectCreateRequest = Schema.Struct({
  "name": Schema.String.annotate({ "description": "The friendly name of the project, this name appears in reports." }),
  "geography": Schema.optionalKey(
    Schema.Literals(["US", "EU", "JP", "IN", "KR", "CA", "AU", "SG"]).annotate({
      "description":
        "Create the project with the specified data residency region. Your organization must have access to Data residency functionality in order to use. See [data residency controls](/docs/guides/your-data#data-residency-controls) to review the functionality and limitations of setting this field."
    })
  )
})
export type ProjectGroup = {
  readonly "object": "project.group"
  readonly "project_id": string
  readonly "group_id": string
  readonly "group_name": string
  readonly "created_at": number
}
export const ProjectGroup = Schema.Struct({
  "object": Schema.Literal("project.group").annotate({ "description": "Always `project.group`." }),
  "project_id": Schema.String.annotate({ "description": "Identifier of the project." }),
  "group_id": Schema.String.annotate({ "description": "Identifier of the group that has access to the project." }),
  "group_name": Schema.String.annotate({ "description": "Display name of the group." }),
  "created_at": Schema.Number.annotate({
    "description": "Unix timestamp (in seconds) when the group was granted project access.",
    "format": "int64"
  }).check(Schema.isInt())
}).annotate({ "description": "Details about a group's membership in a project." })
export type ProjectGroupDeletedResource = { readonly "object": "project.group.deleted"; readonly "deleted": boolean }
export const ProjectGroupDeletedResource = Schema.Struct({
  "object": Schema.Literal("project.group.deleted").annotate({ "description": "Always `project.group.deleted`." }),
  "deleted": Schema.Boolean.annotate({ "description": "Whether the group membership in the project was removed." })
}).annotate({ "description": "Confirmation payload returned after removing a group from a project." })
export type ProjectRateLimit = {
  readonly "object": "project.rate_limit"
  readonly "id": string
  readonly "model": string
  readonly "max_requests_per_1_minute": number
  readonly "max_tokens_per_1_minute": number
  readonly "max_images_per_1_minute"?: number
  readonly "max_audio_megabytes_per_1_minute"?: number
  readonly "max_requests_per_1_day"?: number
  readonly "batch_1_day_max_input_tokens"?: number
}
export const ProjectRateLimit = Schema.Struct({
  "object": Schema.Literal("project.rate_limit").annotate({
    "description": "The object type, which is always `project.rate_limit`"
  }),
  "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints." }),
  "model": Schema.String.annotate({ "description": "The model this rate limit applies to." }),
  "max_requests_per_1_minute": Schema.Number.annotate({ "description": "The maximum requests per minute." }).check(
    Schema.isInt()
  ),
  "max_tokens_per_1_minute": Schema.Number.annotate({ "description": "The maximum tokens per minute." }).check(
    Schema.isInt()
  ),
  "max_images_per_1_minute": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The maximum images per minute. Only present for relevant models." }).check(
      Schema.isInt()
    )
  ),
  "max_audio_megabytes_per_1_minute": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "The maximum audio megabytes per minute. Only present for relevant models."
    }).check(Schema.isInt())
  ),
  "max_requests_per_1_day": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The maximum requests per day. Only present for relevant models." }).check(
      Schema.isInt()
    )
  ),
  "batch_1_day_max_input_tokens": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "The maximum batch input tokens per day. Only present for relevant models."
    }).check(Schema.isInt())
  )
}).annotate({ "description": "Represents a project rate limit config." })
export type ProjectRateLimitUpdateRequest = {
  readonly "max_requests_per_1_minute"?: number
  readonly "max_tokens_per_1_minute"?: number
  readonly "max_images_per_1_minute"?: number
  readonly "max_audio_megabytes_per_1_minute"?: number
  readonly "max_requests_per_1_day"?: number
  readonly "batch_1_day_max_input_tokens"?: number
}
export const ProjectRateLimitUpdateRequest = Schema.Struct({
  "max_requests_per_1_minute": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The maximum requests per minute." }).check(Schema.isInt())
  ),
  "max_tokens_per_1_minute": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The maximum tokens per minute." }).check(Schema.isInt())
  ),
  "max_images_per_1_minute": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The maximum images per minute. Only relevant for certain models." }).check(
      Schema.isInt()
    )
  ),
  "max_audio_megabytes_per_1_minute": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "The maximum audio megabytes per minute. Only relevant for certain models."
    }).check(Schema.isInt())
  ),
  "max_requests_per_1_day": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The maximum requests per day. Only relevant for certain models." }).check(
      Schema.isInt()
    )
  ),
  "batch_1_day_max_input_tokens": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "The maximum batch input tokens per day. Only relevant for certain models."
    }).check(Schema.isInt())
  )
})
export type ProjectServiceAccount = {
  readonly "object": "organization.project.service_account"
  readonly "id": string
  readonly "name": string
  readonly "role": "owner" | "member"
  readonly "created_at": number
}
export const ProjectServiceAccount = Schema.Struct({
  "object": Schema.Literal("organization.project.service_account").annotate({
    "description": "The object type, which is always `organization.project.service_account`"
  }),
  "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" }),
  "name": Schema.String.annotate({ "description": "The name of the service account" }),
  "role": Schema.Literals(["owner", "member"]).annotate({ "description": "`owner` or `member`" }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) of when the service account was created"
  }).check(Schema.isInt())
}).annotate({ "description": "Represents an individual service account in a project." })
export type ProjectServiceAccountApiKey = {
  readonly "object": "organization.project.service_account.api_key"
  readonly "value": string
  readonly "name": string
  readonly "created_at": number
  readonly "id": string
}
export const ProjectServiceAccountApiKey = Schema.Struct({
  "object": Schema.Literal("organization.project.service_account.api_key").annotate({
    "description": "The object type, which is always `organization.project.service_account.api_key`"
  }),
  "value": Schema.String,
  "name": Schema.String,
  "created_at": Schema.Number.check(Schema.isInt()),
  "id": Schema.String
})
export type ProjectServiceAccountCreateRequest = { readonly "name": string }
export const ProjectServiceAccountCreateRequest = Schema.Struct({
  "name": Schema.String.annotate({ "description": "The name of the service account being created." })
})
export type ProjectServiceAccountDeleteResponse = {
  readonly "object": "organization.project.service_account.deleted"
  readonly "id": string
  readonly "deleted": boolean
}
export const ProjectServiceAccountDeleteResponse = Schema.Struct({
  "object": Schema.Literal("organization.project.service_account.deleted"),
  "id": Schema.String,
  "deleted": Schema.Boolean
})
export type ProjectUpdateRequest = { readonly "name": string }
export const ProjectUpdateRequest = Schema.Struct({
  "name": Schema.String.annotate({ "description": "The updated name of the project, this name appears in reports." })
})
export type ProjectUser = {
  readonly "object": "organization.project.user"
  readonly "id": string
  readonly "name": string
  readonly "email": string
  readonly "role": "owner" | "member"
  readonly "added_at": number
}
export const ProjectUser = Schema.Struct({
  "object": Schema.Literal("organization.project.user").annotate({
    "description": "The object type, which is always `organization.project.user`"
  }),
  "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" }),
  "name": Schema.String.annotate({ "description": "The name of the user" }),
  "email": Schema.String.annotate({ "description": "The email address of the user" }),
  "role": Schema.Literals(["owner", "member"]).annotate({ "description": "`owner` or `member`" }),
  "added_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) of when the project was added."
  }).check(Schema.isInt())
}).annotate({ "description": "Represents an individual user in a project." })
export type ProjectUserCreateRequest = { readonly "user_id": string; readonly "role": "owner" | "member" }
export const ProjectUserCreateRequest = Schema.Struct({
  "user_id": Schema.String.annotate({ "description": "The ID of the user." }),
  "role": Schema.Literals(["owner", "member"]).annotate({ "description": "`owner` or `member`" })
})
export type ProjectUserDeleteResponse = {
  readonly "object": "organization.project.user.deleted"
  readonly "id": string
  readonly "deleted": boolean
}
export const ProjectUserDeleteResponse = Schema.Struct({
  "object": Schema.Literal("organization.project.user.deleted"),
  "id": Schema.String,
  "deleted": Schema.Boolean
})
export type ProjectUserUpdateRequest = { readonly "role": "owner" | "member" }
export const ProjectUserUpdateRequest = Schema.Struct({
  "role": Schema.Literals(["owner", "member"]).annotate({ "description": "`owner` or `member`" })
})
export type PublicAssignOrganizationGroupRoleBody = { readonly "role_id": string }
export const PublicAssignOrganizationGroupRoleBody = Schema.Struct({
  "role_id": Schema.String.annotate({ "description": "Identifier of the role to assign." })
}).annotate({ "description": "Request payload for assigning a role to a group or user." })
export type PublicCreateOrganizationRoleBody = {
  readonly "role_name": string
  readonly "permissions": ReadonlyArray<string>
  readonly "description"?: string | null
}
export const PublicCreateOrganizationRoleBody = Schema.Struct({
  "role_name": Schema.String.annotate({ "description": "Unique name for the role." }),
  "permissions": Schema.Array(Schema.String).annotate({ "description": "Permissions to grant to the role." }),
  "description": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Optional description of the role." })
  )
}).annotate({ "description": "Request payload for creating a custom role." })
export type PublicUpdateOrganizationRoleBody = {
  readonly "permissions"?: ReadonlyArray<string> | null
  readonly "description"?: string | null
  readonly "role_name"?: string | null
}
export const PublicUpdateOrganizationRoleBody = Schema.Struct({
  "permissions": Schema.optionalKey(
    Schema.Union([Schema.Array(Schema.String), Schema.Null]).annotate({
      "description": "Updated set of permissions for the role."
    })
  ),
  "description": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "New description for the role." })
  ),
  "role_name": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "New name for the role." })
  )
}).annotate({ "description": "Request payload for updating an existing role." })
export type RealtimeAudioFormats = { readonly "type"?: "audio/pcm"; readonly "rate"?: 24000 } | {
  readonly "type"?: "audio/pcmu"
} | { readonly "type"?: "audio/pcma" }
export const RealtimeAudioFormats = Schema.Union([
  Schema.Struct({
    "type": Schema.optionalKey(
      Schema.Literal("audio/pcm").annotate({ "description": "The audio format. Always `audio/pcm`." })
    ),
    "rate": Schema.optionalKey(
      Schema.Literal(24000).annotate({ "description": "The sample rate of the audio. Always `24000`." })
    )
  }).annotate({
    "title": "PCM audio format",
    "description": "The PCM audio format. Only a 24kHz sample rate is supported."
  }),
  Schema.Struct({
    "type": Schema.optionalKey(
      Schema.Literal("audio/pcmu").annotate({ "description": "The audio format. Always `audio/pcmu`." })
    )
  }).annotate({ "title": "PCMU audio format", "description": "The G.711 -law format." }),
  Schema.Struct({
    "type": Schema.optionalKey(
      Schema.Literal("audio/pcma").annotate({ "description": "The audio format. Always `audio/pcma`." })
    )
  }).annotate({ "title": "PCMA audio format", "description": "The G.711 A-law format." })
])
export type RealtimeCallReferRequest = { readonly "target_uri": string }
export const RealtimeCallReferRequest = Schema.Struct({
  "target_uri": Schema.String.annotate({
    "description":
      "URI that should appear in the SIP Refer-To header. Supports values like\n`tel:+14155550123` or `sip:agent@example.com`."
  })
}).annotate({
  "title": "Realtime call refer request",
  "description": "Parameters required to transfer a SIP call to a new destination using the\nRealtime API."
})
export type RealtimeCallRejectRequest = { readonly "status_code"?: number }
export const RealtimeCallRejectRequest = Schema.Struct({
  "status_code": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "SIP response code to send back to the caller. Defaults to `603` (Decline)\nwhen omitted."
    }).check(Schema.isInt())
  )
}).annotate({
  "title": "Realtime call reject request",
  "description": "Parameters used to decline an incoming SIP call handled by the Realtime API."
})
export type RealtimeClientEventConversationItemDelete = {
  readonly "event_id"?: string
  readonly "type": "conversation.item.delete"
  readonly "item_id": string
}
export const RealtimeClientEventConversationItemDelete = Schema.Struct({
  "event_id": Schema.optionalKey(
    Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." }).check(
      Schema.isMaxLength(512)
    )
  ),
  "type": Schema.Literal("conversation.item.delete").annotate({
    "description": "The event type, must be `conversation.item.delete`."
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the item to delete." })
}).annotate({
  "description":
    "Send this event when you want to remove any item from the conversation \nhistory. The server will respond with a `conversation.item.deleted` event, \nunless the item does not exist in the conversation history, in which case the \nserver will respond with an error.\n"
})
export type RealtimeClientEventConversationItemRetrieve = {
  readonly "event_id"?: string
  readonly "type": "conversation.item.retrieve"
  readonly "item_id": string
}
export const RealtimeClientEventConversationItemRetrieve = Schema.Struct({
  "event_id": Schema.optionalKey(
    Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." }).check(
      Schema.isMaxLength(512)
    )
  ),
  "type": Schema.Literal("conversation.item.retrieve").annotate({
    "description": "The event type, must be `conversation.item.retrieve`."
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the item to retrieve." })
}).annotate({
  "description":
    "Send this event when you want to retrieve the server's representation of a specific item in the conversation history. This is useful, for example, to inspect user audio after noise cancellation and VAD.\nThe server will respond with a `conversation.item.retrieved` event, \nunless the item does not exist in the conversation history, in which case the \nserver will respond with an error.\n"
})
export type RealtimeClientEventConversationItemTruncate = {
  readonly "event_id"?: string
  readonly "type": "conversation.item.truncate"
  readonly "item_id": string
  readonly "content_index": number
  readonly "audio_end_ms": number
}
export const RealtimeClientEventConversationItemTruncate = Schema.Struct({
  "event_id": Schema.optionalKey(
    Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." }).check(
      Schema.isMaxLength(512)
    )
  ),
  "type": Schema.Literal("conversation.item.truncate").annotate({
    "description": "The event type, must be `conversation.item.truncate`."
  }),
  "item_id": Schema.String.annotate({
    "description":
      "The ID of the assistant message item to truncate. Only assistant message \nitems can be truncated.\n"
  }),
  "content_index": Schema.Number.annotate({
    "description": "The index of the content part to truncate. Set this to `0`."
  }).check(Schema.isInt()),
  "audio_end_ms": Schema.Number.annotate({
    "description":
      "Inclusive duration up to which audio is truncated, in milliseconds. If \nthe audio_end_ms is greater than the actual audio duration, the server \nwill respond with an error.\n"
  }).check(Schema.isInt())
}).annotate({
  "description":
    "Send this event to truncate a previous assistant messages audio. The server \nwill produce audio faster than realtime, so this event is useful when the user \ninterrupts to truncate audio that has already been sent to the client but not \nyet played. This will synchronize the server's understanding of the audio with \nthe client's playback.\n\nTruncating audio will delete the server-side text transcript to ensure there \nis not text in the context that hasn't been heard by the user.\n\nIf successful, the server will respond with a `conversation.item.truncated` \nevent. \n"
})
export type RealtimeClientEventInputAudioBufferAppend = {
  readonly "event_id"?: string
  readonly "type": "input_audio_buffer.append"
  readonly "audio": string
}
export const RealtimeClientEventInputAudioBufferAppend = Schema.Struct({
  "event_id": Schema.optionalKey(
    Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." }).check(
      Schema.isMaxLength(512)
    )
  ),
  "type": Schema.Literal("input_audio_buffer.append").annotate({
    "description": "The event type, must be `input_audio_buffer.append`."
  }),
  "audio": Schema.String.annotate({
    "description":
      "Base64-encoded audio bytes. This must be in the format specified by the \n`input_audio_format` field in the session configuration.\n"
  })
}).annotate({
  "description":
    "Send this event to append audio bytes to the input audio buffer. The audio \nbuffer is temporary storage you can write to and later commit. A \"commit\" will create a new\nuser message item in the conversation history from the buffer content and clear the buffer.\nInput audio transcription (if enabled) will be generated when the buffer is committed.\n\nIf VAD is enabled the audio buffer is used to detect speech and the server will decide \nwhen to commit. When Server VAD is disabled, you must commit the audio buffer\nmanually. Input audio noise reduction operates on writes to the audio buffer.\n\nThe client may choose how much audio to place in each event up to a maximum \nof 15 MiB, for example streaming smaller chunks from the client may allow the \nVAD to be more responsive. Unlike most other client events, the server will \nnot send a confirmation response to this event.\n"
})
export type RealtimeClientEventInputAudioBufferClear = {
  readonly "event_id"?: string
  readonly "type": "input_audio_buffer.clear"
}
export const RealtimeClientEventInputAudioBufferClear = Schema.Struct({
  "event_id": Schema.optionalKey(
    Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." }).check(
      Schema.isMaxLength(512)
    )
  ),
  "type": Schema.Literal("input_audio_buffer.clear").annotate({
    "description": "The event type, must be `input_audio_buffer.clear`."
  })
}).annotate({
  "description":
    "Send this event to clear the audio bytes in the buffer. The server will \nrespond with an `input_audio_buffer.cleared` event.\n"
})
export type RealtimeClientEventInputAudioBufferCommit = {
  readonly "event_id"?: string
  readonly "type": "input_audio_buffer.commit"
}
export const RealtimeClientEventInputAudioBufferCommit = Schema.Struct({
  "event_id": Schema.optionalKey(
    Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." }).check(
      Schema.isMaxLength(512)
    )
  ),
  "type": Schema.Literal("input_audio_buffer.commit").annotate({
    "description": "The event type, must be `input_audio_buffer.commit`."
  })
}).annotate({
  "description":
    "Send this event to commit the user input audio buffer, which will create a  new user message item in the conversation. This event will produce an error  if the input audio buffer is empty. When in Server VAD mode, the client does  not need to send this event, the server will commit the audio buffer  automatically.\n\nCommitting the input audio buffer will trigger input audio transcription  (if enabled in session configuration), but it will not create a response  from the model. The server will respond with an `input_audio_buffer.committed` event.\n"
})
export type RealtimeClientEventOutputAudioBufferClear = {
  readonly "event_id"?: string
  readonly "type": "output_audio_buffer.clear"
}
export const RealtimeClientEventOutputAudioBufferClear = Schema.Struct({
  "event_id": Schema.optionalKey(
    Schema.String.annotate({ "description": "The unique ID of the client event used for error handling." })
  ),
  "type": Schema.Literal("output_audio_buffer.clear").annotate({
    "description": "The event type, must be `output_audio_buffer.clear`."
  })
}).annotate({
  "description":
    "**WebRTC/SIP Only:** Emit to cut off the current audio response. This will trigger the server to\nstop generating audio and emit a `output_audio_buffer.cleared` event. This\nevent should be preceded by a `response.cancel` client event to stop the\ngeneration of the current response.\n[Learn more](/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\n"
})
export type RealtimeClientEventResponseCancel = {
  readonly "event_id"?: string
  readonly "type": "response.cancel"
  readonly "response_id"?: string
}
export const RealtimeClientEventResponseCancel = Schema.Struct({
  "event_id": Schema.optionalKey(
    Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." }).check(
      Schema.isMaxLength(512)
    )
  ),
  "type": Schema.Literal("response.cancel").annotate({ "description": "The event type, must be `response.cancel`." }),
  "response_id": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "A specific response ID to cancel - if not provided, will cancel an \nin-progress response in the default conversation.\n"
    })
  )
}).annotate({
  "description":
    "Send this event to cancel an in-progress response. The server will respond \nwith a `response.done` event with a status of `response.status=cancelled`. If \nthere is no response to cancel, the server will respond with an error. It's safe\nto call `response.cancel` even if no response is in progress, an error will be\nreturned the session will remain unaffected.\n"
})
export type RealtimeConversationItemFunctionCall = {
  readonly "id"?: string
  readonly "object"?: "realtime.item"
  readonly "type": "function_call"
  readonly "status"?: "completed" | "incomplete" | "in_progress"
  readonly "call_id"?: string
  readonly "name": string
  readonly "arguments": string
}
export const RealtimeConversationItemFunctionCall = Schema.Struct({
  "id": Schema.optionalKey(
    Schema.String.annotate({
      "description": "The unique ID of the item. This may be provided by the client or generated by the server."
    })
  ),
  "object": Schema.optionalKey(
    Schema.Literal("realtime.item").annotate({
      "description":
        "Identifier for the API object being returned - always `realtime.item`. Optional when creating a new item."
    })
  ),
  "type": Schema.Literal("function_call").annotate({ "description": "The type of the item. Always `function_call`." }),
  "status": Schema.optionalKey(
    Schema.Literals(["completed", "incomplete", "in_progress"]).annotate({
      "description": "The status of the item. Has no effect on the conversation."
    })
  ),
  "call_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the function call." })),
  "name": Schema.String.annotate({ "description": "The name of the function being called." }),
  "arguments": Schema.String.annotate({
    "description":
      "The arguments of the function call. This is a JSON-encoded string representing the arguments passed to the function, for example `{\"arg1\": \"value1\", \"arg2\": 42}`."
  })
}).annotate({
  "title": "Realtime function call item",
  "description": "A function call item in a Realtime conversation."
})
export type RealtimeConversationItemFunctionCallOutput = {
  readonly "id"?: string
  readonly "object"?: "realtime.item"
  readonly "type": "function_call_output"
  readonly "status"?: "completed" | "incomplete" | "in_progress"
  readonly "call_id": string
  readonly "output": string
}
export const RealtimeConversationItemFunctionCallOutput = Schema.Struct({
  "id": Schema.optionalKey(
    Schema.String.annotate({
      "description": "The unique ID of the item. This may be provided by the client or generated by the server."
    })
  ),
  "object": Schema.optionalKey(
    Schema.Literal("realtime.item").annotate({
      "description":
        "Identifier for the API object being returned - always `realtime.item`. Optional when creating a new item."
    })
  ),
  "type": Schema.Literal("function_call_output").annotate({
    "description": "The type of the item. Always `function_call_output`."
  }),
  "status": Schema.optionalKey(
    Schema.Literals(["completed", "incomplete", "in_progress"]).annotate({
      "description": "The status of the item. Has no effect on the conversation."
    })
  ),
  "call_id": Schema.String.annotate({ "description": "The ID of the function call this output is for." }),
  "output": Schema.String.annotate({
    "description":
      "The output of the function call, this is free text and can contain any information or simply be empty."
  })
}).annotate({
  "title": "Realtime function call output item",
  "description": "A function call output item in a Realtime conversation."
})
export type RealtimeConversationItemMessageAssistant = {
  readonly "id"?: string
  readonly "object"?: "realtime.item"
  readonly "type": "message"
  readonly "status"?: "completed" | "incomplete" | "in_progress"
  readonly "role": "assistant"
  readonly "content": ReadonlyArray<
    {
      readonly "type"?: "output_text" | "output_audio"
      readonly "text"?: string
      readonly "audio"?: string
      readonly "transcript"?: string
    }
  >
}
export const RealtimeConversationItemMessageAssistant = Schema.Struct({
  "id": Schema.optionalKey(
    Schema.String.annotate({
      "description": "The unique ID of the item. This may be provided by the client or generated by the server."
    })
  ),
  "object": Schema.optionalKey(
    Schema.Literal("realtime.item").annotate({
      "description":
        "Identifier for the API object being returned - always `realtime.item`. Optional when creating a new item."
    })
  ),
  "type": Schema.Literal("message").annotate({ "description": "The type of the item. Always `message`." }),
  "status": Schema.optionalKey(
    Schema.Literals(["completed", "incomplete", "in_progress"]).annotate({
      "description": "The status of the item. Has no effect on the conversation."
    })
  ),
  "role": Schema.Literal("assistant").annotate({
    "description": "The role of the message sender. Always `assistant`."
  }),
  "content": Schema.Array(Schema.Struct({
    "type": Schema.optionalKey(
      Schema.Literals(["output_text", "output_audio"]).annotate({
        "description":
          "The content type, `output_text` or `output_audio` depending on the session `output_modalities` configuration."
      })
    ),
    "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content." })),
    "audio": Schema.optionalKey(
      Schema.String.annotate({
        "description":
          "Base64-encoded audio bytes, these will be parsed as the format specified in the session output audio type configuration. This defaults to PCM 16-bit 24kHz mono if not specified."
      })
    ),
    "transcript": Schema.optionalKey(
      Schema.String.annotate({
        "description": "The transcript of the audio content, this will always be present if the output type is `audio`."
      })
    )
  })).annotate({ "description": "The content of the message." })
}).annotate({
  "title": "Realtime assistant message item",
  "description": "An assistant message item in a Realtime conversation."
})
export type RealtimeConversationItemMessageSystem = {
  readonly "id"?: string
  readonly "object"?: "realtime.item"
  readonly "type": "message"
  readonly "status"?: "completed" | "incomplete" | "in_progress"
  readonly "role": "system"
  readonly "content": ReadonlyArray<{ readonly "type"?: "input_text"; readonly "text"?: string }>
}
export const RealtimeConversationItemMessageSystem = Schema.Struct({
  "id": Schema.optionalKey(
    Schema.String.annotate({
      "description": "The unique ID of the item. This may be provided by the client or generated by the server."
    })
  ),
  "object": Schema.optionalKey(
    Schema.Literal("realtime.item").annotate({
      "description":
        "Identifier for the API object being returned - always `realtime.item`. Optional when creating a new item."
    })
  ),
  "type": Schema.Literal("message").annotate({ "description": "The type of the item. Always `message`." }),
  "status": Schema.optionalKey(
    Schema.Literals(["completed", "incomplete", "in_progress"]).annotate({
      "description": "The status of the item. Has no effect on the conversation."
    })
  ),
  "role": Schema.Literal("system").annotate({ "description": "The role of the message sender. Always `system`." }),
  "content": Schema.Array(
    Schema.Struct({
      "type": Schema.optionalKey(
        Schema.Literal("input_text").annotate({
          "description": "The content type. Always `input_text` for system messages."
        })
      ),
      "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content." }))
    })
  ).annotate({ "description": "The content of the message." })
}).annotate({
  "title": "Realtime system message item",
  "description":
    "A system message in a Realtime conversation can be used to provide additional context or instructions to the model. This is similar but distinct from the instruction prompt provided at the start of a conversation, as system messages can be added at any point in the conversation. For major changes to the conversation's behavior, use instructions, but for smaller updates (e.g. \"the user is now asking about a different topic\"), use system messages."
})
export type RealtimeConversationItemMessageUser = {
  readonly "id"?: string
  readonly "object"?: "realtime.item"
  readonly "type": "message"
  readonly "status"?: "completed" | "incomplete" | "in_progress"
  readonly "role": "user"
  readonly "content": ReadonlyArray<
    {
      readonly "type"?: "input_text" | "input_audio" | "input_image"
      readonly "text"?: string
      readonly "audio"?: string
      readonly "image_url"?: string
      readonly "detail"?: "auto" | "low" | "high"
      readonly "transcript"?: string
    }
  >
}
export const RealtimeConversationItemMessageUser = Schema.Struct({
  "id": Schema.optionalKey(
    Schema.String.annotate({
      "description": "The unique ID of the item. This may be provided by the client or generated by the server."
    })
  ),
  "object": Schema.optionalKey(
    Schema.Literal("realtime.item").annotate({
      "description":
        "Identifier for the API object being returned - always `realtime.item`. Optional when creating a new item."
    })
  ),
  "type": Schema.Literal("message").annotate({ "description": "The type of the item. Always `message`." }),
  "status": Schema.optionalKey(
    Schema.Literals(["completed", "incomplete", "in_progress"]).annotate({
      "description": "The status of the item. Has no effect on the conversation."
    })
  ),
  "role": Schema.Literal("user").annotate({ "description": "The role of the message sender. Always `user`." }),
  "content": Schema.Array(Schema.Struct({
    "type": Schema.optionalKey(
      Schema.Literals(["input_text", "input_audio", "input_image"]).annotate({
        "description": "The content type (`input_text`, `input_audio`, or `input_image`)."
      })
    ),
    "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content (for `input_text`)." })),
    "audio": Schema.optionalKey(
      Schema.String.annotate({
        "description":
          "Base64-encoded audio bytes (for `input_audio`), these will be parsed as the format specified in the session input audio type configuration. This defaults to PCM 16-bit 24kHz mono if not specified."
      })
    ),
    "image_url": Schema.optionalKey(
      Schema.String.annotate({
        "description":
          "Base64-encoded image bytes (for `input_image`) as a data URI. For example `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA...`. Supported formats are PNG and JPEG."
      })
    ),
    "detail": Schema.optionalKey(
      Schema.Literals(["auto", "low", "high"]).annotate({
        "description": "The detail level of the image (for `input_image`). `auto` will default to `high`."
      })
    ),
    "transcript": Schema.optionalKey(
      Schema.String.annotate({
        "description":
          "Transcript of the audio (for `input_audio`). This is not sent to the model, but will be attached to the message item for reference."
      })
    )
  })).annotate({ "description": "The content of the message." })
}).annotate({ "title": "Realtime user message item", "description": "A user message item in a Realtime conversation." })
export type RealtimeFunctionTool = {
  readonly "type"?: "function"
  readonly "name"?: string
  readonly "description"?: string
  readonly "parameters"?: {}
}
export const RealtimeFunctionTool = Schema.Struct({
  "type": Schema.optionalKey(
    Schema.Literal("function").annotate({ "description": "The type of the tool, i.e. `function`." })
  ),
  "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the function." })),
  "description": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "The description of the function, including guidance on when and how\nto call it, and guidance about what to tell the user when calling\n(if anything).\n"
    })
  ),
  "parameters": Schema.optionalKey(
    Schema.Struct({}).annotate({ "description": "Parameters of the function in JSON Schema." })
  )
}).annotate({ "title": "Function tool" })
export type RealtimeMCPApprovalRequest = {
  readonly "type": "mcp_approval_request"
  readonly "id": string
  readonly "server_label": string
  readonly "name": string
  readonly "arguments": string
}
export const RealtimeMCPApprovalRequest = Schema.Struct({
  "type": Schema.Literal("mcp_approval_request").annotate({
    "description": "The type of the item. Always `mcp_approval_request`."
  }),
  "id": Schema.String.annotate({ "description": "The unique ID of the approval request." }),
  "server_label": Schema.String.annotate({ "description": "The label of the MCP server making the request." }),
  "name": Schema.String.annotate({ "description": "The name of the tool to run." }),
  "arguments": Schema.String.annotate({ "description": "A JSON string of arguments for the tool." })
}).annotate({
  "title": "Realtime MCP approval request",
  "description": "A Realtime item requesting human approval of a tool invocation.\n"
})
export type RealtimeMCPApprovalResponse = {
  readonly "type": "mcp_approval_response"
  readonly "id": string
  readonly "approval_request_id": string
  readonly "approve": boolean
  readonly "reason"?: string | null
}
export const RealtimeMCPApprovalResponse = Schema.Struct({
  "type": Schema.Literal("mcp_approval_response").annotate({
    "description": "The type of the item. Always `mcp_approval_response`."
  }),
  "id": Schema.String.annotate({ "description": "The unique ID of the approval response." }),
  "approval_request_id": Schema.String.annotate({ "description": "The ID of the approval request being answered." }),
  "approve": Schema.Boolean.annotate({ "description": "Whether the request was approved." }),
  "reason": Schema.optionalKey(
    Schema.Union([Schema.String.annotate({ "description": "Optional reason for the decision." }), Schema.Null])
  )
}).annotate({
  "title": "Realtime MCP approval response",
  "description": "A Realtime item responding to an MCP approval request.\n"
})
export type RealtimeMCPHTTPError = {
  readonly "type": "http_error"
  readonly "code": number
  readonly "message": string
}
export const RealtimeMCPHTTPError = Schema.Struct({
  "type": Schema.Literal("http_error"),
  "code": Schema.Number.check(Schema.isInt()),
  "message": Schema.String
}).annotate({ "title": "Realtime MCP HTTP error" })
export type RealtimeMCPProtocolError = {
  readonly "type": "protocol_error"
  readonly "code": number
  readonly "message": string
}
export const RealtimeMCPProtocolError = Schema.Struct({
  "type": Schema.Literal("protocol_error"),
  "code": Schema.Number.check(Schema.isInt()),
  "message": Schema.String
}).annotate({ "title": "Realtime MCP protocol error" })
export type RealtimeMCPToolExecutionError = { readonly "type": "tool_execution_error"; readonly "message": string }
export const RealtimeMCPToolExecutionError = Schema.Struct({
  "type": Schema.Literal("tool_execution_error"),
  "message": Schema.String
}).annotate({ "title": "Realtime MCP tool execution error" })
export type RealtimeServerEventConversationCreated = {
  readonly "event_id": string
  readonly "type": "conversation.created"
  readonly "conversation": { readonly "id"?: string; readonly "object"?: string }
}
export const RealtimeServerEventConversationCreated = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("conversation.created").annotate({
    "description": "The event type, must be `conversation.created`."
  }),
  "conversation": Schema.Struct({
    "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the conversation." })),
    "object": Schema.optionalKey(
      Schema.String.annotate({ "description": "The object type, must be `realtime.conversation`." })
    )
  }).annotate({ "description": "The conversation resource." })
}).annotate({ "description": "Returned when a conversation is created. Emitted right after session creation.\n" })
export type RealtimeServerEventConversationItemDeleted = {
  readonly "event_id": string
  readonly "type": "conversation.item.deleted"
  readonly "item_id": string
}
export const RealtimeServerEventConversationItemDeleted = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("conversation.item.deleted").annotate({
    "description": "The event type, must be `conversation.item.deleted`."
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the item that was deleted." })
}).annotate({
  "description":
    "Returned when an item in the conversation is deleted by the client with a \n`conversation.item.delete` event. This event is used to synchronize the \nserver's understanding of the conversation history with the client's view.\n"
})
export type RealtimeServerEventConversationItemInputAudioTranscriptionFailed = {
  readonly "event_id": string
  readonly "type": "conversation.item.input_audio_transcription.failed"
  readonly "item_id": string
  readonly "content_index": number
  readonly "error": {
    readonly "type"?: string
    readonly "code"?: string
    readonly "message"?: string
    readonly "param"?: string
  }
}
export const RealtimeServerEventConversationItemInputAudioTranscriptionFailed = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("conversation.item.input_audio_transcription.failed").annotate({
    "description": "The event type, must be\n`conversation.item.input_audio_transcription.failed`.\n"
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the user message item." }),
  "content_index": Schema.Number.annotate({ "description": "The index of the content part containing the audio." })
    .check(Schema.isInt()),
  "error": Schema.Struct({
    "type": Schema.optionalKey(Schema.String.annotate({ "description": "The type of error." })),
    "code": Schema.optionalKey(Schema.String.annotate({ "description": "Error code, if any." })),
    "message": Schema.optionalKey(Schema.String.annotate({ "description": "A human-readable error message." })),
    "param": Schema.optionalKey(Schema.String.annotate({ "description": "Parameter related to the error, if any." }))
  }).annotate({ "description": "Details of the transcription error." })
}).annotate({
  "description":
    "Returned when input audio transcription is configured, and a transcription \nrequest for a user message failed. These events are separate from other \n`error` events so that the client can identify the related Item.\n"
})
export type RealtimeServerEventConversationItemInputAudioTranscriptionSegment = {
  readonly "event_id": string
  readonly "type": "conversation.item.input_audio_transcription.segment"
  readonly "item_id": string
  readonly "content_index": number
  readonly "text": string
  readonly "id": string
  readonly "speaker": string
  readonly "start": number
  readonly "end": number
}
export const RealtimeServerEventConversationItemInputAudioTranscriptionSegment = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("conversation.item.input_audio_transcription.segment").annotate({
    "description": "The event type, must be `conversation.item.input_audio_transcription.segment`."
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the item containing the input audio content." }),
  "content_index": Schema.Number.annotate({
    "description": "The index of the input audio content part within the item."
  }).check(Schema.isInt()),
  "text": Schema.String.annotate({ "description": "The text for this segment." }),
  "id": Schema.String.annotate({ "description": "The segment identifier." }),
  "speaker": Schema.String.annotate({ "description": "The detected speaker label for this segment." }),
  "start": Schema.Number.annotate({ "description": "Start time of the segment in seconds.", "format": "float" }).check(
    Schema.isFinite()
  ),
  "end": Schema.Number.annotate({ "description": "End time of the segment in seconds.", "format": "float" }).check(
    Schema.isFinite()
  )
}).annotate({ "description": "Returned when an input audio transcription segment is identified for an item." })
export type RealtimeServerEventConversationItemTruncated = {
  readonly "event_id": string
  readonly "type": "conversation.item.truncated"
  readonly "item_id": string
  readonly "content_index": number
  readonly "audio_end_ms": number
}
export const RealtimeServerEventConversationItemTruncated = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("conversation.item.truncated").annotate({
    "description": "The event type, must be `conversation.item.truncated`."
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the assistant message item that was truncated." }),
  "content_index": Schema.Number.annotate({ "description": "The index of the content part that was truncated." }).check(
    Schema.isInt()
  ),
  "audio_end_ms": Schema.Number.annotate({
    "description": "The duration up to which the audio was truncated, in milliseconds.\n"
  }).check(Schema.isInt())
}).annotate({
  "description":
    "Returned when an earlier assistant audio message item is truncated by the \nclient with a `conversation.item.truncate` event. This event is used to \nsynchronize the server's understanding of the audio with the client's playback.\n\nThis action will truncate the audio and remove the server-side text transcript \nto ensure there is no text in the context that hasn't been heard by the user.\n"
})
export type RealtimeServerEventError = {
  readonly "event_id": string
  readonly "type": "error"
  readonly "error": {
    readonly "type": string
    readonly "code"?: string | null
    readonly "message": string
    readonly "param"?: string | null
    readonly "event_id"?: string | null
  }
}
export const RealtimeServerEventError = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("error").annotate({ "description": "The event type, must be `error`." }),
  "error": Schema.Struct({
    "type": Schema.String.annotate({
      "description": "The type of error (e.g., \"invalid_request_error\", \"server_error\").\n"
    }),
    "code": Schema.optionalKey(
      Schema.Union([Schema.String.annotate({ "description": "Error code, if any." }), Schema.Null])
    ),
    "message": Schema.String.annotate({ "description": "A human-readable error message." }),
    "param": Schema.optionalKey(
      Schema.Union([Schema.String.annotate({ "description": "Parameter related to the error, if any." }), Schema.Null])
    ),
    "event_id": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description": "The event_id of the client event that caused the error, if applicable.\n"
        }),
        Schema.Null
      ])
    )
  }).annotate({ "description": "Details of the error." })
}).annotate({
  "description":
    "Returned when an error occurs, which could be a client problem or a server\nproblem. Most errors are recoverable and the session will stay open, we\nrecommend to implementors to monitor and log error messages by default.\n"
})
export type RealtimeServerEventInputAudioBufferCleared = {
  readonly "event_id": string
  readonly "type": "input_audio_buffer.cleared"
}
export const RealtimeServerEventInputAudioBufferCleared = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("input_audio_buffer.cleared").annotate({
    "description": "The event type, must be `input_audio_buffer.cleared`."
  })
}).annotate({
  "description":
    "Returned when the input audio buffer is cleared by the client with a \n`input_audio_buffer.clear` event.\n"
})
export type RealtimeServerEventInputAudioBufferCommitted = {
  readonly "event_id": string
  readonly "type": "input_audio_buffer.committed"
  readonly "previous_item_id"?: string | null
  readonly "item_id": string
}
export const RealtimeServerEventInputAudioBufferCommitted = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("input_audio_buffer.committed").annotate({
    "description": "The event type, must be `input_audio_buffer.committed`."
  }),
  "previous_item_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "The ID of the preceding item after which the new item will be inserted.\nCan be `null` if the item has no predecessor.\n"
      }),
      Schema.Null
    ])
  ),
  "item_id": Schema.String.annotate({ "description": "The ID of the user message item that will be created." })
}).annotate({
  "description":
    "Returned when an input audio buffer is committed, either by the client or\nautomatically in server VAD mode. The `item_id` property is the ID of the user\nmessage item that will be created, thus a `conversation.item.created` event\nwill also be sent to the client.\n"
})
export type RealtimeServerEventInputAudioBufferDtmfEventReceived = {
  readonly "type": "input_audio_buffer.dtmf_event_received"
  readonly "event": string
  readonly "received_at": number
}
export const RealtimeServerEventInputAudioBufferDtmfEventReceived = Schema.Struct({
  "type": Schema.Literal("input_audio_buffer.dtmf_event_received").annotate({
    "description": "The event type, must be `input_audio_buffer.dtmf_event_received`."
  }),
  "event": Schema.String.annotate({ "description": "The telephone keypad that was pressed by the user." }),
  "received_at": Schema.Number.annotate({
    "description": "UTC Unix Timestamp when DTMF Event was received by server.\n"
  }).check(Schema.isInt())
}).annotate({
  "description":
    "**SIP Only:** Returned when an DTMF event is received. A DTMF event is a message that\nrepresents a telephone keypad press (09, *, #, AD). The `event` property\nis the keypad that the user press. The `received_at` is the UTC Unix Timestamp\nthat the server received the event.\n"
})
export type RealtimeServerEventInputAudioBufferSpeechStarted = {
  readonly "event_id": string
  readonly "type": "input_audio_buffer.speech_started"
  readonly "audio_start_ms": number
  readonly "item_id": string
}
export const RealtimeServerEventInputAudioBufferSpeechStarted = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("input_audio_buffer.speech_started").annotate({
    "description": "The event type, must be `input_audio_buffer.speech_started`."
  }),
  "audio_start_ms": Schema.Number.annotate({
    "description":
      "Milliseconds from the start of all audio written to the buffer during the \nsession when speech was first detected. This will correspond to the \nbeginning of audio sent to the model, and thus includes the \n`prefix_padding_ms` configured in the Session.\n"
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({
    "description": "The ID of the user message item that will be created when speech stops.\n"
  })
}).annotate({
  "description":
    "Sent by the server when in `server_vad` mode to indicate that speech has been \ndetected in the audio buffer. This can happen any time audio is added to the \nbuffer (unless speech is already detected). The client may want to use this \nevent to interrupt audio playback or provide visual feedback to the user. \n\nThe client should expect to receive a `input_audio_buffer.speech_stopped` event \nwhen speech stops. The `item_id` property is the ID of the user message item \nthat will be created when speech stops and will also be included in the \n`input_audio_buffer.speech_stopped` event (unless the client manually commits \nthe audio buffer during VAD activation).\n"
})
export type RealtimeServerEventInputAudioBufferSpeechStopped = {
  readonly "event_id": string
  readonly "type": "input_audio_buffer.speech_stopped"
  readonly "audio_end_ms": number
  readonly "item_id": string
}
export const RealtimeServerEventInputAudioBufferSpeechStopped = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("input_audio_buffer.speech_stopped").annotate({
    "description": "The event type, must be `input_audio_buffer.speech_stopped`."
  }),
  "audio_end_ms": Schema.Number.annotate({
    "description":
      "Milliseconds since the session started when speech stopped. This will \ncorrespond to the end of audio sent to the model, and thus includes the \n`min_silence_duration_ms` configured in the Session.\n"
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({ "description": "The ID of the user message item that will be created." })
}).annotate({
  "description":
    "Returned in `server_vad` mode when the server detects the end of speech in \nthe audio buffer. The server will also send an `conversation.item.created` \nevent with the user message item that is created from the audio buffer.\n"
})
export type RealtimeServerEventInputAudioBufferTimeoutTriggered = {
  readonly "event_id": string
  readonly "type": "input_audio_buffer.timeout_triggered"
  readonly "audio_start_ms": number
  readonly "audio_end_ms": number
  readonly "item_id": string
}
export const RealtimeServerEventInputAudioBufferTimeoutTriggered = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("input_audio_buffer.timeout_triggered").annotate({
    "description": "The event type, must be `input_audio_buffer.timeout_triggered`."
  }),
  "audio_start_ms": Schema.Number.annotate({
    "description":
      "Millisecond offset of audio written to the input audio buffer that was after the playback time of the last model response."
  }).check(Schema.isInt()),
  "audio_end_ms": Schema.Number.annotate({
    "description":
      "Millisecond offset of audio written to the input audio buffer at the time the timeout was triggered."
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({ "description": "The ID of the item associated with this segment." })
}).annotate({
  "description":
    "Returned when the Server VAD timeout is triggered for the input audio buffer. This is configured\nwith `idle_timeout_ms` in the `turn_detection` settings of the session, and it indicates that\nthere hasn't been any speech detected for the configured duration.\n\nThe `audio_start_ms` and `audio_end_ms` fields indicate the segment of audio after the last\nmodel response up to the triggering time, as an offset from the beginning of audio written\nto the input audio buffer. This means it demarcates the segment of audio that was silent and\nthe difference between the start and end values will roughly match the configured timeout.\n\nThe empty audio will be committed to the conversation as an `input_audio` item (there will be a\n`input_audio_buffer.committed` event) and a model response will be generated. There may be speech\nthat didn't trigger VAD but is still detected by the model, so the model may respond with\nsomething relevant to the conversation or a prompt to continue speaking.\n"
})
export type RealtimeServerEventMCPListToolsCompleted = {
  readonly "event_id": string
  readonly "type": "mcp_list_tools.completed"
  readonly "item_id": string
}
export const RealtimeServerEventMCPListToolsCompleted = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("mcp_list_tools.completed").annotate({
    "description": "The event type, must be `mcp_list_tools.completed`."
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the MCP list tools item." })
}).annotate({ "description": "Returned when listing MCP tools has completed for an item." })
export type RealtimeServerEventMCPListToolsFailed = {
  readonly "event_id": string
  readonly "type": "mcp_list_tools.failed"
  readonly "item_id": string
}
export const RealtimeServerEventMCPListToolsFailed = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("mcp_list_tools.failed").annotate({
    "description": "The event type, must be `mcp_list_tools.failed`."
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the MCP list tools item." })
}).annotate({ "description": "Returned when listing MCP tools has failed for an item." })
export type RealtimeServerEventMCPListToolsInProgress = {
  readonly "event_id": string
  readonly "type": "mcp_list_tools.in_progress"
  readonly "item_id": string
}
export const RealtimeServerEventMCPListToolsInProgress = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("mcp_list_tools.in_progress").annotate({
    "description": "The event type, must be `mcp_list_tools.in_progress`."
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the MCP list tools item." })
}).annotate({ "description": "Returned when listing MCP tools is in progress for an item." })
export type RealtimeServerEventOutputAudioBufferCleared = {
  readonly "event_id": string
  readonly "type": "output_audio_buffer.cleared"
  readonly "response_id": string
}
export const RealtimeServerEventOutputAudioBufferCleared = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("output_audio_buffer.cleared").annotate({
    "description": "The event type, must be `output_audio_buffer.cleared`."
  }),
  "response_id": Schema.String.annotate({ "description": "The unique ID of the response that produced the audio." })
}).annotate({
  "description":
    "**WebRTC/SIP Only:** Emitted when the output audio buffer is cleared. This happens either in VAD\nmode when the user has interrupted (`input_audio_buffer.speech_started`),\nor when the client has emitted the `output_audio_buffer.clear` event to manually\ncut off the current audio response.\n[Learn more](/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\n"
})
export type RealtimeServerEventOutputAudioBufferStarted = {
  readonly "event_id": string
  readonly "type": "output_audio_buffer.started"
  readonly "response_id": string
}
export const RealtimeServerEventOutputAudioBufferStarted = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("output_audio_buffer.started").annotate({
    "description": "The event type, must be `output_audio_buffer.started`."
  }),
  "response_id": Schema.String.annotate({ "description": "The unique ID of the response that produced the audio." })
}).annotate({
  "description":
    "**WebRTC/SIP Only:** Emitted when the server begins streaming audio to the client. This event is\nemitted after an audio content part has been added (`response.content_part.added`)\nto the response.\n[Learn more](/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\n"
})
export type RealtimeServerEventOutputAudioBufferStopped = {
  readonly "event_id": string
  readonly "type": "output_audio_buffer.stopped"
  readonly "response_id": string
}
export const RealtimeServerEventOutputAudioBufferStopped = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("output_audio_buffer.stopped").annotate({
    "description": "The event type, must be `output_audio_buffer.stopped`."
  }),
  "response_id": Schema.String.annotate({ "description": "The unique ID of the response that produced the audio." })
}).annotate({
  "description":
    "**WebRTC/SIP Only:** Emitted when the output audio buffer has been completely drained on the server,\nand no more audio is forthcoming. This event is emitted after the full response\ndata has been sent to the client (`response.done`).\n[Learn more](/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\n"
})
export type RealtimeServerEventRateLimitsUpdated = {
  readonly "event_id": string
  readonly "type": "rate_limits.updated"
  readonly "rate_limits": ReadonlyArray<
    {
      readonly "name"?: "requests" | "tokens"
      readonly "limit"?: number
      readonly "remaining"?: number
      readonly "reset_seconds"?: number
    }
  >
}
export const RealtimeServerEventRateLimitsUpdated = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("rate_limits.updated").annotate({
    "description": "The event type, must be `rate_limits.updated`."
  }),
  "rate_limits": Schema.Array(Schema.Struct({
    "name": Schema.optionalKey(
      Schema.Literals(["requests", "tokens"]).annotate({
        "description": "The name of the rate limit (`requests`, `tokens`).\n"
      })
    ),
    "limit": Schema.optionalKey(
      Schema.Number.annotate({ "description": "The maximum allowed value for the rate limit." }).check(Schema.isInt())
    ),
    "remaining": Schema.optionalKey(
      Schema.Number.annotate({ "description": "The remaining value before the limit is reached." }).check(
        Schema.isInt()
      )
    ),
    "reset_seconds": Schema.optionalKey(
      Schema.Number.annotate({ "description": "Seconds until the rate limit resets." }).check(Schema.isFinite())
    )
  })).annotate({ "description": "List of rate limit information." })
}).annotate({
  "description":
    "Emitted at the beginning of a Response to indicate the updated rate limits. \nWhen a Response is created some tokens will be \"reserved\" for the output \ntokens, the rate limits shown here reflect that reservation, which is then \nadjusted accordingly once the Response is completed.\n"
})
export type RealtimeServerEventResponseAudioDelta = {
  readonly "event_id": string
  readonly "type": "response.output_audio.delta"
  readonly "response_id": string
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
  readonly "delta": string
}
export const RealtimeServerEventResponseAudioDelta = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.output_audio.delta").annotate({
    "description": "The event type, must be `response.output_audio.delta`."
  }),
  "response_id": Schema.String.annotate({ "description": "The ID of the response." }),
  "item_id": Schema.String.annotate({ "description": "The ID of the item." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(
    Schema.isInt()
  ),
  "content_index": Schema.Number.annotate({
    "description": "The index of the content part in the item's content array."
  }).check(Schema.isInt()),
  "delta": Schema.String.annotate({ "description": "Base64-encoded audio data delta." })
}).annotate({ "description": "Returned when the model-generated audio is updated." })
export type RealtimeServerEventResponseAudioDone = {
  readonly "event_id": string
  readonly "type": "response.output_audio.done"
  readonly "response_id": string
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
}
export const RealtimeServerEventResponseAudioDone = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.output_audio.done").annotate({
    "description": "The event type, must be `response.output_audio.done`."
  }),
  "response_id": Schema.String.annotate({ "description": "The ID of the response." }),
  "item_id": Schema.String.annotate({ "description": "The ID of the item." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(
    Schema.isInt()
  ),
  "content_index": Schema.Number.annotate({
    "description": "The index of the content part in the item's content array."
  }).check(Schema.isInt())
}).annotate({
  "description":
    "Returned when the model-generated audio is done. Also emitted when a Response\nis interrupted, incomplete, or cancelled.\n"
})
export type RealtimeServerEventResponseAudioTranscriptDelta = {
  readonly "event_id": string
  readonly "type": "response.output_audio_transcript.delta"
  readonly "response_id": string
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
  readonly "delta": string
}
export const RealtimeServerEventResponseAudioTranscriptDelta = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.output_audio_transcript.delta").annotate({
    "description": "The event type, must be `response.output_audio_transcript.delta`."
  }),
  "response_id": Schema.String.annotate({ "description": "The ID of the response." }),
  "item_id": Schema.String.annotate({ "description": "The ID of the item." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(
    Schema.isInt()
  ),
  "content_index": Schema.Number.annotate({
    "description": "The index of the content part in the item's content array."
  }).check(Schema.isInt()),
  "delta": Schema.String.annotate({ "description": "The transcript delta." })
}).annotate({ "description": "Returned when the model-generated transcription of audio output is updated.\n" })
export type RealtimeServerEventResponseAudioTranscriptDone = {
  readonly "event_id": string
  readonly "type": "response.output_audio_transcript.done"
  readonly "response_id": string
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
  readonly "transcript": string
}
export const RealtimeServerEventResponseAudioTranscriptDone = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.output_audio_transcript.done").annotate({
    "description": "The event type, must be `response.output_audio_transcript.done`."
  }),
  "response_id": Schema.String.annotate({ "description": "The ID of the response." }),
  "item_id": Schema.String.annotate({ "description": "The ID of the item." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(
    Schema.isInt()
  ),
  "content_index": Schema.Number.annotate({
    "description": "The index of the content part in the item's content array."
  }).check(Schema.isInt()),
  "transcript": Schema.String.annotate({ "description": "The final transcript of the audio." })
}).annotate({
  "description":
    "Returned when the model-generated transcription of audio output is done\nstreaming. Also emitted when a Response is interrupted, incomplete, or\ncancelled.\n"
})
export type RealtimeServerEventResponseContentPartAdded = {
  readonly "event_id": string
  readonly "type": "response.content_part.added"
  readonly "response_id": string
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
  readonly "part": {
    readonly "type"?: "audio" | "text"
    readonly "text"?: string
    readonly "audio"?: string
    readonly "transcript"?: string
  }
}
export const RealtimeServerEventResponseContentPartAdded = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.content_part.added").annotate({
    "description": "The event type, must be `response.content_part.added`."
  }),
  "response_id": Schema.String.annotate({ "description": "The ID of the response." }),
  "item_id": Schema.String.annotate({ "description": "The ID of the item to which the content part was added." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(
    Schema.isInt()
  ),
  "content_index": Schema.Number.annotate({
    "description": "The index of the content part in the item's content array."
  }).check(Schema.isInt()),
  "part": Schema.Struct({
    "type": Schema.optionalKey(
      Schema.Literals(["audio", "text"]).annotate({ "description": "The content type (\"text\", \"audio\")." })
    ),
    "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content (if type is \"text\")." })),
    "audio": Schema.optionalKey(
      Schema.String.annotate({ "description": "Base64-encoded audio data (if type is \"audio\")." })
    ),
    "transcript": Schema.optionalKey(
      Schema.String.annotate({ "description": "The transcript of the audio (if type is \"audio\")." })
    )
  }).annotate({ "description": "The content part that was added." })
}).annotate({
  "description": "Returned when a new content part is added to an assistant message item during\nresponse generation.\n"
})
export type RealtimeServerEventResponseContentPartDone = {
  readonly "event_id": string
  readonly "type": "response.content_part.done"
  readonly "response_id": string
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
  readonly "part": {
    readonly "type"?: "audio" | "text"
    readonly "text"?: string
    readonly "audio"?: string
    readonly "transcript"?: string
  }
}
export const RealtimeServerEventResponseContentPartDone = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.content_part.done").annotate({
    "description": "The event type, must be `response.content_part.done`."
  }),
  "response_id": Schema.String.annotate({ "description": "The ID of the response." }),
  "item_id": Schema.String.annotate({ "description": "The ID of the item." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(
    Schema.isInt()
  ),
  "content_index": Schema.Number.annotate({
    "description": "The index of the content part in the item's content array."
  }).check(Schema.isInt()),
  "part": Schema.Struct({
    "type": Schema.optionalKey(
      Schema.Literals(["audio", "text"]).annotate({ "description": "The content type (\"text\", \"audio\")." })
    ),
    "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content (if type is \"text\")." })),
    "audio": Schema.optionalKey(
      Schema.String.annotate({ "description": "Base64-encoded audio data (if type is \"audio\")." })
    ),
    "transcript": Schema.optionalKey(
      Schema.String.annotate({ "description": "The transcript of the audio (if type is \"audio\")." })
    )
  }).annotate({ "description": "The content part that is done." })
}).annotate({
  "description":
    "Returned when a content part is done streaming in an assistant message item.\nAlso emitted when a Response is interrupted, incomplete, or cancelled.\n"
})
export type RealtimeServerEventResponseFunctionCallArgumentsDelta = {
  readonly "event_id": string
  readonly "type": "response.function_call_arguments.delta"
  readonly "response_id": string
  readonly "item_id": string
  readonly "output_index": number
  readonly "call_id": string
  readonly "delta": string
}
export const RealtimeServerEventResponseFunctionCallArgumentsDelta = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.function_call_arguments.delta").annotate({
    "description": "The event type, must be `response.function_call_arguments.delta`.\n"
  }),
  "response_id": Schema.String.annotate({ "description": "The ID of the response." }),
  "item_id": Schema.String.annotate({ "description": "The ID of the function call item." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(
    Schema.isInt()
  ),
  "call_id": Schema.String.annotate({ "description": "The ID of the function call." }),
  "delta": Schema.String.annotate({ "description": "The arguments delta as a JSON string." })
}).annotate({ "description": "Returned when the model-generated function call arguments are updated.\n" })
export type RealtimeServerEventResponseFunctionCallArgumentsDone = {
  readonly "event_id": string
  readonly "type": "response.function_call_arguments.done"
  readonly "response_id": string
  readonly "item_id": string
  readonly "output_index": number
  readonly "call_id": string
  readonly "name": string
  readonly "arguments": string
}
export const RealtimeServerEventResponseFunctionCallArgumentsDone = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.function_call_arguments.done").annotate({
    "description": "The event type, must be `response.function_call_arguments.done`.\n"
  }),
  "response_id": Schema.String.annotate({ "description": "The ID of the response." }),
  "item_id": Schema.String.annotate({ "description": "The ID of the function call item." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(
    Schema.isInt()
  ),
  "call_id": Schema.String.annotate({ "description": "The ID of the function call." }),
  "name": Schema.String.annotate({ "description": "The name of the function that was called." }),
  "arguments": Schema.String.annotate({ "description": "The final arguments as a JSON string." })
}).annotate({
  "description":
    "Returned when the model-generated function call arguments are done streaming.\nAlso emitted when a Response is interrupted, incomplete, or cancelled.\n"
})
export type RealtimeServerEventResponseMCPCallArgumentsDelta = {
  readonly "event_id": string
  readonly "type": "response.mcp_call_arguments.delta"
  readonly "response_id": string
  readonly "item_id": string
  readonly "output_index": number
  readonly "delta": string
  readonly "obfuscation"?: string | null
}
export const RealtimeServerEventResponseMCPCallArgumentsDelta = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.mcp_call_arguments.delta").annotate({
    "description": "The event type, must be `response.mcp_call_arguments.delta`."
  }),
  "response_id": Schema.String.annotate({ "description": "The ID of the response." }),
  "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(
    Schema.isInt()
  ),
  "delta": Schema.String.annotate({ "description": "The JSON-encoded arguments delta." }),
  "obfuscation": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "If present, indicates the delta text was obfuscated." }),
      Schema.Null
    ])
  )
}).annotate({ "description": "Returned when MCP tool call arguments are updated during response generation." })
export type RealtimeServerEventResponseMCPCallArgumentsDone = {
  readonly "event_id": string
  readonly "type": "response.mcp_call_arguments.done"
  readonly "response_id": string
  readonly "item_id": string
  readonly "output_index": number
  readonly "arguments": string
}
export const RealtimeServerEventResponseMCPCallArgumentsDone = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.mcp_call_arguments.done").annotate({
    "description": "The event type, must be `response.mcp_call_arguments.done`."
  }),
  "response_id": Schema.String.annotate({ "description": "The ID of the response." }),
  "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(
    Schema.isInt()
  ),
  "arguments": Schema.String.annotate({ "description": "The final JSON-encoded arguments string." })
}).annotate({ "description": "Returned when MCP tool call arguments are finalized during response generation." })
export type RealtimeServerEventResponseMCPCallCompleted = {
  readonly "event_id": string
  readonly "type": "response.mcp_call.completed"
  readonly "output_index": number
  readonly "item_id": string
}
export const RealtimeServerEventResponseMCPCallCompleted = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.mcp_call.completed").annotate({
    "description": "The event type, must be `response.mcp_call.completed`."
  }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(
    Schema.isInt()
  ),
  "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item." })
}).annotate({ "description": "Returned when an MCP tool call has completed successfully." })
export type RealtimeServerEventResponseMCPCallFailed = {
  readonly "event_id": string
  readonly "type": "response.mcp_call.failed"
  readonly "output_index": number
  readonly "item_id": string
}
export const RealtimeServerEventResponseMCPCallFailed = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.mcp_call.failed").annotate({
    "description": "The event type, must be `response.mcp_call.failed`."
  }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(
    Schema.isInt()
  ),
  "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item." })
}).annotate({ "description": "Returned when an MCP tool call has failed." })
export type RealtimeServerEventResponseMCPCallInProgress = {
  readonly "event_id": string
  readonly "type": "response.mcp_call.in_progress"
  readonly "output_index": number
  readonly "item_id": string
}
export const RealtimeServerEventResponseMCPCallInProgress = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.mcp_call.in_progress").annotate({
    "description": "The event type, must be `response.mcp_call.in_progress`."
  }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(
    Schema.isInt()
  ),
  "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item." })
}).annotate({ "description": "Returned when an MCP tool call has started and is in progress." })
export type RealtimeServerEventResponseTextDelta = {
  readonly "event_id": string
  readonly "type": "response.output_text.delta"
  readonly "response_id": string
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
  readonly "delta": string
}
export const RealtimeServerEventResponseTextDelta = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.output_text.delta").annotate({
    "description": "The event type, must be `response.output_text.delta`."
  }),
  "response_id": Schema.String.annotate({ "description": "The ID of the response." }),
  "item_id": Schema.String.annotate({ "description": "The ID of the item." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(
    Schema.isInt()
  ),
  "content_index": Schema.Number.annotate({
    "description": "The index of the content part in the item's content array."
  }).check(Schema.isInt()),
  "delta": Schema.String.annotate({ "description": "The text delta." })
}).annotate({ "description": "Returned when the text value of an \"output_text\" content part is updated." })
export type RealtimeServerEventResponseTextDone = {
  readonly "event_id": string
  readonly "type": "response.output_text.done"
  readonly "response_id": string
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
  readonly "text": string
}
export const RealtimeServerEventResponseTextDone = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.output_text.done").annotate({
    "description": "The event type, must be `response.output_text.done`."
  }),
  "response_id": Schema.String.annotate({ "description": "The ID of the response." }),
  "item_id": Schema.String.annotate({ "description": "The ID of the item." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(
    Schema.isInt()
  ),
  "content_index": Schema.Number.annotate({
    "description": "The index of the content part in the item's content array."
  }).check(Schema.isInt()),
  "text": Schema.String.annotate({ "description": "The final text content." })
}).annotate({
  "description":
    "Returned when the text value of an \"output_text\" content part is done streaming. Also\nemitted when a Response is interrupted, incomplete, or cancelled.\n"
})
export type RealtimeTranscriptionSessionCreateResponse = {
  readonly "client_secret": { readonly "value": string; readonly "expires_at": number }
  readonly "modalities"?: ReadonlyArray<"text" | "audio">
  readonly "input_audio_format"?: string
  readonly "input_audio_transcription"?: {
    readonly "model"?:
      | string
      | "whisper-1"
      | "gpt-4o-mini-transcribe"
      | "gpt-4o-mini-transcribe-2025-12-15"
      | "gpt-4o-transcribe"
      | "gpt-4o-transcribe-diarize"
    readonly "language"?: string
    readonly "prompt"?: string
  }
  readonly "turn_detection"?: {
    readonly "type"?: string
    readonly "threshold"?: number
    readonly "prefix_padding_ms"?: number
    readonly "silence_duration_ms"?: number
  }
}
export const RealtimeTranscriptionSessionCreateResponse = Schema.Struct({
  "client_secret": Schema.Struct({
    "value": Schema.String.annotate({
      "description":
        "Ephemeral key usable in client environments to authenticate connections\nto the Realtime API. Use this in client-side environments rather than\na standard API token, which should only be used server-side.\n"
    }),
    "expires_at": Schema.Number.annotate({
      "description": "Timestamp for when the token expires. Currently, all tokens expire\nafter one minute.\n"
    }).check(Schema.isInt())
  }).annotate({
    "description":
      "Ephemeral key returned by the API. Only present when the session is\ncreated on the server via REST API.\n"
  }),
  "modalities": Schema.optionalKey(
    Schema.Array(Schema.Literals(["text", "audio"])).annotate({
      "description": "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"
    })
  ),
  "input_audio_format": Schema.optionalKey(
    Schema.String.annotate({
      "description": "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"
    })
  ),
  "input_audio_transcription": Schema.optionalKey(
    Schema.Struct({
      "model": Schema.optionalKey(
        Schema.Union([
          Schema.String,
          Schema.Literals([
            "whisper-1",
            "gpt-4o-mini-transcribe",
            "gpt-4o-mini-transcribe-2025-12-15",
            "gpt-4o-transcribe",
            "gpt-4o-transcribe-diarize"
          ])
        ]).annotate({
          "description":
            "The model to use for transcription. Current options are `whisper-1`, `gpt-4o-mini-transcribe`, `gpt-4o-mini-transcribe-2025-12-15`, `gpt-4o-transcribe`, and `gpt-4o-transcribe-diarize`. Use `gpt-4o-transcribe-diarize` when you need diarization with speaker labels.\n"
        })
      ),
      "language": Schema.optionalKey(
        Schema.String.annotate({
          "description":
            "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"
        })
      ),
      "prompt": Schema.optionalKey(Schema.String.annotate({
        "description":
          "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models (excluding `gpt-4o-transcribe-diarize`), the prompt is a free text string, for example \"expect words related to technology\".\n"
      }))
    }).annotate({ "description": "Configuration of the transcription model.\n" })
  ),
  "turn_detection": Schema.optionalKey(
    Schema.Struct({
      "type": Schema.optionalKey(
        Schema.String.annotate({ "description": "Type of turn detection, only `server_vad` is currently supported.\n" })
      ),
      "threshold": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\nhigher threshold will require louder audio to activate the model, and\nthus might perform better in noisy environments.\n"
        }).check(Schema.isFinite())
      ),
      "prefix_padding_ms": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "Amount of audio to include before the VAD detected speech (in\nmilliseconds). Defaults to 300ms.\n"
        }).check(Schema.isInt())
      ),
      "silence_duration_ms": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "Duration of silence to detect speech stop (in milliseconds). Defaults\nto 500ms. With shorter values the model will respond more quickly,\nbut may jump in on short pauses from the user.\n"
        }).check(Schema.isInt())
      )
    }).annotate({
      "description":
        "Configuration for turn detection. Can be set to `null` to turn off. Server\nVAD means that the model will detect the start and end of speech based on\naudio volume and respond at the end of user speech.\n"
    })
  )
}).annotate({
  "description":
    "A new Realtime transcription session configuration.\n\nWhen a session is created on the server via REST API, the session object\nalso contains an ephemeral key. Default TTL for keys is 10 minutes. This\nproperty is not present when a session is updated via the WebSocket API.\n"
})
export type RealtimeTruncation = "auto" | "disabled" | {
  readonly "type": "retention_ratio"
  readonly "retention_ratio": number
  readonly "token_limits"?: { readonly "post_instructions"?: number }
}
export const RealtimeTruncation = Schema.Union([
  Schema.Literals(["auto", "disabled"]).annotate({
    "description":
      "The truncation strategy to use for the session. `auto` is the default truncation strategy. `disabled` will disable truncation and emit errors when the conversation exceeds the input token limit."
  }),
  Schema.Struct({
    "type": Schema.Literal("retention_ratio").annotate({ "description": "Use retention ratio truncation." }),
    "retention_ratio": Schema.Number.annotate({
      "description":
        "Fraction of post-instruction conversation tokens to retain (`0.0` - `1.0`) when the conversation exceeds the input token limit. Setting this to `0.8` means that messages will be dropped until 80% of the maximum allowed tokens are used. This helps reduce the frequency of truncations and improve cache rates.\n"
    }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1)),
    "token_limits": Schema.optionalKey(
      Schema.Struct({
        "post_instructions": Schema.optionalKey(
          Schema.Number.annotate({
            "description":
              "Maximum tokens allowed in the conversation after instructions (which including tool definitions). For example, setting this to 5,000 would mean that truncation would occur when the conversation exceeds 5,000 tokens after instructions. This cannot be higher than the model's context window size minus the maximum output tokens."
          }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0))
        )
      }).annotate({
        "description":
          "Optional custom token limits for this truncation strategy. If not provided, the model's default token limits will be used."
      })
    )
  }).annotate({
    "title": "Retention ratio truncation",
    "description":
      "Retain a fraction of the conversation tokens when the conversation exceeds the input token limit. This allows you to amortize truncations across multiple turns, which can help improve cached token usage."
  })
], { mode: "oneOf" }).annotate({
  "title": "Realtime Truncation Controls",
  "description":
    "When the number of tokens in a conversation exceeds the model's input token limit, the conversation be truncated, meaning messages (starting from the oldest) will not be included in the model's context. A 32k context model with 4,096 max output tokens can only include 28,224 tokens in the context before truncation occurs.\n\nClients can configure truncation behavior to truncate with a lower max token limit, which is an effective way to control token usage and cost.\n\nTruncation will reduce the number of cached tokens on the next turn (busting the cache), since messages are dropped from the beginning of the context. However, clients can also configure truncation to retain messages up to a fraction of the maximum context size, which will reduce the need for future truncations and thus improve the cache rate.\n\nTruncation can be disabled entirely, which means the server will never truncate but would instead return an error if the conversation exceeds the model's input token limit.\n"
})
export type RealtimeTurnDetection = {
  readonly "type": "server_vad"
  readonly "threshold"?: number
  readonly "prefix_padding_ms"?: number
  readonly "silence_duration_ms"?: number
  readonly "create_response"?: boolean
  readonly "interrupt_response"?: boolean
  readonly "idle_timeout_ms"?: number | null
} | {
  readonly "type": "semantic_vad"
  readonly "eagerness"?: "low" | "medium" | "high" | "auto"
  readonly "create_response"?: boolean
  readonly "interrupt_response"?: boolean
} | null
export const RealtimeTurnDetection = Schema.Union([
  Schema.Union([
    Schema.Struct({
      "type": Schema.Literal("server_vad").annotate({
        "description": "Type of turn detection, `server_vad` to turn on simple Server VAD.\n"
      }),
      "threshold": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "Used only for `server_vad` mode. Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\nhigher threshold will require louder audio to activate the model, and\nthus might perform better in noisy environments.\n"
        }).check(Schema.isFinite())
      ),
      "prefix_padding_ms": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "Used only for `server_vad` mode. Amount of audio to include before the VAD detected speech (in\nmilliseconds). Defaults to 300ms.\n"
        }).check(Schema.isInt())
      ),
      "silence_duration_ms": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "Used only for `server_vad` mode. Duration of silence to detect speech stop (in milliseconds). Defaults\nto 500ms. With shorter values the model will respond more quickly,\nbut may jump in on short pauses from the user.\n"
        }).check(Schema.isInt())
      ),
      "create_response": Schema.optionalKey(Schema.Boolean.annotate({
        "description":
          "Whether or not to automatically generate a response when a VAD stop event occurs. If `interrupt_response` is set to `false` this may fail to create a response if the model is already responding.\n\nIf both `create_response` and `interrupt_response` are set to `false`, the model will never respond automatically but VAD events will still be emitted.\n"
      })),
      "interrupt_response": Schema.optionalKey(Schema.Boolean.annotate({
        "description":
          "Whether or not to automatically interrupt (cancel) any ongoing response with output to the default\nconversation (i.e. `conversation` of `auto`) when a VAD start event occurs. If `true` then the response will be cancelled, otherwise it will continue until complete.\n\nIf both `create_response` and `interrupt_response` are set to `false`, the model will never respond automatically but VAD events will still be emitted.\n"
      })),
      "idle_timeout_ms": Schema.optionalKey(Schema.Union([
        Schema.Number.annotate({
          "description":
            "Optional timeout after which a model response will be triggered automatically. This is\nuseful for situations in which a long pause from the user is unexpected, such as a phone\ncall. The model will effectively prompt the user to continue the conversation based\non the current context.\n\nThe timeout value will be applied after the last model response's audio has finished playing,\ni.e. it's set to the `response.done` time plus audio playback duration.\n\nAn `input_audio_buffer.timeout_triggered` event (plus events\nassociated with the Response) will be emitted when the timeout is reached.\nIdle timeout is currently only supported for `server_vad` mode.\n"
        }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(5000)).check(Schema.isLessThanOrEqualTo(30000)),
        Schema.Null
      ]))
    }).annotate({
      "title": "Server VAD",
      "description":
        "Server-side voice activity detection (VAD) which flips on when user speech is detected and off after a period of silence."
    }),
    Schema.Struct({
      "type": Schema.Literal("semantic_vad").annotate({
        "description": "Type of turn detection, `semantic_vad` to turn on Semantic VAD.\n"
      }),
      "eagerness": Schema.optionalKey(
        Schema.Literals(["low", "medium", "high", "auto"]).annotate({
          "description":
            "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`. `low`, `medium`, and `high` have max timeouts of 8s, 4s, and 2s respectively.\n"
        })
      ),
      "create_response": Schema.optionalKey(
        Schema.Boolean.annotate({
          "description": "Whether or not to automatically generate a response when a VAD stop event occurs.\n"
        })
      ),
      "interrupt_response": Schema.optionalKey(
        Schema.Boolean.annotate({
          "description":
            "Whether or not to automatically interrupt any ongoing response with output to the default\nconversation (i.e. `conversation` of `auto`) when a VAD start event occurs.\n"
        })
      )
    }).annotate({
      "title": "Semantic VAD",
      "description":
        "Server-side semantic turn detection which uses a model to determine when the user has finished speaking."
    })
  ], { mode: "oneOf" }).annotate({
    "title": "Realtime Turn Detection",
    "description":
      "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\n\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\n\nSemantic VAD is more advanced and uses a turn detection model (in conjunction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"
  }),
  Schema.Null
])
export type ReasoningEffort = "none" | "minimal" | "low" | "medium" | "high" | "xhigh" | null
export const ReasoningEffort = Schema.Union([
  Schema.Literals(["none", "minimal", "low", "medium", "high", "xhigh"]).annotate({
    "description":
      "Constrains effort on reasoning for\n[reasoning models](https://platform.openai.com/docs/guides/reasoning).\nCurrently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing\nreasoning effort can result in faster responses and fewer tokens used\non reasoning in a response.\n\n- `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.\n- All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.\n- The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.\n- `xhigh` is supported for all models after `gpt-5.1-codex-max`.\n"
  }),
  Schema.Null
])
export type ResponseAudioDeltaEvent = {
  readonly "type": "response.audio.delta"
  readonly "sequence_number": number
  readonly "delta": string
}
export const ResponseAudioDeltaEvent = Schema.Struct({
  "type": Schema.Literal("response.audio.delta").annotate({
    "description": "The type of the event. Always `response.audio.delta`.\n"
  }),
  "sequence_number": Schema.Number.annotate({
    "description": "A sequence number for this chunk of the stream response.\n"
  }).check(Schema.isInt()),
  "delta": Schema.String.annotate({ "description": "A chunk of Base64 encoded response audio bytes.\n" })
}).annotate({ "description": "Emitted when there is a partial audio response." })
export type ResponseAudioDoneEvent = {
  readonly "type": "response.audio.done"
  readonly "sequence_number": number
  readonly "response_id": unknown
}
export const ResponseAudioDoneEvent = Schema.Struct({
  "type": Schema.Literal("response.audio.done").annotate({
    "description": "The type of the event. Always `response.audio.done`.\n"
  }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of the delta.\n" }).check(
    Schema.isInt()
  ),
  "response_id": Schema.Unknown
}).annotate({ "description": "Emitted when the audio response is complete." })
export type ResponseAudioTranscriptDeltaEvent = {
  readonly "type": "response.audio.transcript.delta"
  readonly "delta": string
  readonly "sequence_number": number
  readonly "response_id": unknown
}
export const ResponseAudioTranscriptDeltaEvent = Schema.Struct({
  "type": Schema.Literal("response.audio.transcript.delta").annotate({
    "description": "The type of the event. Always `response.audio.transcript.delta`.\n"
  }),
  "delta": Schema.String.annotate({ "description": "The partial transcript of the audio response.\n" }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  ),
  "response_id": Schema.Unknown
}).annotate({ "description": "Emitted when there is a partial transcript of audio." })
export type ResponseAudioTranscriptDoneEvent = {
  readonly "type": "response.audio.transcript.done"
  readonly "sequence_number": number
  readonly "response_id": unknown
}
export const ResponseAudioTranscriptDoneEvent = Schema.Struct({
  "type": Schema.Literal("response.audio.transcript.done").annotate({
    "description": "The type of the event. Always `response.audio.transcript.done`.\n"
  }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  ),
  "response_id": Schema.Unknown
}).annotate({ "description": "Emitted when the full audio transcript is completed." })
export type ResponseCodeInterpreterCallCodeDeltaEvent = {
  readonly "type": "response.code_interpreter_call_code.delta"
  readonly "output_index": number
  readonly "item_id": string
  readonly "delta": string
  readonly "sequence_number": number
}
export const ResponseCodeInterpreterCallCodeDeltaEvent = Schema.Struct({
  "type": Schema.Literal("response.code_interpreter_call_code.delta").annotate({
    "description": "The type of the event. Always `response.code_interpreter_call_code.delta`."
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item in the response for which the code is being streamed."
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({ "description": "The unique identifier of the code interpreter tool call item." }),
  "delta": Schema.String.annotate({
    "description": "The partial code snippet being streamed by the code interpreter."
  }),
  "sequence_number": Schema.Number.annotate({
    "description": "The sequence number of this event, used to order streaming events."
  }).check(Schema.isInt())
}).annotate({ "description": "Emitted when a partial code snippet is streamed by the code interpreter." })
export type ResponseCodeInterpreterCallCodeDoneEvent = {
  readonly "type": "response.code_interpreter_call_code.done"
  readonly "output_index": number
  readonly "item_id": string
  readonly "code": string
  readonly "sequence_number": number
}
export const ResponseCodeInterpreterCallCodeDoneEvent = Schema.Struct({
  "type": Schema.Literal("response.code_interpreter_call_code.done").annotate({
    "description": "The type of the event. Always `response.code_interpreter_call_code.done`."
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item in the response for which the code is finalized."
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({ "description": "The unique identifier of the code interpreter tool call item." }),
  "code": Schema.String.annotate({ "description": "The final code snippet output by the code interpreter." }),
  "sequence_number": Schema.Number.annotate({
    "description": "The sequence number of this event, used to order streaming events."
  }).check(Schema.isInt())
}).annotate({ "description": "Emitted when the code snippet is finalized by the code interpreter." })
export type ResponseCodeInterpreterCallCompletedEvent = {
  readonly "type": "response.code_interpreter_call.completed"
  readonly "output_index": number
  readonly "item_id": string
  readonly "sequence_number": number
}
export const ResponseCodeInterpreterCallCompletedEvent = Schema.Struct({
  "type": Schema.Literal("response.code_interpreter_call.completed").annotate({
    "description": "The type of the event. Always `response.code_interpreter_call.completed`."
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item in the response for which the code interpreter call is completed."
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({ "description": "The unique identifier of the code interpreter tool call item." }),
  "sequence_number": Schema.Number.annotate({
    "description": "The sequence number of this event, used to order streaming events."
  }).check(Schema.isInt())
}).annotate({ "description": "Emitted when the code interpreter call is completed." })
export type ResponseCodeInterpreterCallInProgressEvent = {
  readonly "type": "response.code_interpreter_call.in_progress"
  readonly "output_index": number
  readonly "item_id": string
  readonly "sequence_number": number
}
export const ResponseCodeInterpreterCallInProgressEvent = Schema.Struct({
  "type": Schema.Literal("response.code_interpreter_call.in_progress").annotate({
    "description": "The type of the event. Always `response.code_interpreter_call.in_progress`."
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item in the response for which the code interpreter call is in progress."
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({ "description": "The unique identifier of the code interpreter tool call item." }),
  "sequence_number": Schema.Number.annotate({
    "description": "The sequence number of this event, used to order streaming events."
  }).check(Schema.isInt())
}).annotate({ "description": "Emitted when a code interpreter call is in progress." })
export type ResponseCodeInterpreterCallInterpretingEvent = {
  readonly "type": "response.code_interpreter_call.interpreting"
  readonly "output_index": number
  readonly "item_id": string
  readonly "sequence_number": number
}
export const ResponseCodeInterpreterCallInterpretingEvent = Schema.Struct({
  "type": Schema.Literal("response.code_interpreter_call.interpreting").annotate({
    "description": "The type of the event. Always `response.code_interpreter_call.interpreting`."
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item in the response for which the code interpreter is interpreting code."
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({ "description": "The unique identifier of the code interpreter tool call item." }),
  "sequence_number": Schema.Number.annotate({
    "description": "The sequence number of this event, used to order streaming events."
  }).check(Schema.isInt())
}).annotate({ "description": "Emitted when the code interpreter is actively interpreting the code snippet." })
export type ResponseCustomToolCallInputDeltaEvent = {
  readonly "type": "response.custom_tool_call_input.delta"
  readonly "sequence_number": number
  readonly "output_index": number
  readonly "item_id": string
  readonly "delta": string
}
export const ResponseCustomToolCallInputDeltaEvent = Schema.Struct({
  "type": Schema.Literal("response.custom_tool_call_input.delta").annotate({
    "description": "The event type identifier."
  }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  ),
  "output_index": Schema.Number.annotate({ "description": "The index of the output this delta applies to." }).check(
    Schema.isInt()
  ),
  "item_id": Schema.String.annotate({
    "description": "Unique identifier for the API item associated with this event."
  }),
  "delta": Schema.String.annotate({ "description": "The incremental input data (delta) for the custom tool call." })
}).annotate({
  "title": "ResponseCustomToolCallInputDelta",
  "description": "Event representing a delta (partial update) to the input of a custom tool call.\n"
})
export type ResponseCustomToolCallInputDoneEvent = {
  readonly "type": "response.custom_tool_call_input.done"
  readonly "sequence_number": number
  readonly "output_index": number
  readonly "item_id": string
  readonly "input": string
}
export const ResponseCustomToolCallInputDoneEvent = Schema.Struct({
  "type": Schema.Literal("response.custom_tool_call_input.done").annotate({
    "description": "The event type identifier."
  }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  ),
  "output_index": Schema.Number.annotate({ "description": "The index of the output this event applies to." }).check(
    Schema.isInt()
  ),
  "item_id": Schema.String.annotate({
    "description": "Unique identifier for the API item associated with this event."
  }),
  "input": Schema.String.annotate({ "description": "The complete input data for the custom tool call." })
}).annotate({
  "title": "ResponseCustomToolCallInputDone",
  "description": "Event indicating that input for a custom tool call is complete.\n"
})
export type ResponseErrorCode =
  | "server_error"
  | "rate_limit_exceeded"
  | "invalid_prompt"
  | "vector_store_timeout"
  | "invalid_image"
  | "invalid_image_format"
  | "invalid_base64_image"
  | "invalid_image_url"
  | "image_too_large"
  | "image_too_small"
  | "image_parse_error"
  | "image_content_policy_violation"
  | "invalid_image_mode"
  | "image_file_too_large"
  | "unsupported_image_media_type"
  | "empty_image_file"
  | "failed_to_download_image"
  | "image_file_not_found"
export const ResponseErrorCode = Schema.Literals([
  "server_error",
  "rate_limit_exceeded",
  "invalid_prompt",
  "vector_store_timeout",
  "invalid_image",
  "invalid_image_format",
  "invalid_base64_image",
  "invalid_image_url",
  "image_too_large",
  "image_too_small",
  "image_parse_error",
  "image_content_policy_violation",
  "invalid_image_mode",
  "image_file_too_large",
  "unsupported_image_media_type",
  "empty_image_file",
  "failed_to_download_image",
  "image_file_not_found"
]).annotate({ "description": "The error code for the response.\n" })
export type ResponseErrorEvent = {
  readonly "type": "error"
  readonly "code": string | null
  readonly "message": string
  readonly "param": string | null
  readonly "sequence_number": number
}
export const ResponseErrorEvent = Schema.Struct({
  "type": Schema.Literal("error").annotate({ "description": "The type of the event. Always `error`.\n" }),
  "code": Schema.Union([Schema.String.annotate({ "description": "The error code.\n" }), Schema.Null]),
  "message": Schema.String.annotate({ "description": "The error message.\n" }),
  "param": Schema.Union([Schema.String.annotate({ "description": "The error parameter.\n" }), Schema.Null]),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  )
}).annotate({ "description": "Emitted when an error occurs." })
export type ResponseFileSearchCallCompletedEvent = {
  readonly "type": "response.file_search_call.completed"
  readonly "output_index": number
  readonly "item_id": string
  readonly "sequence_number": number
}
export const ResponseFileSearchCallCompletedEvent = Schema.Struct({
  "type": Schema.Literal("response.file_search_call.completed").annotate({
    "description": "The type of the event. Always `response.file_search_call.completed`.\n"
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item that the file search call is initiated.\n"
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({
    "description": "The ID of the output item that the file search call is initiated.\n"
  }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  )
}).annotate({ "description": "Emitted when a file search call is completed (results found)." })
export type ResponseFileSearchCallInProgressEvent = {
  readonly "type": "response.file_search_call.in_progress"
  readonly "output_index": number
  readonly "item_id": string
  readonly "sequence_number": number
}
export const ResponseFileSearchCallInProgressEvent = Schema.Struct({
  "type": Schema.Literal("response.file_search_call.in_progress").annotate({
    "description": "The type of the event. Always `response.file_search_call.in_progress`.\n"
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item that the file search call is initiated.\n"
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({
    "description": "The ID of the output item that the file search call is initiated.\n"
  }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  )
}).annotate({ "description": "Emitted when a file search call is initiated." })
export type ResponseFileSearchCallSearchingEvent = {
  readonly "type": "response.file_search_call.searching"
  readonly "output_index": number
  readonly "item_id": string
  readonly "sequence_number": number
}
export const ResponseFileSearchCallSearchingEvent = Schema.Struct({
  "type": Schema.Literal("response.file_search_call.searching").annotate({
    "description": "The type of the event. Always `response.file_search_call.searching`.\n"
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item that the file search call is searching.\n"
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({
    "description": "The ID of the output item that the file search call is initiated.\n"
  }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  )
}).annotate({ "description": "Emitted when a file search is currently searching." })
export type ResponseFormatJsonObject = { readonly "type": "json_object" }
export const ResponseFormatJsonObject = Schema.Struct({
  "type": Schema.Literal("json_object").annotate({
    "description": "The type of response format being defined. Always `json_object`."
  })
}).annotate({
  "title": "JSON object",
  "description":
    "JSON object response format. An older method of generating JSON responses.\nUsing `json_schema` is recommended for models that support it. Note that the\nmodel will not generate JSON without a system or user message instructing it\nto do so.\n"
})
export type ResponseFormatJsonSchemaSchema = {}
export const ResponseFormatJsonSchemaSchema = Schema.Struct({}).annotate({
  "title": "JSON schema",
  "description":
    "The schema for the response format, described as a JSON Schema object.\nLearn how to build JSON schemas [here](https://json-schema.org/).\n"
})
export type ResponseFormatText = { readonly "type": "text" }
export const ResponseFormatText = Schema.Struct({
  "type": Schema.Literal("text").annotate({
    "description": "The type of response format being defined. Always `text`."
  })
}).annotate({ "title": "Text", "description": "Default response format. Used to generate text responses.\n" })
export type ResponseFunctionCallArgumentsDeltaEvent = {
  readonly "type": "response.function_call_arguments.delta"
  readonly "item_id": string
  readonly "output_index": number
  readonly "sequence_number": number
  readonly "delta": string
}
export const ResponseFunctionCallArgumentsDeltaEvent = Schema.Struct({
  "type": Schema.Literal("response.function_call_arguments.delta").annotate({
    "description": "The type of the event. Always `response.function_call_arguments.delta`.\n"
  }),
  "item_id": Schema.String.annotate({
    "description": "The ID of the output item that the function-call arguments delta is added to.\n"
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item that the function-call arguments delta is added to.\n"
  }).check(Schema.isInt()),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  ),
  "delta": Schema.String.annotate({ "description": "The function-call arguments delta that is added.\n" })
}).annotate({ "description": "Emitted when there is a partial function-call arguments delta." })
export type ResponseFunctionCallArgumentsDoneEvent = {
  readonly "type": "response.function_call_arguments.done"
  readonly "item_id": string
  readonly "name"?: string
  readonly "output_index": number
  readonly "sequence_number": number
  readonly "arguments": string
}
export const ResponseFunctionCallArgumentsDoneEvent = Schema.Struct({
  "type": Schema.Literal("response.function_call_arguments.done"),
  "item_id": Schema.String.annotate({ "description": "The ID of the item." }),
  "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the function that was called." })),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item." }).check(Schema.isInt()),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  ),
  "arguments": Schema.String.annotate({ "description": "The function-call arguments." })
}).annotate({ "description": "Emitted when function-call arguments are finalized." })
export type ResponseImageGenCallCompletedEvent = {
  readonly "type": "response.image_generation_call.completed"
  readonly "output_index": number
  readonly "sequence_number": number
  readonly "item_id": string
}
export const ResponseImageGenCallCompletedEvent = Schema.Struct({
  "type": Schema.Literal("response.image_generation_call.completed").annotate({
    "description": "The type of the event. Always 'response.image_generation_call.completed'."
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item in the response's output array."
  }).check(Schema.isInt()),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  ),
  "item_id": Schema.String.annotate({
    "description": "The unique identifier of the image generation item being processed."
  })
}).annotate({
  "title": "ResponseImageGenCallCompletedEvent",
  "description": "Emitted when an image generation tool call has completed and the final image is available.\n"
})
export type ResponseImageGenCallGeneratingEvent = {
  readonly "type": "response.image_generation_call.generating"
  readonly "output_index": number
  readonly "item_id": string
  readonly "sequence_number": number
}
export const ResponseImageGenCallGeneratingEvent = Schema.Struct({
  "type": Schema.Literal("response.image_generation_call.generating").annotate({
    "description": "The type of the event. Always 'response.image_generation_call.generating'."
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item in the response's output array."
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({
    "description": "The unique identifier of the image generation item being processed."
  }),
  "sequence_number": Schema.Number.annotate({
    "description": "The sequence number of the image generation item being processed."
  }).check(Schema.isInt())
}).annotate({
  "title": "ResponseImageGenCallGeneratingEvent",
  "description": "Emitted when an image generation tool call is actively generating an image (intermediate state).\n"
})
export type ResponseImageGenCallInProgressEvent = {
  readonly "type": "response.image_generation_call.in_progress"
  readonly "output_index": number
  readonly "item_id": string
  readonly "sequence_number": number
}
export const ResponseImageGenCallInProgressEvent = Schema.Struct({
  "type": Schema.Literal("response.image_generation_call.in_progress").annotate({
    "description": "The type of the event. Always 'response.image_generation_call.in_progress'."
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item in the response's output array."
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({
    "description": "The unique identifier of the image generation item being processed."
  }),
  "sequence_number": Schema.Number.annotate({
    "description": "The sequence number of the image generation item being processed."
  }).check(Schema.isInt())
}).annotate({
  "title": "ResponseImageGenCallInProgressEvent",
  "description": "Emitted when an image generation tool call is in progress.\n"
})
export type ResponseImageGenCallPartialImageEvent = {
  readonly "type": "response.image_generation_call.partial_image"
  readonly "output_index": number
  readonly "item_id": string
  readonly "sequence_number": number
  readonly "partial_image_index": number
  readonly "partial_image_b64": string
}
export const ResponseImageGenCallPartialImageEvent = Schema.Struct({
  "type": Schema.Literal("response.image_generation_call.partial_image").annotate({
    "description": "The type of the event. Always 'response.image_generation_call.partial_image'."
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item in the response's output array."
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({
    "description": "The unique identifier of the image generation item being processed."
  }),
  "sequence_number": Schema.Number.annotate({
    "description": "The sequence number of the image generation item being processed."
  }).check(Schema.isInt()),
  "partial_image_index": Schema.Number.annotate({
    "description": "0-based index for the partial image (backend is 1-based, but this is 0-based for the user)."
  }).check(Schema.isInt()),
  "partial_image_b64": Schema.String.annotate({
    "description": "Base64-encoded partial image data, suitable for rendering as an image."
  })
}).annotate({
  "title": "ResponseImageGenCallPartialImageEvent",
  "description": "Emitted when a partial image is available during image generation streaming.\n"
})
export type ResponseLogProb = {
  readonly "token": string
  readonly "logprob": number
  readonly "top_logprobs"?: ReadonlyArray<{ readonly "token"?: string; readonly "logprob"?: number }>
}
export const ResponseLogProb = Schema.Struct({
  "token": Schema.String.annotate({ "description": "A possible text token." }),
  "logprob": Schema.Number.annotate({ "description": "The log probability of this token.\n" }).check(Schema.isFinite()),
  "top_logprobs": Schema.optionalKey(
    Schema.Array(
      Schema.Struct({
        "token": Schema.optionalKey(Schema.String.annotate({ "description": "A possible text token." })),
        "logprob": Schema.optionalKey(
          Schema.Number.annotate({ "description": "The log probability of this token." }).check(Schema.isFinite())
        )
      })
    ).annotate({ "description": "The log probability of the top 20 most likely tokens.\n" })
  )
}).annotate({
  "description":
    "A logprob is the logarithmic probability that the model assigns to producing \na particular token at a given position in the sequence. Less-negative (higher) \nlogprob values indicate greater model confidence in that token choice.\n"
})
export type ResponseMCPCallArgumentsDeltaEvent = {
  readonly "type": "response.mcp_call_arguments.delta"
  readonly "output_index": number
  readonly "item_id": string
  readonly "delta": string
  readonly "sequence_number": number
}
export const ResponseMCPCallArgumentsDeltaEvent = Schema.Struct({
  "type": Schema.Literal("response.mcp_call_arguments.delta").annotate({
    "description": "The type of the event. Always 'response.mcp_call_arguments.delta'."
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item in the response's output array."
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({
    "description": "The unique identifier of the MCP tool call item being processed."
  }),
  "delta": Schema.String.annotate({
    "description": "A JSON string containing the partial update to the arguments for the MCP tool call.\n"
  }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  )
}).annotate({
  "title": "ResponseMCPCallArgumentsDeltaEvent",
  "description": "Emitted when there is a delta (partial update) to the arguments of an MCP tool call.\n"
})
export type ResponseMCPCallArgumentsDoneEvent = {
  readonly "type": "response.mcp_call_arguments.done"
  readonly "output_index": number
  readonly "item_id": string
  readonly "arguments": string
  readonly "sequence_number": number
}
export const ResponseMCPCallArgumentsDoneEvent = Schema.Struct({
  "type": Schema.Literal("response.mcp_call_arguments.done").annotate({
    "description": "The type of the event. Always 'response.mcp_call_arguments.done'."
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item in the response's output array."
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({
    "description": "The unique identifier of the MCP tool call item being processed."
  }),
  "arguments": Schema.String.annotate({
    "description": "A JSON string containing the finalized arguments for the MCP tool call.\n"
  }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  )
}).annotate({
  "title": "ResponseMCPCallArgumentsDoneEvent",
  "description": "Emitted when the arguments for an MCP tool call are finalized.\n"
})
export type ResponseMCPCallCompletedEvent = {
  readonly "type": "response.mcp_call.completed"
  readonly "item_id": string
  readonly "output_index": number
  readonly "sequence_number": number
}
export const ResponseMCPCallCompletedEvent = Schema.Struct({
  "type": Schema.Literal("response.mcp_call.completed").annotate({
    "description": "The type of the event. Always 'response.mcp_call.completed'."
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item that completed." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item that completed." }).check(
    Schema.isInt()
  ),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  )
}).annotate({
  "title": "ResponseMCPCallCompletedEvent",
  "description": "Emitted when an MCP  tool call has completed successfully.\n"
})
export type ResponseMCPCallFailedEvent = {
  readonly "type": "response.mcp_call.failed"
  readonly "item_id": string
  readonly "output_index": number
  readonly "sequence_number": number
}
export const ResponseMCPCallFailedEvent = Schema.Struct({
  "type": Schema.Literal("response.mcp_call.failed").annotate({
    "description": "The type of the event. Always 'response.mcp_call.failed'."
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item that failed." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item that failed." }).check(
    Schema.isInt()
  ),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  )
}).annotate({ "title": "ResponseMCPCallFailedEvent", "description": "Emitted when an MCP  tool call has failed.\n" })
export type ResponseMCPCallInProgressEvent = {
  readonly "type": "response.mcp_call.in_progress"
  readonly "sequence_number": number
  readonly "output_index": number
  readonly "item_id": string
}
export const ResponseMCPCallInProgressEvent = Schema.Struct({
  "type": Schema.Literal("response.mcp_call.in_progress").annotate({
    "description": "The type of the event. Always 'response.mcp_call.in_progress'."
  }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  ),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item in the response's output array."
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({
    "description": "The unique identifier of the MCP tool call item being processed."
  })
}).annotate({
  "title": "ResponseMCPCallInProgressEvent",
  "description": "Emitted when an MCP  tool call is in progress.\n"
})
export type ResponseMCPListToolsCompletedEvent = {
  readonly "type": "response.mcp_list_tools.completed"
  readonly "item_id": string
  readonly "output_index": number
  readonly "sequence_number": number
}
export const ResponseMCPListToolsCompletedEvent = Schema.Struct({
  "type": Schema.Literal("response.mcp_list_tools.completed").annotate({
    "description": "The type of the event. Always 'response.mcp_list_tools.completed'."
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item that produced this output." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item that was processed." }).check(
    Schema.isInt()
  ),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  )
}).annotate({
  "title": "ResponseMCPListToolsCompletedEvent",
  "description": "Emitted when the list of available MCP tools has been successfully retrieved.\n"
})
export type ResponseMCPListToolsFailedEvent = {
  readonly "type": "response.mcp_list_tools.failed"
  readonly "item_id": string
  readonly "output_index": number
  readonly "sequence_number": number
}
export const ResponseMCPListToolsFailedEvent = Schema.Struct({
  "type": Schema.Literal("response.mcp_list_tools.failed").annotate({
    "description": "The type of the event. Always 'response.mcp_list_tools.failed'."
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item that failed." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item that failed." }).check(
    Schema.isInt()
  ),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  )
}).annotate({
  "title": "ResponseMCPListToolsFailedEvent",
  "description": "Emitted when the attempt to list available MCP tools has failed.\n"
})
export type ResponseMCPListToolsInProgressEvent = {
  readonly "type": "response.mcp_list_tools.in_progress"
  readonly "item_id": string
  readonly "output_index": number
  readonly "sequence_number": number
}
export const ResponseMCPListToolsInProgressEvent = Schema.Struct({
  "type": Schema.Literal("response.mcp_list_tools.in_progress").annotate({
    "description": "The type of the event. Always 'response.mcp_list_tools.in_progress'."
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item that is being processed." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item that is being processed." })
    .check(Schema.isInt()),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  )
}).annotate({
  "title": "ResponseMCPListToolsInProgressEvent",
  "description": "Emitted when the system is in the process of retrieving the list of available MCP tools.\n"
})
export type ResponseModalities = ReadonlyArray<"text" | "audio"> | null
export const ResponseModalities = Schema.Union([
  Schema.Array(Schema.Literals(["text", "audio"])).annotate({
    "description":
      "Output types that you would like the model to generate.\nMost models are capable of generating text, which is the default:\n\n`[\"text\"]`\n\nThe `gpt-4o-audio-preview` model can also be used to\n[generate audio](/docs/guides/audio). To request that this model generate\nboth text and audio responses, you can use:\n\n`[\"text\", \"audio\"]`\n"
  }),
  Schema.Null
])
export type ResponseOutputTextAnnotationAddedEvent = {
  readonly "type": "response.output_text.annotation.added"
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
  readonly "annotation_index": number
  readonly "sequence_number": number
  readonly "annotation": {}
}
export const ResponseOutputTextAnnotationAddedEvent = Schema.Struct({
  "type": Schema.Literal("response.output_text.annotation.added").annotate({
    "description": "The type of the event. Always 'response.output_text.annotation.added'."
  }),
  "item_id": Schema.String.annotate({
    "description": "The unique identifier of the item to which the annotation is being added."
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item in the response's output array."
  }).check(Schema.isInt()),
  "content_index": Schema.Number.annotate({ "description": "The index of the content part within the output item." })
    .check(Schema.isInt()),
  "annotation_index": Schema.Number.annotate({ "description": "The index of the annotation within the content part." })
    .check(Schema.isInt()),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  ),
  "annotation": Schema.Struct({}).annotate({
    "description": "The annotation object being added. (See annotation schema for details.)"
  })
}).annotate({
  "title": "ResponseOutputTextAnnotationAddedEvent",
  "description": "Emitted when an annotation is added to output text content.\n"
})
export type ResponsePromptVariables = {} | null
export const ResponsePromptVariables = Schema.Union([
  Schema.Struct({}).annotate({
    "title": "Prompt Variables",
    "description":
      "Optional map of values to substitute in for variables in your\nprompt. The substitution values can either be strings, or other\nResponse input types like images or files.\n"
  }),
  Schema.Null
])
export type ResponseReasoningSummaryPartAddedEvent = {
  readonly "type": "response.reasoning_summary_part.added"
  readonly "item_id": string
  readonly "output_index": number
  readonly "summary_index": number
  readonly "sequence_number": number
  readonly "part": { readonly "type": "summary_text"; readonly "text": string }
}
export const ResponseReasoningSummaryPartAddedEvent = Schema.Struct({
  "type": Schema.Literal("response.reasoning_summary_part.added").annotate({
    "description": "The type of the event. Always `response.reasoning_summary_part.added`.\n"
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the item this summary part is associated with.\n" }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item this summary part is associated with.\n"
  }).check(Schema.isInt()),
  "summary_index": Schema.Number.annotate({
    "description": "The index of the summary part within the reasoning summary.\n"
  }).check(Schema.isInt()),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\n" }).check(
    Schema.isInt()
  ),
  "part": Schema.Struct({
    "type": Schema.Literal("summary_text").annotate({
      "description": "The type of the summary part. Always `summary_text`."
    }),
    "text": Schema.String.annotate({ "description": "The text of the summary part." })
  }).annotate({ "description": "The summary part that was added.\n" })
}).annotate({ "description": "Emitted when a new reasoning summary part is added." })
export type ResponseReasoningSummaryPartDoneEvent = {
  readonly "type": "response.reasoning_summary_part.done"
  readonly "item_id": string
  readonly "output_index": number
  readonly "summary_index": number
  readonly "sequence_number": number
  readonly "part": { readonly "type": "summary_text"; readonly "text": string }
}
export const ResponseReasoningSummaryPartDoneEvent = Schema.Struct({
  "type": Schema.Literal("response.reasoning_summary_part.done").annotate({
    "description": "The type of the event. Always `response.reasoning_summary_part.done`.\n"
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the item this summary part is associated with.\n" }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item this summary part is associated with.\n"
  }).check(Schema.isInt()),
  "summary_index": Schema.Number.annotate({
    "description": "The index of the summary part within the reasoning summary.\n"
  }).check(Schema.isInt()),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\n" }).check(
    Schema.isInt()
  ),
  "part": Schema.Struct({
    "type": Schema.Literal("summary_text").annotate({
      "description": "The type of the summary part. Always `summary_text`."
    }),
    "text": Schema.String.annotate({ "description": "The text of the summary part." })
  }).annotate({ "description": "The completed summary part.\n" })
}).annotate({ "description": "Emitted when a reasoning summary part is completed." })
export type ResponseReasoningSummaryTextDeltaEvent = {
  readonly "type": "response.reasoning_summary_text.delta"
  readonly "item_id": string
  readonly "output_index": number
  readonly "summary_index": number
  readonly "delta": string
  readonly "sequence_number": number
}
export const ResponseReasoningSummaryTextDeltaEvent = Schema.Struct({
  "type": Schema.Literal("response.reasoning_summary_text.delta").annotate({
    "description": "The type of the event. Always `response.reasoning_summary_text.delta`.\n"
  }),
  "item_id": Schema.String.annotate({
    "description": "The ID of the item this summary text delta is associated with.\n"
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item this summary text delta is associated with.\n"
  }).check(Schema.isInt()),
  "summary_index": Schema.Number.annotate({
    "description": "The index of the summary part within the reasoning summary.\n"
  }).check(Schema.isInt()),
  "delta": Schema.String.annotate({ "description": "The text delta that was added to the summary.\n" }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\n" }).check(
    Schema.isInt()
  )
}).annotate({ "description": "Emitted when a delta is added to a reasoning summary text." })
export type ResponseReasoningSummaryTextDoneEvent = {
  readonly "type": "response.reasoning_summary_text.done"
  readonly "item_id": string
  readonly "output_index": number
  readonly "summary_index": number
  readonly "text": string
  readonly "sequence_number": number
}
export const ResponseReasoningSummaryTextDoneEvent = Schema.Struct({
  "type": Schema.Literal("response.reasoning_summary_text.done").annotate({
    "description": "The type of the event. Always `response.reasoning_summary_text.done`.\n"
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the item this summary text is associated with.\n" }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item this summary text is associated with.\n"
  }).check(Schema.isInt()),
  "summary_index": Schema.Number.annotate({
    "description": "The index of the summary part within the reasoning summary.\n"
  }).check(Schema.isInt()),
  "text": Schema.String.annotate({ "description": "The full text of the completed reasoning summary.\n" }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\n" }).check(
    Schema.isInt()
  )
}).annotate({ "description": "Emitted when a reasoning summary text is completed." })
export type ResponseReasoningTextDeltaEvent = {
  readonly "type": "response.reasoning_text.delta"
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
  readonly "delta": string
  readonly "sequence_number": number
}
export const ResponseReasoningTextDeltaEvent = Schema.Struct({
  "type": Schema.Literal("response.reasoning_text.delta").annotate({
    "description": "The type of the event. Always `response.reasoning_text.delta`.\n"
  }),
  "item_id": Schema.String.annotate({
    "description": "The ID of the item this reasoning text delta is associated with.\n"
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item this reasoning text delta is associated with.\n"
  }).check(Schema.isInt()),
  "content_index": Schema.Number.annotate({
    "description": "The index of the reasoning content part this delta is associated with.\n"
  }).check(Schema.isInt()),
  "delta": Schema.String.annotate({ "description": "The text delta that was added to the reasoning content.\n" }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\n" }).check(
    Schema.isInt()
  )
}).annotate({ "description": "Emitted when a delta is added to a reasoning text." })
export type ResponseReasoningTextDoneEvent = {
  readonly "type": "response.reasoning_text.done"
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
  readonly "text": string
  readonly "sequence_number": number
}
export const ResponseReasoningTextDoneEvent = Schema.Struct({
  "type": Schema.Literal("response.reasoning_text.done").annotate({
    "description": "The type of the event. Always `response.reasoning_text.done`.\n"
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the item this reasoning text is associated with.\n" }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item this reasoning text is associated with.\n"
  }).check(Schema.isInt()),
  "content_index": Schema.Number.annotate({ "description": "The index of the reasoning content part.\n" }).check(
    Schema.isInt()
  ),
  "text": Schema.String.annotate({ "description": "The full text of the completed reasoning content.\n" }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\n" }).check(
    Schema.isInt()
  )
}).annotate({ "description": "Emitted when a reasoning text is completed." })
export type ResponseRefusalDeltaEvent = {
  readonly "type": "response.refusal.delta"
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
  readonly "delta": string
  readonly "sequence_number": number
}
export const ResponseRefusalDeltaEvent = Schema.Struct({
  "type": Schema.Literal("response.refusal.delta").annotate({
    "description": "The type of the event. Always `response.refusal.delta`.\n"
  }),
  "item_id": Schema.String.annotate({
    "description": "The ID of the output item that the refusal text is added to.\n"
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item that the refusal text is added to.\n"
  }).check(Schema.isInt()),
  "content_index": Schema.Number.annotate({
    "description": "The index of the content part that the refusal text is added to.\n"
  }).check(Schema.isInt()),
  "delta": Schema.String.annotate({ "description": "The refusal text that is added.\n" }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\n" }).check(
    Schema.isInt()
  )
}).annotate({ "description": "Emitted when there is a partial refusal text." })
export type ResponseRefusalDoneEvent = {
  readonly "type": "response.refusal.done"
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
  readonly "refusal": string
  readonly "sequence_number": number
}
export const ResponseRefusalDoneEvent = Schema.Struct({
  "type": Schema.Literal("response.refusal.done").annotate({
    "description": "The type of the event. Always `response.refusal.done`.\n"
  }),
  "item_id": Schema.String.annotate({
    "description": "The ID of the output item that the refusal text is finalized.\n"
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item that the refusal text is finalized.\n"
  }).check(Schema.isInt()),
  "content_index": Schema.Number.annotate({
    "description": "The index of the content part that the refusal text is finalized.\n"
  }).check(Schema.isInt()),
  "refusal": Schema.String.annotate({ "description": "The refusal text that is finalized.\n" }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\n" }).check(
    Schema.isInt()
  )
}).annotate({ "description": "Emitted when refusal text is finalized." })
export type ResponseStreamOptions = { readonly "include_obfuscation"?: boolean } | null
export const ResponseStreamOptions = Schema.Union([
  Schema.Struct({
    "include_obfuscation": Schema.optionalKey(Schema.Boolean.annotate({
      "description":
        "When true, stream obfuscation will be enabled. Stream obfuscation adds\nrandom characters to an `obfuscation` field on streaming delta events to\nnormalize payload sizes as a mitigation to certain side-channel attacks.\nThese obfuscation fields are included by default, but add a small amount\nof overhead to the data stream. You can set `include_obfuscation` to\nfalse to optimize for bandwidth if you trust the network links between\nyour application and the OpenAI API.\n"
    }))
  }).annotate({ "description": "Options for streaming responses. Only set this when you set `stream: true`.\n" }),
  Schema.Null
])
export type ResponseUsage = {
  readonly "input_tokens": number
  readonly "input_tokens_details": { readonly "cached_tokens": number }
  readonly "output_tokens": number
  readonly "output_tokens_details": { readonly "reasoning_tokens": number }
  readonly "total_tokens": number
}
export const ResponseUsage = Schema.Struct({
  "input_tokens": Schema.Number.annotate({ "description": "The number of input tokens." }).check(Schema.isInt()),
  "input_tokens_details": Schema.Struct({
    "cached_tokens": Schema.Number.annotate({
      "description":
        "The number of tokens that were retrieved from the cache. \n[More on prompt caching](/docs/guides/prompt-caching).\n"
    }).check(Schema.isInt())
  }).annotate({ "description": "A detailed breakdown of the input tokens." }),
  "output_tokens": Schema.Number.annotate({ "description": "The number of output tokens." }).check(Schema.isInt()),
  "output_tokens_details": Schema.Struct({
    "reasoning_tokens": Schema.Number.annotate({ "description": "The number of reasoning tokens." }).check(
      Schema.isInt()
    )
  }).annotate({ "description": "A detailed breakdown of the output tokens." }),
  "total_tokens": Schema.Number.annotate({ "description": "The total number of tokens used." }).check(Schema.isInt())
}).annotate({
  "description":
    "Represents token usage details including input tokens, output tokens,\na breakdown of output tokens, and the total tokens used.\n"
})
export type ResponseWebSearchCallCompletedEvent = {
  readonly "type": "response.web_search_call.completed"
  readonly "output_index": number
  readonly "item_id": string
  readonly "sequence_number": number
}
export const ResponseWebSearchCallCompletedEvent = Schema.Struct({
  "type": Schema.Literal("response.web_search_call.completed").annotate({
    "description": "The type of the event. Always `response.web_search_call.completed`.\n"
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item that the web search call is associated with.\n"
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({
    "description": "Unique ID for the output item associated with the web search call.\n"
  }),
  "sequence_number": Schema.Number.annotate({
    "description": "The sequence number of the web search call being processed."
  }).check(Schema.isInt())
}).annotate({ "description": "Emitted when a web search call is completed." })
export type ResponseWebSearchCallInProgressEvent = {
  readonly "type": "response.web_search_call.in_progress"
  readonly "output_index": number
  readonly "item_id": string
  readonly "sequence_number": number
}
export const ResponseWebSearchCallInProgressEvent = Schema.Struct({
  "type": Schema.Literal("response.web_search_call.in_progress").annotate({
    "description": "The type of the event. Always `response.web_search_call.in_progress`.\n"
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item that the web search call is associated with.\n"
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({
    "description": "Unique ID for the output item associated with the web search call.\n"
  }),
  "sequence_number": Schema.Number.annotate({
    "description": "The sequence number of the web search call being processed."
  }).check(Schema.isInt())
}).annotate({ "description": "Emitted when a web search call is initiated." })
export type ResponseWebSearchCallSearchingEvent = {
  readonly "type": "response.web_search_call.searching"
  readonly "output_index": number
  readonly "item_id": string
  readonly "sequence_number": number
}
export const ResponseWebSearchCallSearchingEvent = Schema.Struct({
  "type": Schema.Literal("response.web_search_call.searching").annotate({
    "description": "The type of the event. Always `response.web_search_call.searching`.\n"
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item that the web search call is associated with.\n"
  }).check(Schema.isInt()),
  "item_id": Schema.String.annotate({
    "description": "Unique ID for the output item associated with the web search call.\n"
  }),
  "sequence_number": Schema.Number.annotate({
    "description": "The sequence number of the web search call being processed."
  }).check(Schema.isInt())
}).annotate({ "description": "Emitted when a web search call is executing." })
export type Role = {
  readonly "object": "role"
  readonly "id": string
  readonly "name": string
  readonly "description": string | null
  readonly "permissions": ReadonlyArray<string>
  readonly "resource_type": string
  readonly "predefined_role": boolean
}
export const Role = Schema.Struct({
  "object": Schema.Literal("role").annotate({ "description": "Always `role`." }),
  "id": Schema.String.annotate({ "description": "Identifier for the role." }),
  "name": Schema.String.annotate({ "description": "Unique name for the role." }),
  "description": Schema.Union([Schema.String, Schema.Null]).annotate({
    "description": "Optional description of the role."
  }),
  "permissions": Schema.Array(Schema.String).annotate({ "description": "Permissions granted by the role." }),
  "resource_type": Schema.String.annotate({
    "description": "Resource type the role is bound to (for example `api.organization` or `api.project`)."
  }),
  "predefined_role": Schema.Boolean.annotate({ "description": "Whether the role is predefined and managed by OpenAI." })
}).annotate({ "description": "Details about a role that can be assigned through the public Roles API." })
export type RoleDeletedResource = {
  readonly "object": "role.deleted"
  readonly "id": string
  readonly "deleted": boolean
}
export const RoleDeletedResource = Schema.Struct({
  "object": Schema.Literal("role.deleted").annotate({ "description": "Always `role.deleted`." }),
  "id": Schema.String.annotate({ "description": "Identifier of the deleted role." }),
  "deleted": Schema.Boolean.annotate({ "description": "Whether the role was deleted." })
}).annotate({ "description": "Confirmation payload returned after deleting a role." })
export type RunCompletionUsage = {
  readonly "completion_tokens": number
  readonly "prompt_tokens": number
  readonly "total_tokens": number
} | null
export const RunCompletionUsage = Schema.Union([
  Schema.Struct({
    "completion_tokens": Schema.Number.annotate({
      "description": "Number of completion tokens used over the course of the run."
    }).check(Schema.isInt()),
    "prompt_tokens": Schema.Number.annotate({
      "description": "Number of prompt tokens used over the course of the run."
    }).check(Schema.isInt()),
    "total_tokens": Schema.Number.annotate({ "description": "Total number of tokens used (prompt + completion)." })
      .check(Schema.isInt())
  }).annotate({
    "description":
      "Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.)."
  }),
  Schema.Null
])
export type RunGraderResponse = {
  readonly "reward": number
  readonly "metadata": {
    readonly "name": string
    readonly "type": string
    readonly "errors": {
      readonly "formula_parse_error": boolean
      readonly "sample_parse_error": boolean
      readonly "truncated_observation_error": boolean
      readonly "unresponsive_reward_error": boolean
      readonly "invalid_variable_error": boolean
      readonly "other_error": boolean
      readonly "python_grader_server_error": boolean
      readonly "python_grader_server_error_type": string | null
      readonly "python_grader_runtime_error": boolean
      readonly "python_grader_runtime_error_details": string | null
      readonly "model_grader_server_error": boolean
      readonly "model_grader_refusal_error": boolean
      readonly "model_grader_parse_error": boolean
      readonly "model_grader_server_error_details": string | null
    }
    readonly "execution_time": number
    readonly "scores": {}
    readonly "token_usage": number | null
    readonly "sampled_model_name": string | null
  }
  readonly "sub_rewards": {}
  readonly "model_grader_token_usage_per_model": {}
}
export const RunGraderResponse = Schema.Struct({
  "reward": Schema.Number.check(Schema.isFinite()),
  "metadata": Schema.Struct({
    "name": Schema.String,
    "type": Schema.String,
    "errors": Schema.Struct({
      "formula_parse_error": Schema.Boolean,
      "sample_parse_error": Schema.Boolean,
      "truncated_observation_error": Schema.Boolean,
      "unresponsive_reward_error": Schema.Boolean,
      "invalid_variable_error": Schema.Boolean,
      "other_error": Schema.Boolean,
      "python_grader_server_error": Schema.Boolean,
      "python_grader_server_error_type": Schema.Union([Schema.String, Schema.Null]),
      "python_grader_runtime_error": Schema.Boolean,
      "python_grader_runtime_error_details": Schema.Union([Schema.String, Schema.Null]),
      "model_grader_server_error": Schema.Boolean,
      "model_grader_refusal_error": Schema.Boolean,
      "model_grader_parse_error": Schema.Boolean,
      "model_grader_server_error_details": Schema.Union([Schema.String, Schema.Null])
    }),
    "execution_time": Schema.Number.check(Schema.isFinite()),
    "scores": Schema.Struct({}),
    "token_usage": Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]),
    "sampled_model_name": Schema.Union([Schema.String, Schema.Null])
  }),
  "sub_rewards": Schema.Struct({}),
  "model_grader_token_usage_per_model": Schema.Struct({})
})
export type RunStepCompletionUsage = {
  readonly "completion_tokens": number
  readonly "prompt_tokens": number
  readonly "total_tokens": number
} | null
export const RunStepCompletionUsage = Schema.Union([
  Schema.Struct({
    "completion_tokens": Schema.Number.annotate({
      "description": "Number of completion tokens used over the course of the run step."
    }).check(Schema.isInt()),
    "prompt_tokens": Schema.Number.annotate({
      "description": "Number of prompt tokens used over the course of the run step."
    }).check(Schema.isInt()),
    "total_tokens": Schema.Number.annotate({ "description": "Total number of tokens used (prompt + completion)." })
      .check(Schema.isInt())
  }).annotate({
    "description":
      "Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`."
  }),
  Schema.Null
])
export type RunStepDeltaStepDetailsMessageCreationObject = {
  readonly "type": "message_creation"
  readonly "message_creation"?: { readonly "message_id"?: string }
}
export const RunStepDeltaStepDetailsMessageCreationObject = Schema.Struct({
  "type": Schema.Literal("message_creation").annotate({ "description": "Always `message_creation`." }),
  "message_creation": Schema.optionalKey(
    Schema.Struct({
      "message_id": Schema.optionalKey(
        Schema.String.annotate({ "description": "The ID of the message that was created by this run step." })
      )
    })
  )
}).annotate({ "title": "Message creation", "description": "Details of the message creation by the run step." })
export type RunStepDeltaStepDetailsToolCallsCodeOutputImageObject = {
  readonly "index": number
  readonly "type": "image"
  readonly "image"?: { readonly "file_id"?: string }
}
export const RunStepDeltaStepDetailsToolCallsCodeOutputImageObject = Schema.Struct({
  "index": Schema.Number.annotate({ "description": "The index of the output in the outputs array." }).check(
    Schema.isInt()
  ),
  "type": Schema.Literal("image").annotate({ "description": "Always `image`." }),
  "image": Schema.optionalKey(
    Schema.Struct({
      "file_id": Schema.optionalKey(
        Schema.String.annotate({ "description": "The [file](/docs/api-reference/files) ID of the image." })
      )
    })
  )
}).annotate({ "title": "Code interpreter image output" })
export type RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject = {
  readonly "index": number
  readonly "type": "logs"
  readonly "logs"?: string
}
export const RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject = Schema.Struct({
  "index": Schema.Number.annotate({ "description": "The index of the output in the outputs array." }).check(
    Schema.isInt()
  ),
  "type": Schema.Literal("logs").annotate({ "description": "Always `logs`." }),
  "logs": Schema.optionalKey(
    Schema.String.annotate({ "description": "The text output from the Code Interpreter tool call." })
  )
}).annotate({
  "title": "Code interpreter log output",
  "description": "Text output from the Code Interpreter tool call as part of a run step."
})
export type RunStepDeltaStepDetailsToolCallsFileSearchObject = {
  readonly "index": number
  readonly "id"?: string
  readonly "type": "file_search"
  readonly "file_search": {}
}
export const RunStepDeltaStepDetailsToolCallsFileSearchObject = Schema.Struct({
  "index": Schema.Number.annotate({ "description": "The index of the tool call in the tool calls array." }).check(
    Schema.isInt()
  ),
  "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the tool call object." })),
  "type": Schema.Literal("file_search").annotate({
    "description": "The type of tool call. This is always going to be `file_search` for this type of tool call."
  }),
  "file_search": Schema.Struct({}).annotate({ "description": "For now, this is always going to be an empty object." })
}).annotate({ "title": "File search tool call" })
export type RunStepDeltaStepDetailsToolCallsFunctionObject = {
  readonly "index": number
  readonly "id"?: string
  readonly "type": "function"
  readonly "function"?: { readonly "name"?: string; readonly "arguments"?: string; readonly "output"?: string | null }
}
export const RunStepDeltaStepDetailsToolCallsFunctionObject = Schema.Struct({
  "index": Schema.Number.annotate({ "description": "The index of the tool call in the tool calls array." }).check(
    Schema.isInt()
  ),
  "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the tool call object." })),
  "type": Schema.Literal("function").annotate({
    "description": "The type of tool call. This is always going to be `function` for this type of tool call."
  }),
  "function": Schema.optionalKey(
    Schema.Struct({
      "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the function." })),
      "arguments": Schema.optionalKey(
        Schema.String.annotate({ "description": "The arguments passed to the function." })
      ),
      "output": Schema.optionalKey(
        Schema.Union([
          Schema.String.annotate({
            "description":
              "The output of the function. This will be `null` if the outputs have not been [submitted](/docs/api-reference/runs/submitToolOutputs) yet."
          }),
          Schema.Null
        ])
      )
    }).annotate({ "description": "The definition of the function that was called." })
  )
}).annotate({ "title": "Function tool call" })
export type RunStepDetailsMessageCreationObject = {
  readonly "type": "message_creation"
  readonly "message_creation": { readonly "message_id": string }
}
export const RunStepDetailsMessageCreationObject = Schema.Struct({
  "type": Schema.Literal("message_creation").annotate({ "description": "Always `message_creation`." }),
  "message_creation": Schema.Struct({
    "message_id": Schema.String.annotate({ "description": "The ID of the message that was created by this run step." })
  })
}).annotate({ "title": "Message creation", "description": "Details of the message creation by the run step." })
export type RunStepDetailsToolCallsCodeOutputImageObject = {
  readonly "type": "image"
  readonly "image": { readonly "file_id": string }
}
export const RunStepDetailsToolCallsCodeOutputImageObject = Schema.Struct({
  "type": Schema.Literal("image").annotate({ "description": "Always `image`." }),
  "image": Schema.Struct({
    "file_id": Schema.String.annotate({ "description": "The [file](/docs/api-reference/files) ID of the image." })
  })
}).annotate({ "title": "Code Interpreter image output" })
export type RunStepDetailsToolCallsCodeOutputLogsObject = { readonly "type": "logs"; readonly "logs": string }
export const RunStepDetailsToolCallsCodeOutputLogsObject = Schema.Struct({
  "type": Schema.Literal("logs").annotate({ "description": "Always `logs`." }),
  "logs": Schema.String.annotate({ "description": "The text output from the Code Interpreter tool call." })
}).annotate({
  "title": "Code Interpreter log output",
  "description": "Text output from the Code Interpreter tool call as part of a run step."
})
export type RunStepDetailsToolCallsFileSearchResultObject = {
  readonly "file_id": string
  readonly "file_name": string
  readonly "score": number
  readonly "content"?: ReadonlyArray<{ readonly "type"?: "text"; readonly "text"?: string }>
}
export const RunStepDetailsToolCallsFileSearchResultObject = Schema.Struct({
  "file_id": Schema.String.annotate({ "description": "The ID of the file that result was found in." }),
  "file_name": Schema.String.annotate({ "description": "The name of the file that result was found in." }),
  "score": Schema.Number.annotate({
    "description": "The score of the result. All values must be a floating point number between 0 and 1."
  }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1)),
  "content": Schema.optionalKey(
    Schema.Array(
      Schema.Struct({
        "type": Schema.optionalKey(Schema.Literal("text").annotate({ "description": "The type of the content." })),
        "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content of the file." }))
      })
    ).annotate({
      "description":
        "The content of the result that was found. The content is only included if requested via the include query parameter."
    })
  )
}).annotate({ "title": "File search tool call result", "description": "A result instance of the file search." })
export type RunStepDetailsToolCallsFunctionObject = {
  readonly "id": string
  readonly "type": "function"
  readonly "function": { readonly "name": string; readonly "arguments": string; readonly "output": string | null }
}
export const RunStepDetailsToolCallsFunctionObject = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The ID of the tool call object." }),
  "type": Schema.Literal("function").annotate({
    "description": "The type of tool call. This is always going to be `function` for this type of tool call."
  }),
  "function": Schema.Struct({
    "name": Schema.String.annotate({ "description": "The name of the function." }),
    "arguments": Schema.String.annotate({ "description": "The arguments passed to the function." }),
    "output": Schema.Union([
      Schema.String.annotate({
        "description":
          "The output of the function. This will be `null` if the outputs have not been [submitted](/docs/api-reference/runs/submitToolOutputs) yet."
      }),
      Schema.Null
    ])
  }).annotate({ "description": "The definition of the function that was called." })
}).annotate({ "title": "Function tool call" })
export type ServiceTier = "auto" | "default" | "flex" | "scale" | "priority" | null
export const ServiceTier = Schema.Union([
  Schema.Literals(["auto", "default", "flex", "scale", "priority"]).annotate({
    "description":
      "Specifies the processing type used for serving the request.\n  - If set to 'auto', then the request will be processed with the service tier configured in the Project settings. Unless otherwise configured, the Project will use 'default'.\n  - If set to 'default', then the request will be processed with the standard pricing and performance for the selected model.\n  - If set to '[flex](/docs/guides/flex-processing)' or '[priority](https://openai.com/api-priority-processing/)', then the request will be processed with the corresponding service tier.\n  - When not set, the default behavior is 'auto'.\n\n  When the `service_tier` parameter is set, the response body will include the `service_tier` value based on the processing mode actually used to serve the request. This response value may be different from the value set in the parameter.\n"
  }),
  Schema.Null
])
export type SpeechAudioDeltaEvent = { readonly "type": "speech.audio.delta"; readonly "audio": string }
export const SpeechAudioDeltaEvent = Schema.Struct({
  "type": Schema.Literal("speech.audio.delta").annotate({
    "description": "The type of the event. Always `speech.audio.delta`.\n"
  }),
  "audio": Schema.String.annotate({ "description": "A chunk of Base64-encoded audio data.\n" })
}).annotate({ "description": "Emitted for each chunk of audio data generated during speech synthesis." })
export type SpeechAudioDoneEvent = {
  readonly "type": "speech.audio.done"
  readonly "usage": {
    readonly "input_tokens": number
    readonly "output_tokens": number
    readonly "total_tokens": number
  }
}
export const SpeechAudioDoneEvent = Schema.Struct({
  "type": Schema.Literal("speech.audio.done").annotate({
    "description": "The type of the event. Always `speech.audio.done`.\n"
  }),
  "usage": Schema.Struct({
    "input_tokens": Schema.Number.annotate({ "description": "Number of input tokens in the prompt." }).check(
      Schema.isInt()
    ),
    "output_tokens": Schema.Number.annotate({ "description": "Number of output tokens generated." }).check(
      Schema.isInt()
    ),
    "total_tokens": Schema.Number.annotate({ "description": "Total number of tokens used (input + output)." }).check(
      Schema.isInt()
    )
  }).annotate({ "description": "Token usage statistics for the request.\n" })
}).annotate({ "description": "Emitted when the speech synthesis is complete and all audio has been streamed." })
export type StaticChunkingStrategy = {
  readonly "max_chunk_size_tokens": number
  readonly "chunk_overlap_tokens": number
}
export const StaticChunkingStrategy = Schema.Struct({
  "max_chunk_size_tokens": Schema.Number.annotate({
    "description":
      "The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`."
  }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(100)).check(Schema.isLessThanOrEqualTo(4096)),
  "chunk_overlap_tokens": Schema.Number.annotate({
    "description":
      "The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n"
  }).check(Schema.isInt())
})
export type StopConfiguration = string | null | ReadonlyArray<string> | null
export const StopConfiguration = Schema.Union([
  Schema.Union([
    Schema.Union([Schema.String, Schema.Null]),
    Schema.Array(Schema.String).check(Schema.isMinLength(1)).check(Schema.isMaxLength(4))
  ], { mode: "oneOf" }).annotate({
    "description":
      "Not supported with latest reasoning models `o3` and `o4-mini`.\n\nUp to 4 sequences where the API will stop generating further tokens. The\nreturned text will not contain the stop sequence.\n"
  }),
  Schema.Null
])
export type SubmitToolOutputsRunRequest = {
  readonly "tool_outputs": ReadonlyArray<{ readonly "tool_call_id"?: string; readonly "output"?: string }>
  readonly "stream"?: boolean | null
}
export const SubmitToolOutputsRunRequest = Schema.Struct({
  "tool_outputs": Schema.Array(Schema.Struct({
    "tool_call_id": Schema.optionalKey(
      Schema.String.annotate({
        "description":
          "The ID of the tool call in the `required_action` object within the run object the output is being submitted for."
      })
    ),
    "output": Schema.optionalKey(
      Schema.String.annotate({ "description": "The output of the tool call to be submitted to continue the run." })
    )
  })).annotate({ "description": "A list of tools for which the outputs are being submitted." }),
  "stream": Schema.optionalKey(
    Schema.Union([
      Schema.Boolean.annotate({
        "description":
          "If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.\n"
      }),
      Schema.Null
    ])
  )
})
export type ToggleCertificatesRequest = { readonly "certificate_ids": ReadonlyArray<string> }
export const ToggleCertificatesRequest = Schema.Struct({
  "certificate_ids": Schema.Array(Schema.String).check(Schema.isMinLength(1)).check(Schema.isMaxLength(10))
})
export type ToolChoiceAllowed = {
  readonly "type": "allowed_tools"
  readonly "mode": "auto" | "required"
  readonly "tools": ReadonlyArray<{}>
}
export const ToolChoiceAllowed = Schema.Struct({
  "type": Schema.Literal("allowed_tools").annotate({
    "description": "Allowed tool configuration type. Always `allowed_tools`."
  }),
  "mode": Schema.Literals(["auto", "required"]).annotate({
    "description":
      "Constrains the tools available to the model to a pre-defined set.\n\n`auto` allows the model to pick from among the allowed tools and generate a\nmessage.\n\n`required` requires the model to call one or more of the allowed tools.\n"
  }),
  "tools": Schema.Array(
    Schema.Struct({}).annotate({ "description": "A tool definition that the model should be allowed to call.\n" })
  ).annotate({
    "description":
      "A list of tool definitions that the model should be allowed to call.\n\nFor the Responses API, the list of tool definitions might look like:\n```json\n[\n  { \"type\": \"function\", \"name\": \"get_weather\" },\n  { \"type\": \"mcp\", \"server_label\": \"deepwiki\" },\n  { \"type\": \"image_generation\" }\n]\n```\n"
  })
}).annotate({
  "title": "Allowed tools",
  "description": "Constrains the tools available to the model to a pre-defined set.\n"
})
export type ToolChoiceCustom = { readonly "type": "custom"; readonly "name": string }
export const ToolChoiceCustom = Schema.Struct({
  "type": Schema.Literal("custom").annotate({ "description": "For custom tool calling, the type is always `custom`." }),
  "name": Schema.String.annotate({ "description": "The name of the custom tool to call." })
}).annotate({
  "title": "Custom tool",
  "description": "Use this option to force the model to call a specific custom tool.\n"
})
export type ToolChoiceFunction = { readonly "type": "function"; readonly "name": string }
export const ToolChoiceFunction = Schema.Struct({
  "type": Schema.Literal("function").annotate({
    "description": "For function calling, the type is always `function`."
  }),
  "name": Schema.String.annotate({ "description": "The name of the function to call." })
}).annotate({
  "title": "Function tool",
  "description": "Use this option to force the model to call a specific function.\n"
})
export type ToolChoiceMCP = { readonly "type": "mcp"; readonly "server_label": string; readonly "name"?: string | null }
export const ToolChoiceMCP = Schema.Struct({
  "type": Schema.Literal("mcp").annotate({ "description": "For MCP tools, the type is always `mcp`." }),
  "server_label": Schema.String.annotate({ "description": "The label of the MCP server to use.\n" }),
  "name": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "The name of the tool to call on the server.\n" }),
      Schema.Null
    ])
  )
}).annotate({
  "title": "MCP tool",
  "description": "Use this option to force the model to call a specific tool on a remote MCP server.\n"
})
export type ToolChoiceOptions = "none" | "auto" | "required"
export const ToolChoiceOptions = Schema.Literals(["none", "auto", "required"]).annotate({
  "title": "Tool choice mode",
  "description":
    "Controls which (if any) tool is called by the model.\n\n`none` means the model will not call any tool and instead generates a message.\n\n`auto` means the model can pick between generating a message or calling one or\nmore tools.\n\n`required` means the model must call one or more tools.\n"
})
export type ToolChoiceTypes = {
  readonly "type":
    | "file_search"
    | "web_search_preview"
    | "computer_use_preview"
    | "web_search_preview_2025_03_11"
    | "image_generation"
    | "code_interpreter"
}
export const ToolChoiceTypes = Schema.Struct({
  "type": Schema.Literals([
    "file_search",
    "web_search_preview",
    "computer_use_preview",
    "web_search_preview_2025_03_11",
    "image_generation",
    "code_interpreter"
  ]).annotate({
    "description":
      "The type of hosted tool the model should to use. Learn more about\n[built-in tools](/docs/guides/tools).\n\nAllowed values are:\n- `file_search`\n- `web_search_preview`\n- `computer_use_preview`\n- `code_interpreter`\n- `image_generation`\n"
  })
}).annotate({
  "title": "Hosted tool",
  "description":
    "Indicates that the model should use a built-in tool to generate a response.\n[Learn more about built-in tools](/docs/guides/tools).\n"
})
export type TranscriptTextDeltaEvent = {
  readonly "type": "transcript.text.delta"
  readonly "delta": string
  readonly "logprobs"?: ReadonlyArray<
    { readonly "token"?: string; readonly "logprob"?: number; readonly "bytes"?: ReadonlyArray<number> }
  >
  readonly "segment_id"?: string
}
export const TranscriptTextDeltaEvent = Schema.Struct({
  "type": Schema.Literal("transcript.text.delta").annotate({
    "description": "The type of the event. Always `transcript.text.delta`.\n"
  }),
  "delta": Schema.String.annotate({ "description": "The text delta that was additionally transcribed.\n" }),
  "logprobs": Schema.optionalKey(
    Schema.Array(Schema.Struct({
      "token": Schema.optionalKey(
        Schema.String.annotate({ "description": "The token that was used to generate the log probability.\n" })
      ),
      "logprob": Schema.optionalKey(
        Schema.Number.annotate({ "description": "The log probability of the token.\n" }).check(Schema.isFinite())
      ),
      "bytes": Schema.optionalKey(
        Schema.Array(Schema.Number.check(Schema.isInt())).annotate({
          "description": "The bytes that were used to generate the log probability.\n"
        })
      )
    })).annotate({
      "description":
        "The log probabilities of the delta. Only included if you [create a transcription](/docs/api-reference/audio/create-transcription) with the `include[]` parameter set to `logprobs`.\n"
    })
  ),
  "segment_id": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "Identifier of the diarized segment that this delta belongs to. Only present when using `gpt-4o-transcribe-diarize`.\n"
    })
  )
}).annotate({
  "description":
    "Emitted when there is an additional text delta. This is also the first event emitted when the transcription starts. Only emitted when you [create a transcription](/docs/api-reference/audio/create-transcription) with the `Stream` parameter set to `true`."
})
export type TranscriptTextSegmentEvent = {
  readonly "type": "transcript.text.segment"
  readonly "id": string
  readonly "start": number
  readonly "end": number
  readonly "text": string
  readonly "speaker": string
}
export const TranscriptTextSegmentEvent = Schema.Struct({
  "type": Schema.Literal("transcript.text.segment").annotate({
    "description": "The type of the event. Always `transcript.text.segment`."
  }),
  "id": Schema.String.annotate({ "description": "Unique identifier for the segment." }),
  "start": Schema.Number.annotate({ "description": "Start timestamp of the segment in seconds.", "format": "float" })
    .check(Schema.isFinite()),
  "end": Schema.Number.annotate({ "description": "End timestamp of the segment in seconds.", "format": "float" }).check(
    Schema.isFinite()
  ),
  "text": Schema.String.annotate({ "description": "Transcript text for this segment." }),
  "speaker": Schema.String.annotate({ "description": "Speaker label for this segment." })
}).annotate({
  "description":
    "Emitted when a diarized transcription returns a completed segment with speaker information. Only emitted when you [create a transcription](/docs/api-reference/audio/create-transcription) with `stream` set to `true` and `response_format` set to `diarized_json`.\n"
})
export type TranscriptTextUsageDuration = { readonly "type": "duration"; readonly "seconds": number }
export const TranscriptTextUsageDuration = Schema.Struct({
  "type": Schema.Literal("duration").annotate({
    "description": "The type of the usage object. Always `duration` for this variant."
  }),
  "seconds": Schema.Number.annotate({ "description": "Duration of the input audio in seconds." }).check(
    Schema.isFinite()
  )
}).annotate({ "title": "Duration Usage", "description": "Usage statistics for models billed by audio input duration." })
export type TranscriptTextUsageTokens = {
  readonly "type": "tokens"
  readonly "input_tokens": number
  readonly "input_token_details"?: { readonly "text_tokens"?: number; readonly "audio_tokens"?: number }
  readonly "output_tokens": number
  readonly "total_tokens": number
}
export const TranscriptTextUsageTokens = Schema.Struct({
  "type": Schema.Literal("tokens").annotate({
    "description": "The type of the usage object. Always `tokens` for this variant."
  }),
  "input_tokens": Schema.Number.annotate({ "description": "Number of input tokens billed for this request." }).check(
    Schema.isInt()
  ),
  "input_token_details": Schema.optionalKey(
    Schema.Struct({
      "text_tokens": Schema.optionalKey(
        Schema.Number.annotate({ "description": "Number of text tokens billed for this request." }).check(
          Schema.isInt()
        )
      ),
      "audio_tokens": Schema.optionalKey(
        Schema.Number.annotate({ "description": "Number of audio tokens billed for this request." }).check(
          Schema.isInt()
        )
      )
    }).annotate({ "description": "Details about the input tokens billed for this request." })
  ),
  "output_tokens": Schema.Number.annotate({ "description": "Number of output tokens generated." }).check(
    Schema.isInt()
  ),
  "total_tokens": Schema.Number.annotate({ "description": "Total number of tokens used (input + output)." }).check(
    Schema.isInt()
  )
}).annotate({ "title": "Token Usage", "description": "Usage statistics for models billed by token usage." })
export type TranscriptionDiarizedSegment = {
  readonly "type": "transcript.text.segment"
  readonly "id": string
  readonly "start": number
  readonly "end": number
  readonly "text": string
  readonly "speaker": string
}
export const TranscriptionDiarizedSegment = Schema.Struct({
  "type": Schema.Literal("transcript.text.segment").annotate({
    "description": "The type of the segment. Always `transcript.text.segment`.\n"
  }),
  "id": Schema.String.annotate({ "description": "Unique identifier for the segment." }),
  "start": Schema.Number.annotate({ "description": "Start timestamp of the segment in seconds.", "format": "float" })
    .check(Schema.isFinite()),
  "end": Schema.Number.annotate({ "description": "End timestamp of the segment in seconds.", "format": "float" }).check(
    Schema.isFinite()
  ),
  "text": Schema.String.annotate({ "description": "Transcript text for this segment." }),
  "speaker": Schema.String.annotate({
    "description":
      "Speaker label for this segment. When known speakers are provided, the label matches `known_speaker_names[]`. Otherwise speakers are labeled sequentially using capital letters (`A`, `B`, ...).\n"
  })
}).annotate({ "description": "A segment of diarized transcript text with speaker metadata." })
export type TranscriptionInclude = "logprobs"
export const TranscriptionInclude = Schema.Literal("logprobs")
export type TranscriptionSegment = {
  readonly "id": number
  readonly "seek": number
  readonly "start": number
  readonly "end": number
  readonly "text": string
  readonly "tokens": ReadonlyArray<number>
  readonly "temperature": number
  readonly "avg_logprob": number
  readonly "compression_ratio": number
  readonly "no_speech_prob": number
}
export const TranscriptionSegment = Schema.Struct({
  "id": Schema.Number.annotate({ "description": "Unique identifier of the segment." }).check(Schema.isInt()),
  "seek": Schema.Number.annotate({ "description": "Seek offset of the segment." }).check(Schema.isInt()),
  "start": Schema.Number.annotate({ "description": "Start time of the segment in seconds.", "format": "float" }).check(
    Schema.isFinite()
  ),
  "end": Schema.Number.annotate({ "description": "End time of the segment in seconds.", "format": "float" }).check(
    Schema.isFinite()
  ),
  "text": Schema.String.annotate({ "description": "Text content of the segment." }),
  "tokens": Schema.Array(Schema.Number.check(Schema.isInt())).annotate({
    "description": "Array of token IDs for the text content."
  }),
  "temperature": Schema.Number.annotate({
    "description": "Temperature parameter used for generating the segment.",
    "format": "float"
  }).check(Schema.isFinite()),
  "avg_logprob": Schema.Number.annotate({
    "description": "Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.",
    "format": "float"
  }).check(Schema.isFinite()),
  "compression_ratio": Schema.Number.annotate({
    "description":
      "Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.",
    "format": "float"
  }).check(Schema.isFinite()),
  "no_speech_prob": Schema.Number.annotate({
    "description":
      "Probability of no speech in the segment. If the value is higher than 1.0 and the `avg_logprob` is below -1, consider this segment silent.",
    "format": "float"
  }).check(Schema.isFinite())
})
export type TranscriptionWord = { readonly "word": string; readonly "start": number; readonly "end": number }
export const TranscriptionWord = Schema.Struct({
  "word": Schema.String.annotate({ "description": "The text content of the word." }),
  "start": Schema.Number.annotate({ "description": "Start time of the word in seconds.", "format": "float" }).check(
    Schema.isFinite()
  ),
  "end": Schema.Number.annotate({ "description": "End time of the word in seconds.", "format": "float" }).check(
    Schema.isFinite()
  )
})
export type UpdateGroupBody = { readonly "name": string }
export const UpdateGroupBody = Schema.Struct({
  "name": Schema.String.annotate({ "description": "New display name for the group." }).check(Schema.isMinLength(1))
    .check(Schema.isMaxLength(255))
}).annotate({ "description": "Request payload for updating the details of an existing group." })
export type UpdateVoiceConsentRequest = { readonly "name": string }
export const UpdateVoiceConsentRequest = Schema.Struct({
  "name": Schema.String.annotate({ "description": "The updated label for this consent recording." })
})
export type Upload = {
  readonly "id": string
  readonly "created_at": number
  readonly "filename": string
  readonly "bytes": number
  readonly "purpose": string
  readonly "status": "pending" | "completed" | "cancelled" | "expired"
  readonly "expires_at": number
  readonly "object"?: "upload"
  readonly "file"?: {
    readonly "id": string
    readonly "bytes": number
    readonly "created_at": number
    readonly "expires_at"?: number
    readonly "filename": string
    readonly "object": "file"
    readonly "purpose":
      | "assistants"
      | "assistants_output"
      | "batch"
      | "batch_output"
      | "fine-tune"
      | "fine-tune-results"
      | "vision"
      | "user_data"
    readonly "status": "uploaded" | "processed" | "error"
    readonly "status_details"?: string
    readonly [x: string]: unknown
  }
}
export const Upload = Schema.Struct({
  "id": Schema.String.annotate({
    "description": "The Upload unique identifier, which can be referenced in API endpoints."
  }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the Upload was created."
  }).check(Schema.isInt()),
  "filename": Schema.String.annotate({ "description": "The name of the file to be uploaded." }),
  "bytes": Schema.Number.annotate({ "description": "The intended number of bytes to be uploaded." }).check(
    Schema.isInt()
  ),
  "purpose": Schema.String.annotate({
    "description":
      "The intended purpose of the file. [Please refer here](/docs/api-reference/files/object#files/object-purpose) for acceptable values."
  }),
  "status": Schema.Literals(["pending", "completed", "cancelled", "expired"]).annotate({
    "description": "The status of the Upload."
  }),
  "expires_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the Upload will expire."
  }).check(Schema.isInt()),
  "object": Schema.optionalKey(
    Schema.Literal("upload").annotate({ "description": "The object type, which is always \"upload\"." })
  ),
  "file": Schema.optionalKey(Schema.Union([
    Schema.StructWithRest(
      Schema.Struct({
        "id": Schema.String.annotate({
          "description": "The file identifier, which can be referenced in the API endpoints."
        }),
        "bytes": Schema.Number.annotate({ "description": "The size of the file, in bytes." }).check(Schema.isInt()),
        "created_at": Schema.Number.annotate({
          "description": "The Unix timestamp (in seconds) for when the file was created."
        }).check(Schema.isInt()),
        "expires_at": Schema.optionalKey(
          Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the file will expire." })
            .check(Schema.isInt())
        ),
        "filename": Schema.String.annotate({ "description": "The name of the file." }),
        "object": Schema.Literal("file").annotate({ "description": "The object type, which is always `file`." }),
        "purpose": Schema.Literals([
          "assistants",
          "assistants_output",
          "batch",
          "batch_output",
          "fine-tune",
          "fine-tune-results",
          "vision",
          "user_data"
        ]).annotate({
          "description":
            "The intended purpose of the file. Supported values are `assistants`, `assistants_output`, `batch`, `batch_output`, `fine-tune`, `fine-tune-results`, `vision`, and `user_data`."
        }),
        "status": Schema.Literals(["uploaded", "processed", "error"]).annotate({
          "description":
            "Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`."
        }),
        "status_details": Schema.optionalKey(
          Schema.String.annotate({
            "description":
              "Deprecated. For details on why a fine-tuning training file failed validation, see the `error` field on `fine_tuning.job`."
          })
        )
      }),
      [Schema.Record(Schema.String, Schema.Json)]
    ).annotate({
      "description": "The `File` object represents a document that has been uploaded to OpenAI.",
      "title": "OpenAIFile"
    })
  ]))
}).annotate({ "title": "Upload", "description": "The Upload object can accept byte chunks in the form of Parts.\n" })
export type UploadCertificateRequest = { readonly "name"?: string; readonly "content": string }
export const UploadCertificateRequest = Schema.Struct({
  "name": Schema.optionalKey(Schema.String.annotate({ "description": "An optional name for the certificate" })),
  "content": Schema.String.annotate({ "description": "The certificate content in PEM format" })
})
export type UploadPart = {
  readonly "id": string
  readonly "created_at": number
  readonly "upload_id": string
  readonly "object": "upload.part"
}
export const UploadPart = Schema.Struct({
  "id": Schema.String.annotate({
    "description": "The upload Part unique identifier, which can be referenced in API endpoints."
  }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the Part was created."
  }).check(Schema.isInt()),
  "upload_id": Schema.String.annotate({ "description": "The ID of the Upload object that this Part was added to." }),
  "object": Schema.Literal("upload.part").annotate({ "description": "The object type, which is always `upload.part`." })
}).annotate({
  "title": "UploadPart",
  "description": "The upload Part represents a chunk of bytes we can add to an Upload object.\n"
})
export type UsageAudioSpeechesResult = {
  readonly "object": "organization.usage.audio_speeches.result"
  readonly "characters": number
  readonly "num_model_requests": number
  readonly "project_id"?: string | null
  readonly "user_id"?: string | null
  readonly "api_key_id"?: string | null
  readonly "model"?: string | null
}
export const UsageAudioSpeechesResult = Schema.Struct({
  "object": Schema.Literal("organization.usage.audio_speeches.result"),
  "characters": Schema.Number.annotate({ "description": "The number of characters processed." }).check(Schema.isInt()),
  "num_model_requests": Schema.Number.annotate({ "description": "The count of requests made to the model." }).check(
    Schema.isInt()
  ),
  "project_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=project_id`, this field provides the project ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "user_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=user_id`, this field provides the user ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "api_key_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=model`, this field provides the model name of the grouped usage result."
      }),
      Schema.Null
    ])
  )
}).annotate({ "description": "The aggregated audio speeches usage details of the specific time bucket." })
export type UsageAudioTranscriptionsResult = {
  readonly "object": "organization.usage.audio_transcriptions.result"
  readonly "seconds": number
  readonly "num_model_requests": number
  readonly "project_id"?: string | null
  readonly "user_id"?: string | null
  readonly "api_key_id"?: string | null
  readonly "model"?: string | null
}
export const UsageAudioTranscriptionsResult = Schema.Struct({
  "object": Schema.Literal("organization.usage.audio_transcriptions.result"),
  "seconds": Schema.Number.annotate({ "description": "The number of seconds processed." }).check(Schema.isInt()),
  "num_model_requests": Schema.Number.annotate({ "description": "The count of requests made to the model." }).check(
    Schema.isInt()
  ),
  "project_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=project_id`, this field provides the project ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "user_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=user_id`, this field provides the user ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "api_key_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=model`, this field provides the model name of the grouped usage result."
      }),
      Schema.Null
    ])
  )
}).annotate({ "description": "The aggregated audio transcriptions usage details of the specific time bucket." })
export type UsageCodeInterpreterSessionsResult = {
  readonly "object": "organization.usage.code_interpreter_sessions.result"
  readonly "num_sessions"?: number
  readonly "project_id"?: string | null
  readonly "sessions": unknown
}
export const UsageCodeInterpreterSessionsResult = Schema.Struct({
  "object": Schema.Literal("organization.usage.code_interpreter_sessions.result"),
  "num_sessions": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The number of code interpreter sessions." }).check(Schema.isInt())
  ),
  "project_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=project_id`, this field provides the project ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "sessions": Schema.Unknown
}).annotate({ "description": "The aggregated code interpreter sessions usage details of the specific time bucket." })
export type UsageCompletionsResult = {
  readonly "object": "organization.usage.completions.result"
  readonly "input_tokens": number
  readonly "input_cached_tokens"?: number
  readonly "output_tokens": number
  readonly "input_audio_tokens"?: number
  readonly "output_audio_tokens"?: number
  readonly "num_model_requests": number
  readonly "project_id"?: string | null
  readonly "user_id"?: string | null
  readonly "api_key_id"?: string | null
  readonly "model"?: string | null
  readonly "batch"?: boolean | null
  readonly "service_tier"?: string | null
}
export const UsageCompletionsResult = Schema.Struct({
  "object": Schema.Literal("organization.usage.completions.result"),
  "input_tokens": Schema.Number.annotate({
    "description":
      "The aggregated number of text input tokens used, including cached tokens. For customers subscribe to scale tier, this includes scale tier tokens."
  }).check(Schema.isInt()),
  "input_cached_tokens": Schema.optionalKey(
    Schema.Number.annotate({
      "description":
        "The aggregated number of text input tokens that has been cached from previous requests. For customers subscribe to scale tier, this includes scale tier tokens."
    }).check(Schema.isInt())
  ),
  "output_tokens": Schema.Number.annotate({
    "description":
      "The aggregated number of text output tokens used. For customers subscribe to scale tier, this includes scale tier tokens."
  }).check(Schema.isInt()),
  "input_audio_tokens": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "The aggregated number of audio input tokens used, including cached tokens."
    }).check(Schema.isInt())
  ),
  "output_audio_tokens": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The aggregated number of audio output tokens used." }).check(
      Schema.isInt()
    )
  ),
  "num_model_requests": Schema.Number.annotate({ "description": "The count of requests made to the model." }).check(
    Schema.isInt()
  ),
  "project_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=project_id`, this field provides the project ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "user_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=user_id`, this field provides the user ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "api_key_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=model`, this field provides the model name of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "batch": Schema.optionalKey(
    Schema.Union([
      Schema.Boolean.annotate({
        "description": "When `group_by=batch`, this field tells whether the grouped usage result is batch or not."
      }),
      Schema.Null
    ])
  ),
  "service_tier": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=service_tier`, this field provides the service tier of the grouped usage result."
      }),
      Schema.Null
    ])
  )
}).annotate({ "description": "The aggregated completions usage details of the specific time bucket." })
export type UsageEmbeddingsResult = {
  readonly "object": "organization.usage.embeddings.result"
  readonly "input_tokens": number
  readonly "num_model_requests": number
  readonly "project_id"?: string | null
  readonly "user_id"?: string | null
  readonly "api_key_id"?: string | null
  readonly "model"?: string | null
}
export const UsageEmbeddingsResult = Schema.Struct({
  "object": Schema.Literal("organization.usage.embeddings.result"),
  "input_tokens": Schema.Number.annotate({ "description": "The aggregated number of input tokens used." }).check(
    Schema.isInt()
  ),
  "num_model_requests": Schema.Number.annotate({ "description": "The count of requests made to the model." }).check(
    Schema.isInt()
  ),
  "project_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=project_id`, this field provides the project ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "user_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=user_id`, this field provides the user ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "api_key_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=model`, this field provides the model name of the grouped usage result."
      }),
      Schema.Null
    ])
  )
}).annotate({ "description": "The aggregated embeddings usage details of the specific time bucket." })
export type UsageImagesResult = {
  readonly "object": "organization.usage.images.result"
  readonly "images": number
  readonly "num_model_requests": number
  readonly "source"?: string | null
  readonly "size"?: string | null
  readonly "project_id"?: string | null
  readonly "user_id"?: string | null
  readonly "api_key_id"?: string | null
  readonly "model"?: string | null
}
export const UsageImagesResult = Schema.Struct({
  "object": Schema.Literal("organization.usage.images.result"),
  "images": Schema.Number.annotate({ "description": "The number of images processed." }).check(Schema.isInt()),
  "num_model_requests": Schema.Number.annotate({ "description": "The count of requests made to the model." }).check(
    Schema.isInt()
  ),
  "source": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "When `group_by=source`, this field provides the source of the grouped usage result, possible values are `image.generation`, `image.edit`, `image.variation`."
      }),
      Schema.Null
    ])
  ),
  "size": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=size`, this field provides the image size of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "project_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=project_id`, this field provides the project ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "user_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=user_id`, this field provides the user ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "api_key_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=model`, this field provides the model name of the grouped usage result."
      }),
      Schema.Null
    ])
  )
}).annotate({ "description": "The aggregated images usage details of the specific time bucket." })
export type UsageModerationsResult = {
  readonly "object": "organization.usage.moderations.result"
  readonly "input_tokens": number
  readonly "num_model_requests": number
  readonly "project_id"?: string | null
  readonly "user_id"?: string | null
  readonly "api_key_id"?: string | null
  readonly "model"?: string | null
}
export const UsageModerationsResult = Schema.Struct({
  "object": Schema.Literal("organization.usage.moderations.result"),
  "input_tokens": Schema.Number.annotate({ "description": "The aggregated number of input tokens used." }).check(
    Schema.isInt()
  ),
  "num_model_requests": Schema.Number.annotate({ "description": "The count of requests made to the model." }).check(
    Schema.isInt()
  ),
  "project_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=project_id`, this field provides the project ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "user_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=user_id`, this field provides the user ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "api_key_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."
      }),
      Schema.Null
    ])
  ),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=model`, this field provides the model name of the grouped usage result."
      }),
      Schema.Null
    ])
  )
}).annotate({ "description": "The aggregated moderations usage details of the specific time bucket." })
export type UsageVectorStoresResult = {
  readonly "object": "organization.usage.vector_stores.result"
  readonly "usage_bytes": number
  readonly "project_id"?: string | null
}
export const UsageVectorStoresResult = Schema.Struct({
  "object": Schema.Literal("organization.usage.vector_stores.result"),
  "usage_bytes": Schema.Number.annotate({ "description": "The vector stores usage in bytes." }).check(Schema.isInt()),
  "project_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "When `group_by=project_id`, this field provides the project ID of the grouped usage result."
      }),
      Schema.Null
    ])
  )
}).annotate({ "description": "The aggregated vector stores usage details of the specific time bucket." })
export type User = {
  readonly "object": "organization.user"
  readonly "id": string
  readonly "name": string
  readonly "email": string
  readonly "role": "owner" | "reader"
  readonly "added_at": number
}
export const User = Schema.Struct({
  "object": Schema.Literal("organization.user").annotate({
    "description": "The object type, which is always `organization.user`"
  }),
  "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" }),
  "name": Schema.String.annotate({ "description": "The name of the user" }),
  "email": Schema.String.annotate({ "description": "The email address of the user" }),
  "role": Schema.Literals(["owner", "reader"]).annotate({ "description": "`owner` or `reader`" }),
  "added_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the user was added." })
    .check(Schema.isInt())
}).annotate({ "description": "Represents an individual `user` within an organization." })
export type UserDeleteResponse = {
  readonly "object": "organization.user.deleted"
  readonly "id": string
  readonly "deleted": boolean
}
export const UserDeleteResponse = Schema.Struct({
  "object": Schema.Literal("organization.user.deleted"),
  "id": Schema.String,
  "deleted": Schema.Boolean
})
export type UserRoleUpdateRequest = { readonly "role": "owner" | "reader" }
export const UserRoleUpdateRequest = Schema.Struct({
  "role": Schema.Literals(["owner", "reader"]).annotate({ "description": "`owner` or `reader`" })
})
export type VadConfig = {
  readonly "type": "server_vad"
  readonly "prefix_padding_ms"?: number
  readonly "silence_duration_ms"?: number
  readonly "threshold"?: number
}
export const VadConfig = Schema.Struct({
  "type": Schema.Literal("server_vad").annotate({
    "description": "Must be set to `server_vad` to enable manual chunking using server side VAD."
  }),
  "prefix_padding_ms": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "Amount of audio to include before the VAD detected speech (in \nmilliseconds).\n"
    }).check(Schema.isInt())
  ),
  "silence_duration_ms": Schema.optionalKey(
    Schema.Number.annotate({
      "description":
        "Duration of silence to detect speech stop (in milliseconds).\nWith shorter values the model will respond more quickly, \nbut may jump in on short pauses from the user.\n"
    }).check(Schema.isInt())
  ),
  "threshold": Schema.optionalKey(
    Schema.Number.annotate({
      "description":
        "Sensitivity threshold (0.0 to 1.0) for voice activity detection. A \nhigher threshold will require louder audio to activate the model, and \nthus might perform better in noisy environments.\n"
    }).check(Schema.isFinite())
  )
})
export type VectorStoreExpirationAfter = { readonly "anchor": "last_active_at"; readonly "days": number }
export const VectorStoreExpirationAfter = Schema.Struct({
  "anchor": Schema.Literal("last_active_at").annotate({
    "description": "Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`."
  }),
  "days": Schema.Number.annotate({
    "description": "The number of days after the anchor time that the vector store will expire."
  }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(Schema.isLessThanOrEqualTo(365))
}).annotate({ "title": "Vector store expiration policy", "description": "The expiration policy for a vector store." })
export type VectorStoreFileAttributes = {} | null
export const VectorStoreFileAttributes = Schema.Union([
  Schema.Struct({}).annotate({
    "description":
      "Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard. Keys are strings\nwith a maximum length of 64 characters. Values are strings with a maximum\nlength of 512 characters, booleans, or numbers.\n"
  }).check(Schema.isMaxProperties(16)).check(Schema.isPropertyNames(Schema.String.check(Schema.isMaxLength(64)))),
  Schema.Null
])
export type VectorStoreFileBatchObject = {
  readonly "id": string
  readonly "object": "vector_store.files_batch"
  readonly "created_at": number
  readonly "vector_store_id": string
  readonly "status": "in_progress" | "completed" | "cancelled" | "failed"
  readonly "file_counts": {
    readonly "in_progress": number
    readonly "completed": number
    readonly "failed": number
    readonly "cancelled": number
    readonly "total": number
  }
}
export const VectorStoreFileBatchObject = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints." }),
  "object": Schema.Literal("vector_store.files_batch").annotate({
    "description": "The object type, which is always `vector_store.file_batch`."
  }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the vector store files batch was created."
  }).check(Schema.isInt()),
  "vector_store_id": Schema.String.annotate({
    "description":
      "The ID of the [vector store](/docs/api-reference/vector-stores/object) that the [File](/docs/api-reference/files) is attached to."
  }),
  "status": Schema.Literals(["in_progress", "completed", "cancelled", "failed"]).annotate({
    "description":
      "The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`."
  }),
  "file_counts": Schema.Struct({
    "in_progress": Schema.Number.annotate({ "description": "The number of files that are currently being processed." })
      .check(Schema.isInt()),
    "completed": Schema.Number.annotate({ "description": "The number of files that have been processed." }).check(
      Schema.isInt()
    ),
    "failed": Schema.Number.annotate({ "description": "The number of files that have failed to process." }).check(
      Schema.isInt()
    ),
    "cancelled": Schema.Number.annotate({ "description": "The number of files that where cancelled." }).check(
      Schema.isInt()
    ),
    "total": Schema.Number.annotate({ "description": "The total number of files." }).check(Schema.isInt())
  })
}).annotate({ "title": "Vector store file batch", "description": "A batch of files attached to a vector store." })
export type VectorStoreFileContentResponse = {
  readonly "object": "vector_store.file_content.page"
  readonly "data": ReadonlyArray<{ readonly "type"?: string; readonly "text"?: string }>
  readonly "has_more": boolean
  readonly "next_page": string | null
}
export const VectorStoreFileContentResponse = Schema.Struct({
  "object": Schema.Literal("vector_store.file_content.page").annotate({
    "description": "The object type, which is always `vector_store.file_content.page`"
  }),
  "data": Schema.Array(
    Schema.Struct({
      "type": Schema.optionalKey(
        Schema.String.annotate({ "description": "The content type (currently only `\"text\"`)" })
      ),
      "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content" }))
    })
  ).annotate({ "description": "Parsed content of the file." }),
  "has_more": Schema.Boolean.annotate({ "description": "Indicates if there are more content pages to fetch." }),
  "next_page": Schema.Union([
    Schema.String.annotate({ "description": "The token for the next page, if any." }),
    Schema.Null
  ])
}).annotate({ "description": "Represents the parsed content of a vector store file." })
export type VectorStoreSearchResultContentObject = { readonly "type": "text"; readonly "text": string }
export const VectorStoreSearchResultContentObject = Schema.Struct({
  "type": Schema.Literal("text").annotate({ "description": "The type of content." }),
  "text": Schema.String.annotate({ "description": "The text content returned from search." })
})
export type Verbosity = "low" | "medium" | "high" | null
export const Verbosity = Schema.Union([
  Schema.Literals(["low", "medium", "high"]).annotate({
    "description":
      "Constrains the verbosity of the model's response. Lower values will result in\nmore concise responses, while higher values will result in more verbose responses.\nCurrently supported values are `low`, `medium`, and `high`.\n"
  }),
  Schema.Null
])
export type VoiceConsentDeletedResource = {
  readonly "id": string
  readonly "object": "audio.voice_consent"
  readonly "deleted": boolean
}
export const VoiceConsentDeletedResource = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The consent recording identifier." }),
  "object": Schema.Literal("audio.voice_consent"),
  "deleted": Schema.Boolean
})
export type VoiceConsentResource = {
  readonly "object": "audio.voice_consent"
  readonly "id": string
  readonly "name": string
  readonly "language": string
  readonly "created_at": number
}
export const VoiceConsentResource = Schema.Struct({
  "object": Schema.Literal("audio.voice_consent").annotate({
    "description": "The object type, which is always `audio.voice_consent`."
  }),
  "id": Schema.String.annotate({ "description": "The consent recording identifier." }),
  "name": Schema.String.annotate({ "description": "The label provided when the consent recording was uploaded." }),
  "language": Schema.String.annotate({
    "description": "The BCP 47 language tag for the consent phrase (for example, `en-US`)."
  }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the consent recording was created."
  }).check(Schema.isInt())
}).annotate({
  "title": "Voice consent",
  "description": "A consent recording used to authorize creation of a custom voice."
})
export type VoiceIdsShared =
  | string
  | "alloy"
  | "ash"
  | "ballad"
  | "coral"
  | "echo"
  | "sage"
  | "shimmer"
  | "verse"
  | "marin"
  | "cedar"
export const VoiceIdsShared = Schema.Union([
  Schema.String,
  Schema.Literals(["alloy", "ash", "ballad", "coral", "echo", "sage", "shimmer", "verse", "marin", "cedar"])
])
export type VoiceResource = {
  readonly "object": "audio.voice"
  readonly "id": string
  readonly "name": string
  readonly "created_at": number
}
export const VoiceResource = Schema.Struct({
  "object": Schema.Literal("audio.voice").annotate({
    "description": "The object type, which is always `audio.voice`."
  }),
  "id": Schema.String.annotate({ "description": "The voice identifier, which can be referenced in API endpoints." }),
  "name": Schema.String.annotate({ "description": "The name of the voice." }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the voice was created."
  }).check(Schema.isInt())
}).annotate({ "title": "Voice", "description": "A custom voice that can be used for audio output." })
export type WebSearchActionFind = {
  readonly "type": "find_in_page"
  readonly "url": string
  readonly "pattern": string
}
export const WebSearchActionFind = Schema.Struct({
  "type": Schema.Literal("find_in_page").annotate({ "description": "The action type.\n" }),
  "url": Schema.String.annotate({ "description": "The URL of the page searched for the pattern.\n", "format": "uri" }),
  "pattern": Schema.String.annotate({ "description": "The pattern or text to search for within the page.\n" })
}).annotate({
  "title": "Find action",
  "description": "Action type \"find_in_page\": Searches for a pattern within a loaded page.\n"
})
export type WebSearchActionOpenPage = { readonly "type": "open_page"; readonly "url"?: string | null }
export const WebSearchActionOpenPage = Schema.Struct({
  "type": Schema.Literal("open_page").annotate({ "description": "The action type.\n" }),
  "url": Schema.optionalKey(
    Schema.Union([Schema.String.annotate({ "format": "uri" }), Schema.Null]).annotate({
      "description": "The URL opened by the model.\n"
    })
  )
}).annotate({
  "title": "Open page action",
  "description": "Action type \"open_page\" - Opens a specific URL from search results.\n"
})
export type WebSearchActionSearch = {
  readonly "type": "search"
  readonly "query"?: string
  readonly "queries"?: ReadonlyArray<string>
  readonly "sources"?: ReadonlyArray<{ readonly "type": "url"; readonly "url": string }>
}
export const WebSearchActionSearch = Schema.Struct({
  "type": Schema.Literal("search").annotate({ "description": "The action type.\n" }),
  "query": Schema.optionalKey(Schema.String.annotate({ "description": "[DEPRECATED] The search query.\n" })),
  "queries": Schema.optionalKey(
    Schema.Array(Schema.String.annotate({ "description": "A search query.\n" })).annotate({
      "title": "Search queries",
      "description": "The search queries.\n"
    })
  ),
  "sources": Schema.optionalKey(
    Schema.Array(
      Schema.Struct({
        "type": Schema.Literal("url").annotate({ "description": "The type of source. Always `url`.\n" }),
        "url": Schema.String.annotate({ "description": "The URL of the source.\n" })
      }).annotate({ "title": "Web search source", "description": "A source used in the search.\n" })
    ).annotate({ "title": "Web search sources", "description": "The sources used in the search.\n" })
  )
}).annotate({ "title": "Search action", "description": "Action type \"search\" - Performs a web search query.\n" })
export type WebSearchApproximateLocation = {
  readonly "type"?: "approximate"
  readonly "country"?: string | null
  readonly "region"?: string | null
  readonly "city"?: string | null
  readonly "timezone"?: string | null
} | null
export const WebSearchApproximateLocation = Schema.Union([
  Schema.Struct({
    "type": Schema.optionalKey(
      Schema.Literal("approximate").annotate({
        "description": "The type of location approximation. Always `approximate`."
      })
    ),
    "country": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description":
            "The two-letter [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1) of the user, e.g. `US`."
        }),
        Schema.Null
      ])
    ),
    "region": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({ "description": "Free text input for the region of the user, e.g. `California`." }),
        Schema.Null
      ])
    ),
    "city": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({ "description": "Free text input for the city of the user, e.g. `San Francisco`." }),
        Schema.Null
      ])
    ),
    "timezone": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description":
            "The [IANA timezone](https://timeapi.io/documentation/iana-timezones) of the user, e.g. `America/Los_Angeles`."
        }),
        Schema.Null
      ])
    )
  }).annotate({ "title": "Web search approximate location", "description": "The approximate location of the user.\n" }),
  Schema.Null
])
export type WebSearchContextSize = "low" | "medium" | "high"
export const WebSearchContextSize = Schema.Literals(["low", "medium", "high"]).annotate({
  "description":
    "High level guidance for the amount of context window space to use for the \nsearch. One of `low`, `medium`, or `high`. `medium` is the default.\n"
})
export type SkillReferenceParam = {
  readonly "type": "skill_reference"
  readonly "skill_id": string
  readonly "version"?: string
}
export const SkillReferenceParam = Schema.Struct({
  "type": Schema.Literal("skill_reference").annotate({
    "description": "References a skill created with the /v1/skills endpoint."
  }),
  "skill_id": Schema.String.annotate({ "description": "The ID of the referenced skill." }).check(Schema.isMinLength(1))
    .check(Schema.isMaxLength(64)),
  "version": Schema.optionalKey(
    Schema.String.annotate({
      "description": "Optional skill version. Use a positive integer or 'latest'. Omit for default."
    })
  )
})
export type InlineSkillParam = {
  readonly "type": "inline"
  readonly "name": string
  readonly "description": string
  readonly "source": { readonly "type": "base64"; readonly "media_type": "application/zip"; readonly "data": string }
}
export const InlineSkillParam = Schema.Struct({
  "type": Schema.Literal("inline").annotate({ "description": "Defines an inline skill for this request." }),
  "name": Schema.String.annotate({ "description": "The name of the skill." }),
  "description": Schema.String.annotate({ "description": "The description of the skill." }),
  "source": Schema.Struct({
    "type": Schema.Literal("base64").annotate({
      "description": "The type of the inline skill source. Must be `base64`."
    }),
    "media_type": Schema.Literal("application/zip").annotate({
      "description": "The media type of the inline skill payload. Must be `application/zip`."
    }),
    "data": Schema.String.annotate({ "description": "Base64-encoded skill zip bundle." }).check(Schema.isMinLength(1))
      .check(Schema.isMaxLength(70254592))
  }).annotate({ "description": "Inline skill payload" })
})
export type ContainerNetworkPolicyDisabledParam = { readonly "type": "disabled" }
export const ContainerNetworkPolicyDisabledParam = Schema.Struct({
  "type": Schema.Literal("disabled").annotate({ "description": "Disable outbound network access. Always `disabled`." })
})
export type ContainerNetworkPolicyDomainSecretParam = {
  readonly "domain": string
  readonly "name": string
  readonly "value": string
}
export const ContainerNetworkPolicyDomainSecretParam = Schema.Struct({
  "domain": Schema.String.annotate({ "description": "The domain associated with the secret." }).check(
    Schema.isMinLength(1)
  ),
  "name": Schema.String.annotate({ "description": "The name of the secret to inject for the domain." }).check(
    Schema.isMinLength(1)
  ),
  "value": Schema.String.annotate({ "description": "The secret value to inject for the domain." }).check(
    Schema.isMinLength(1)
  ).check(Schema.isMaxLength(10485760))
})
export type IncludeEnum =
  | "file_search_call.results"
  | "web_search_call.results"
  | "web_search_call.action.sources"
  | "message.input_image.image_url"
  | "computer_call_output.output.image_url"
  | "code_interpreter_call.outputs"
  | "reasoning.encrypted_content"
  | "message.output_text.logprobs"
export const IncludeEnum = Schema.Literals([
  "file_search_call.results",
  "web_search_call.results",
  "web_search_call.action.sources",
  "message.input_image.image_url",
  "computer_call_output.output.image_url",
  "code_interpreter_call.outputs",
  "reasoning.encrypted_content",
  "message.output_text.logprobs"
]).annotate({
  "description":
    "Specify additional output data to include in the model response. Currently supported values are:\n- `web_search_call.action.sources`: Include the sources of the web search tool call.\n- `code_interpreter_call.outputs`: Includes the outputs of python code execution in code interpreter tool call items.\n- `computer_call_output.output.image_url`: Include image urls from the computer call output.\n- `file_search_call.results`: Include the search results of the file search tool call.\n- `message.input_image.image_url`: Include image urls from the input message.\n- `message.output_text.logprobs`: Include logprobs with assistant messages.\n- `reasoning.encrypted_content`: Includes an encrypted version of reasoning tokens in reasoning item outputs. This enables reasoning items to be used in multi-turn conversations when using the Responses API statelessly (like when the `store` parameter is set to `false`, or when an organization is enrolled in the zero data retention program)."
})
export type InputTextContent = { readonly "type": "input_text"; readonly "text": string }
export const InputTextContent = Schema.Struct({
  "type": Schema.Literal("input_text").annotate({ "description": "The type of the input item. Always `input_text`." }),
  "text": Schema.String.annotate({ "description": "The text input to the model." })
}).annotate({ "title": "Input text", "description": "A text input to the model." })
export type FileCitationBody = {
  readonly "type": "file_citation"
  readonly "file_id": string
  readonly "index": number
  readonly "filename": string
}
export const FileCitationBody = Schema.Struct({
  "type": Schema.Literal("file_citation").annotate({
    "description": "The type of the file citation. Always `file_citation`."
  }),
  "file_id": Schema.String.annotate({ "description": "The ID of the file." }),
  "index": Schema.Number.annotate({ "description": "The index of the file in the list of files." }).check(
    Schema.isInt()
  ),
  "filename": Schema.String.annotate({ "description": "The filename of the file cited." })
}).annotate({ "title": "File citation", "description": "A citation to a file." })
export type UrlCitationBody = {
  readonly "type": "url_citation"
  readonly "url": string
  readonly "start_index": number
  readonly "end_index": number
  readonly "title": string
}
export const UrlCitationBody = Schema.Struct({
  "type": Schema.Literal("url_citation").annotate({
    "description": "The type of the URL citation. Always `url_citation`."
  }),
  "url": Schema.String.annotate({ "description": "The URL of the web resource." }),
  "start_index": Schema.Number.annotate({
    "description": "The index of the first character of the URL citation in the message."
  }).check(Schema.isInt()),
  "end_index": Schema.Number.annotate({
    "description": "The index of the last character of the URL citation in the message."
  }).check(Schema.isInt()),
  "title": Schema.String.annotate({ "description": "The title of the web resource." })
}).annotate({
  "title": "URL citation",
  "description": "A citation for a web resource used to generate a model response."
})
export type ContainerFileCitationBody = {
  readonly "type": "container_file_citation"
  readonly "container_id": string
  readonly "file_id": string
  readonly "start_index": number
  readonly "end_index": number
  readonly "filename": string
}
export const ContainerFileCitationBody = Schema.Struct({
  "type": Schema.Literal("container_file_citation").annotate({
    "description": "The type of the container file citation. Always `container_file_citation`."
  }),
  "container_id": Schema.String.annotate({ "description": "The ID of the container file." }),
  "file_id": Schema.String.annotate({ "description": "The ID of the file." }),
  "start_index": Schema.Number.annotate({
    "description": "The index of the first character of the container file citation in the message."
  }).check(Schema.isInt()),
  "end_index": Schema.Number.annotate({
    "description": "The index of the last character of the container file citation in the message."
  }).check(Schema.isInt()),
  "filename": Schema.String.annotate({ "description": "The filename of the container file cited." })
}).annotate({
  "title": "Container file citation",
  "description": "A citation for a container file used to generate a model response."
})
export type TopLogProb = {
  readonly "token": string
  readonly "logprob": number
  readonly "bytes": ReadonlyArray<number>
}
export const TopLogProb = Schema.Struct({
  "token": Schema.String,
  "logprob": Schema.Number.check(Schema.isFinite()),
  "bytes": Schema.Array(Schema.Number.check(Schema.isInt()))
}).annotate({ "title": "Top log probability", "description": "The top log probability of a token." })
export type TextContent = { readonly "type": "text"; readonly "text": string }
export const TextContent = Schema.Struct({ "type": Schema.Literal("text"), "text": Schema.String }).annotate({
  "title": "Text Content",
  "description": "A text content."
})
export type SummaryTextContent = { readonly "type": "summary_text"; readonly "text": string }
export const SummaryTextContent = Schema.Struct({
  "type": Schema.Literal("summary_text").annotate({ "description": "The type of the object. Always `summary_text`." }),
  "text": Schema.String.annotate({ "description": "A summary of the reasoning output from the model so far." })
}).annotate({ "title": "Summary text", "description": "A summary text from the model." })
export type ReasoningTextContent = { readonly "type": "reasoning_text"; readonly "text": string }
export const ReasoningTextContent = Schema.Struct({
  "type": Schema.Literal("reasoning_text").annotate({
    "description": "The type of the reasoning text. Always `reasoning_text`."
  }),
  "text": Schema.String.annotate({ "description": "The reasoning text from the model." })
}).annotate({ "title": "Reasoning text", "description": "Reasoning text from the model." })
export type RefusalContent = { readonly "type": "refusal"; readonly "refusal": string }
export const RefusalContent = Schema.Struct({
  "type": Schema.Literal("refusal").annotate({ "description": "The type of the refusal. Always `refusal`." }),
  "refusal": Schema.String.annotate({ "description": "The refusal explanation from the model." })
}).annotate({ "title": "Refusal", "description": "A refusal from the model." })
export type InputImageContent = {
  readonly "type": "input_image"
  readonly "image_url"?: string | null
  readonly "file_id"?: string | null
  readonly "detail": "low" | "high" | "auto"
}
export const InputImageContent = Schema.Struct({
  "type": Schema.Literal("input_image").annotate({
    "description": "The type of the input item. Always `input_image`."
  }),
  "image_url": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL."
      }),
      Schema.Null
    ])
  ),
  "file_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "The ID of the file to be sent to the model." }),
      Schema.Null
    ])
  ),
  "detail": Schema.Literals(["low", "high", "auto"]).annotate({
    "description":
      "The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`."
  })
}).annotate({
  "title": "Input image",
  "description": "An image input to the model. Learn about [image inputs](/docs/guides/vision)."
})
export type ComputerScreenshotContent = {
  readonly "type": "computer_screenshot"
  readonly "image_url": string | null
  readonly "file_id": string | null
}
export const ComputerScreenshotContent = Schema.Struct({
  "type": Schema.Literal("computer_screenshot").annotate({
    "description":
      "Specifies the event type. For a computer screenshot, this property is always set to `computer_screenshot`."
  }),
  "image_url": Schema.Union([
    Schema.String.annotate({ "description": "The URL of the screenshot image." }),
    Schema.Null
  ]),
  "file_id": Schema.Union([
    Schema.String.annotate({ "description": "The identifier of an uploaded file that contains the screenshot." }),
    Schema.Null
  ])
}).annotate({ "title": "Computer screenshot", "description": "A screenshot of a computer." })
export type InputFileContent = {
  readonly "type": "input_file"
  readonly "file_id"?: string | null
  readonly "filename"?: string
  readonly "file_url"?: string
  readonly "file_data"?: string
}
export const InputFileContent = Schema.Struct({
  "type": Schema.Literal("input_file").annotate({ "description": "The type of the input item. Always `input_file`." }),
  "file_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "The ID of the file to be sent to the model." }),
      Schema.Null
    ])
  ),
  "filename": Schema.optionalKey(
    Schema.String.annotate({ "description": "The name of the file to be sent to the model." })
  ),
  "file_url": Schema.optionalKey(
    Schema.String.annotate({ "description": "The URL of the file to be sent to the model." })
  ),
  "file_data": Schema.optionalKey(
    Schema.String.annotate({ "description": "The content of the file to be sent to the model.\n" })
  )
}).annotate({ "title": "Input file", "description": "A file input to the model." })
export type ClickParam = {
  readonly "type": "click"
  readonly "button": "left" | "right" | "wheel" | "back" | "forward"
  readonly "x": number
  readonly "y": number
}
export const ClickParam = Schema.Struct({
  "type": Schema.Literal("click").annotate({
    "description": "Specifies the event type. For a click action, this property is always `click`."
  }),
  "button": Schema.Literals(["left", "right", "wheel", "back", "forward"]).annotate({
    "description":
      "Indicates which mouse button was pressed during the click. One of `left`, `right`, `wheel`, `back`, or `forward`."
  }),
  "x": Schema.Number.annotate({ "description": "The x-coordinate where the click occurred." }).check(Schema.isInt()),
  "y": Schema.Number.annotate({ "description": "The y-coordinate where the click occurred." }).check(Schema.isInt())
}).annotate({ "title": "Click", "description": "A click action." })
export type DoubleClickAction = { readonly "type": "double_click"; readonly "x": number; readonly "y": number }
export const DoubleClickAction = Schema.Struct({
  "type": Schema.Literal("double_click").annotate({
    "description": "Specifies the event type. For a double click action, this property is always set to `double_click`."
  }),
  "x": Schema.Number.annotate({ "description": "The x-coordinate where the double click occurred." }).check(
    Schema.isInt()
  ),
  "y": Schema.Number.annotate({ "description": "The y-coordinate where the double click occurred." }).check(
    Schema.isInt()
  )
}).annotate({ "title": "DoubleClick", "description": "A double click action." })
export type CoordParam = { readonly "x": number; readonly "y": number }
export const CoordParam = Schema.Struct({
  "x": Schema.Number.annotate({ "description": "The x-coordinate." }).check(Schema.isInt()),
  "y": Schema.Number.annotate({ "description": "The y-coordinate." }).check(Schema.isInt())
}).annotate({ "title": "Coordinate", "description": "An x/y coordinate pair, e.g. `{ x: 100, y: 200 }`." })
export type KeyPressAction = { readonly "type": "keypress"; readonly "keys": ReadonlyArray<string> }
export const KeyPressAction = Schema.Struct({
  "type": Schema.Literal("keypress").annotate({
    "description": "Specifies the event type. For a keypress action, this property is always set to `keypress`."
  }),
  "keys": Schema.Array(
    Schema.String.annotate({ "description": "One of the keys the model is requesting to be pressed." })
  ).annotate({
    "description":
      "The combination of keys the model is requesting to be pressed. This is an array of strings, each representing a key."
  })
}).annotate({ "title": "KeyPress", "description": "A collection of keypresses the model would like to perform." })
export type MoveParam = { readonly "type": "move"; readonly "x": number; readonly "y": number }
export const MoveParam = Schema.Struct({
  "type": Schema.Literal("move").annotate({
    "description": "Specifies the event type. For a move action, this property is always set to `move`."
  }),
  "x": Schema.Number.annotate({ "description": "The x-coordinate to move to." }).check(Schema.isInt()),
  "y": Schema.Number.annotate({ "description": "The y-coordinate to move to." }).check(Schema.isInt())
}).annotate({ "title": "Move", "description": "A mouse move action." })
export type ScreenshotParam = { readonly "type": "screenshot" }
export const ScreenshotParam = Schema.Struct({
  "type": Schema.Literal("screenshot").annotate({
    "description": "Specifies the event type. For a screenshot action, this property is always set to `screenshot`."
  })
}).annotate({ "title": "Screenshot", "description": "A screenshot action." })
export type ScrollParam = {
  readonly "type": "scroll"
  readonly "x": number
  readonly "y": number
  readonly "scroll_x": number
  readonly "scroll_y": number
}
export const ScrollParam = Schema.Struct({
  "type": Schema.Literal("scroll").annotate({
    "description": "Specifies the event type. For a scroll action, this property is always set to `scroll`."
  }),
  "x": Schema.Number.annotate({ "description": "The x-coordinate where the scroll occurred." }).check(Schema.isInt()),
  "y": Schema.Number.annotate({ "description": "The y-coordinate where the scroll occurred." }).check(Schema.isInt()),
  "scroll_x": Schema.Number.annotate({ "description": "The horizontal scroll distance." }).check(Schema.isInt()),
  "scroll_y": Schema.Number.annotate({ "description": "The vertical scroll distance." }).check(Schema.isInt())
}).annotate({ "title": "Scroll", "description": "A scroll action." })
export type TypeParam = { readonly "type": "type"; readonly "text": string }
export const TypeParam = Schema.Struct({
  "type": Schema.Literal("type").annotate({
    "description": "Specifies the event type. For a type action, this property is always set to `type`."
  }),
  "text": Schema.String.annotate({ "description": "The text to type." })
}).annotate({ "title": "Type", "description": "An action to type in text." })
export type WaitParam = { readonly "type": "wait" }
export const WaitParam = Schema.Struct({
  "type": Schema.Literal("wait").annotate({
    "description": "Specifies the event type. For a wait action, this property is always set to `wait`."
  })
}).annotate({ "title": "Wait", "description": "A wait action." })
export type ComputerCallSafetyCheckParam = {
  readonly "id": string
  readonly "code"?: string | null
  readonly "message"?: string | null
}
export const ComputerCallSafetyCheckParam = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The ID of the pending safety check." }),
  "code": Schema.optionalKey(
    Schema.Union([Schema.String.annotate({ "description": "The type of the pending safety check." }), Schema.Null])
  ),
  "message": Schema.optionalKey(
    Schema.Union([Schema.String.annotate({ "description": "Details about the pending safety check." }), Schema.Null])
  )
}).annotate({ "description": "A pending safety check for the computer call." })
export type CodeInterpreterOutputLogs = { readonly "type": "logs"; readonly "logs": string }
export const CodeInterpreterOutputLogs = Schema.Struct({
  "type": Schema.Literal("logs").annotate({ "description": "The type of the output. Always `logs`." }),
  "logs": Schema.String.annotate({ "description": "The logs output from the code interpreter." })
}).annotate({ "title": "Code interpreter output logs", "description": "The logs output from the code interpreter." })
export type CodeInterpreterOutputImage = { readonly "type": "image"; readonly "url": string }
export const CodeInterpreterOutputImage = Schema.Struct({
  "type": Schema.Literal("image").annotate({ "description": "The type of the output. Always `image`." }),
  "url": Schema.String.annotate({ "description": "The URL of the image output from the code interpreter." })
}).annotate({ "title": "Code interpreter output image", "description": "The image output from the code interpreter." })
export type LocalShellExecAction = {
  readonly "type": "exec"
  readonly "command": ReadonlyArray<string>
  readonly "timeout_ms"?: number | null
  readonly "working_directory"?: string | null
  readonly "env": {}
  readonly "user"?: string | null
}
export const LocalShellExecAction = Schema.Struct({
  "type": Schema.Literal("exec").annotate({ "description": "The type of the local shell action. Always `exec`." }),
  "command": Schema.Array(Schema.String).annotate({ "description": "The command to run." }),
  "timeout_ms": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({ "description": "Optional timeout in milliseconds for the command." }).check(
        Schema.isInt()
      ),
      Schema.Null
    ])
  ),
  "working_directory": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "Optional working directory to run the command in." }),
      Schema.Null
    ])
  ),
  "env": Schema.Struct({}).annotate({ "description": "Environment variables to set for the command." }),
  "user": Schema.optionalKey(
    Schema.Union([Schema.String.annotate({ "description": "Optional user to run the command as." }), Schema.Null])
  )
}).annotate({ "title": "Local shell exec action", "description": "Execute a shell command on the server." })
export type LocalEnvironmentResource = { readonly "type": "local" }
export const LocalEnvironmentResource = Schema.Struct({
  "type": Schema.Literal("local").annotate({ "description": "The environment type. Always `local`." })
}).annotate({
  "title": "Local Environment",
  "description": "Represents the use of a local environment to perform shell actions."
})
export type ContainerReferenceResource = { readonly "type": "container_reference"; readonly "container_id": string }
export const ContainerReferenceResource = Schema.Struct({
  "type": Schema.Literal("container_reference").annotate({
    "description": "The environment type. Always `container_reference`."
  }),
  "container_id": Schema.String
}).annotate({ "title": "Container Reference", "description": "Represents a container created with /v1/containers." })
export type FunctionShellCallOutputTimeoutOutcome = { readonly "type": "timeout" }
export const FunctionShellCallOutputTimeoutOutcome = Schema.Struct({
  "type": Schema.Literal("timeout").annotate({ "description": "The outcome type. Always `timeout`." })
}).annotate({
  "title": "Shell call timeout outcome",
  "description": "Indicates that the shell call exceeded its configured time limit."
})
export type FunctionShellCallOutputExitOutcome = { readonly "type": "exit"; readonly "exit_code": number }
export const FunctionShellCallOutputExitOutcome = Schema.Struct({
  "type": Schema.Literal("exit").annotate({ "description": "The outcome type. Always `exit`." }),
  "exit_code": Schema.Number.annotate({ "description": "Exit code from the shell process." }).check(Schema.isInt())
}).annotate({
  "title": "Shell call exit outcome",
  "description": "Indicates that the shell commands finished and returned an exit code."
})
export type ApplyPatchCreateFileOperation = {
  readonly "type": "create_file"
  readonly "path": string
  readonly "diff": string
}
export const ApplyPatchCreateFileOperation = Schema.Struct({
  "type": Schema.Literal("create_file").annotate({ "description": "Create a new file with the provided diff." }),
  "path": Schema.String.annotate({ "description": "Path of the file to create." }),
  "diff": Schema.String.annotate({ "description": "Diff to apply." })
}).annotate({
  "title": "Apply patch create file operation",
  "description": "Instruction describing how to create a file via the apply_patch tool."
})
export type ApplyPatchDeleteFileOperation = { readonly "type": "delete_file"; readonly "path": string }
export const ApplyPatchDeleteFileOperation = Schema.Struct({
  "type": Schema.Literal("delete_file").annotate({ "description": "Delete the specified file." }),
  "path": Schema.String.annotate({ "description": "Path of the file to delete." })
}).annotate({
  "title": "Apply patch delete file operation",
  "description": "Instruction describing how to delete a file via the apply_patch tool."
})
export type ApplyPatchUpdateFileOperation = {
  readonly "type": "update_file"
  readonly "path": string
  readonly "diff": string
}
export const ApplyPatchUpdateFileOperation = Schema.Struct({
  "type": Schema.Literal("update_file").annotate({ "description": "Update an existing file with the provided diff." }),
  "path": Schema.String.annotate({ "description": "Path of the file to update." }),
  "diff": Schema.String.annotate({ "description": "Diff to apply." })
}).annotate({
  "title": "Apply patch update file operation",
  "description": "Instruction describing how to update a file via the apply_patch tool."
})
export type ApplyPatchToolCallOutput = {
  readonly "type": "apply_patch_call_output"
  readonly "id": string
  readonly "call_id": string
  readonly "status": "completed" | "failed"
  readonly "output"?: string | null
  readonly "created_by"?: string
}
export const ApplyPatchToolCallOutput = Schema.Struct({
  "type": Schema.Literal("apply_patch_call_output").annotate({
    "description": "The type of the item. Always `apply_patch_call_output`."
  }),
  "id": Schema.String.annotate({
    "description": "The unique ID of the apply patch tool call output. Populated when this item is returned via API."
  }),
  "call_id": Schema.String.annotate({
    "description": "The unique ID of the apply patch tool call generated by the model."
  }),
  "status": Schema.Literals(["completed", "failed"]).annotate({
    "description": "The status of the apply patch tool call output. One of `completed` or `failed`."
  }),
  "output": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "Optional textual output returned by the apply patch tool." }),
      Schema.Null
    ])
  ),
  "created_by": Schema.optionalKey(
    Schema.String.annotate({ "description": "The ID of the entity that created this tool call output." })
  )
}).annotate({
  "title": "Apply patch tool call output",
  "description": "The output emitted by an apply patch tool call."
})
export type InputTextContentParam = { readonly "type": "input_text"; readonly "text": string }
export const InputTextContentParam = Schema.Struct({
  "type": Schema.Literal("input_text").annotate({ "description": "The type of the input item. Always `input_text`." }),
  "text": Schema.String.annotate({ "description": "The text input to the model." }).check(Schema.isMaxLength(10485760))
}).annotate({ "title": "Input text", "description": "A text input to the model." })
export type InputImageContentParamAutoParam = {
  readonly "type": "input_image"
  readonly "image_url"?: string | null
  readonly "file_id"?: string | null
  readonly "detail"?: "low" | "high" | "auto" | null
}
export const InputImageContentParamAutoParam = Schema.Struct({
  "type": Schema.Literal("input_image").annotate({
    "description": "The type of the input item. Always `input_image`."
  }),
  "image_url": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL."
      }).check(Schema.isMaxLength(20971520)),
      Schema.Null
    ])
  ),
  "file_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "The ID of the file to be sent to the model." }),
      Schema.Null
    ])
  ),
  "detail": Schema.optionalKey(
    Schema.Union([
      Schema.Literals(["low", "high", "auto"]).annotate({
        "description":
          "The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`."
      }),
      Schema.Null
    ])
  )
}).annotate({
  "title": "Input image",
  "description": "An image input to the model. Learn about [image inputs](/docs/guides/vision)"
})
export type InputFileContentParam = {
  readonly "type": "input_file"
  readonly "file_id"?: string | null
  readonly "filename"?: string | null
  readonly "file_data"?: string | null
  readonly "file_url"?: string | null
}
export const InputFileContentParam = Schema.Struct({
  "type": Schema.Literal("input_file").annotate({ "description": "The type of the input item. Always `input_file`." }),
  "file_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "The ID of the file to be sent to the model." }),
      Schema.Null
    ])
  ),
  "filename": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "The name of the file to be sent to the model." }),
      Schema.Null
    ])
  ),
  "file_data": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "The base64-encoded data of the file to be sent to the model." }).check(
        Schema.isMaxLength(33554432)
      ),
      Schema.Null
    ])
  ),
  "file_url": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "The URL of the file to be sent to the model." }),
      Schema.Null
    ])
  )
}).annotate({ "title": "Input file", "description": "A file input to the model." })
export type CompactionSummaryItemParam = {
  readonly "id"?: string | null
  readonly "type": "compaction"
  readonly "encrypted_content": string
}
export const CompactionSummaryItemParam = Schema.Struct({
  "id": Schema.optionalKey(
    Schema.Union([Schema.String.annotate({ "description": "The ID of the compaction item." }), Schema.Null])
  ),
  "type": Schema.Literal("compaction").annotate({ "description": "The type of the item. Always `compaction`." }),
  "encrypted_content": Schema.String.annotate({ "description": "The encrypted content of the compaction summary." })
    .check(Schema.isMaxLength(10485760))
}).annotate({
  "title": "Compaction item",
  "description":
    "A compaction item generated by the [`v1/responses/compact` API](/docs/api-reference/responses/compact)."
})
export type LocalSkillParam = { readonly "name": string; readonly "description": string; readonly "path": string }
export const LocalSkillParam = Schema.Struct({
  "name": Schema.String.annotate({ "description": "The name of the skill." }),
  "description": Schema.String.annotate({ "description": "The description of the skill." }),
  "path": Schema.String.annotate({ "description": "The path to the directory containing the skill." })
})
export type ContainerReferenceParam = { readonly "type": "container_reference"; readonly "container_id": string }
export const ContainerReferenceParam = Schema.Struct({
  "type": Schema.Literal("container_reference").annotate({
    "description": "References a container created with the /v1/containers endpoint"
  }),
  "container_id": Schema.String.annotate({ "description": "The ID of the referenced container." })
})
export type FunctionShellCallOutputTimeoutOutcomeParam = { readonly "type": "timeout" }
export const FunctionShellCallOutputTimeoutOutcomeParam = Schema.Struct({
  "type": Schema.Literal("timeout").annotate({ "description": "The outcome type. Always `timeout`." })
}).annotate({
  "title": "Shell call timeout outcome",
  "description": "Indicates that the shell call exceeded its configured time limit."
})
export type FunctionShellCallOutputExitOutcomeParam = { readonly "type": "exit"; readonly "exit_code": number }
export const FunctionShellCallOutputExitOutcomeParam = Schema.Struct({
  "type": Schema.Literal("exit").annotate({ "description": "The outcome type. Always `exit`." }),
  "exit_code": Schema.Number.annotate({ "description": "The exit code returned by the shell process." }).check(
    Schema.isInt()
  )
}).annotate({
  "title": "Shell call exit outcome",
  "description": "Indicates that the shell commands finished and returned an exit code."
})
export type ApplyPatchCreateFileOperationParam = {
  readonly "type": "create_file"
  readonly "path": string
  readonly "diff": string
}
export const ApplyPatchCreateFileOperationParam = Schema.Struct({
  "type": Schema.Literal("create_file").annotate({ "description": "The operation type. Always `create_file`." }),
  "path": Schema.String.annotate({ "description": "Path of the file to create relative to the workspace root." }).check(
    Schema.isMinLength(1)
  ),
  "diff": Schema.String.annotate({ "description": "Unified diff content to apply when creating the file." }).check(
    Schema.isMaxLength(10485760)
  )
}).annotate({
  "title": "Apply patch create file operation",
  "description": "Instruction for creating a new file via the apply_patch tool."
})
export type ApplyPatchDeleteFileOperationParam = { readonly "type": "delete_file"; readonly "path": string }
export const ApplyPatchDeleteFileOperationParam = Schema.Struct({
  "type": Schema.Literal("delete_file").annotate({ "description": "The operation type. Always `delete_file`." }),
  "path": Schema.String.annotate({ "description": "Path of the file to delete relative to the workspace root." }).check(
    Schema.isMinLength(1)
  )
}).annotate({
  "title": "Apply patch delete file operation",
  "description": "Instruction for deleting an existing file via the apply_patch tool."
})
export type ApplyPatchUpdateFileOperationParam = {
  readonly "type": "update_file"
  readonly "path": string
  readonly "diff": string
}
export const ApplyPatchUpdateFileOperationParam = Schema.Struct({
  "type": Schema.Literal("update_file").annotate({ "description": "The operation type. Always `update_file`." }),
  "path": Schema.String.annotate({ "description": "Path of the file to update relative to the workspace root." }).check(
    Schema.isMinLength(1)
  ),
  "diff": Schema.String.annotate({ "description": "Unified diff content to apply to the existing file." }).check(
    Schema.isMaxLength(10485760)
  )
}).annotate({
  "title": "Apply patch update file operation",
  "description": "Instruction for updating an existing file via the apply_patch tool."
})
export type ApplyPatchToolCallOutputItemParam = {
  readonly "type": "apply_patch_call_output"
  readonly "id"?: string | null
  readonly "call_id": string
  readonly "status": "completed" | "failed"
  readonly "output"?: string | null
}
export const ApplyPatchToolCallOutputItemParam = Schema.Struct({
  "type": Schema.Literal("apply_patch_call_output").annotate({
    "description": "The type of the item. Always `apply_patch_call_output`."
  }),
  "id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "The unique ID of the apply patch tool call output. Populated when this item is returned via API."
      }),
      Schema.Null
    ])
  ),
  "call_id": Schema.String.annotate({
    "description": "The unique ID of the apply patch tool call generated by the model."
  }).check(Schema.isMinLength(1)).check(Schema.isMaxLength(64)),
  "status": Schema.Literals(["completed", "failed"]).annotate({
    "title": "Apply patch call output status",
    "description": "The status of the apply patch tool call output. One of `completed` or `failed`."
  }),
  "output": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "Optional human-readable log text from the apply patch tool (e.g., patch results or errors)."
      }).check(Schema.isMaxLength(10485760)),
      Schema.Null
    ])
  )
}).annotate({
  "title": "Apply patch tool call output",
  "description": "The streamed output emitted by an apply patch tool call."
})
export type ItemReferenceParam = { readonly "type"?: "item_reference" | null; readonly "id": string }
export const ItemReferenceParam = Schema.Struct({
  "type": Schema.optionalKey(
    Schema.Union([
      Schema.Literal("item_reference").annotate({
        "description": "The type of item to reference. Always `item_reference`."
      }),
      Schema.Null
    ])
  ),
  "id": Schema.String.annotate({ "description": "The ID of the item to reference." })
}).annotate({ "title": "Item reference", "description": "An internal identifier for an item to reference." })
export type ConversationResource = {
  readonly "id": string
  readonly "object": "conversation"
  readonly "metadata": unknown
  readonly "created_at": number
}
export const ConversationResource = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The unique ID of the conversation." }),
  "object": Schema.Literal("conversation").annotate({
    "description": "The object type, which is always `conversation`."
  }),
  "metadata": Schema.Unknown.annotate({
    "description":
      "Set of 16 key-value pairs that can be attached to an object. This can be         useful for storing additional information about the object in a structured         format, and querying for objects via API or the dashboard.\n        Keys are strings with a maximum length of 64 characters. Values are strings         with a maximum length of 512 characters."
  }),
  "created_at": Schema.Number.annotate({
    "description": "The time at which the conversation was created, measured in seconds since the Unix epoch."
  }).check(Schema.isInt())
})
export type FunctionTool = {
  readonly "type": "function"
  readonly "name": string
  readonly "description"?: string | null
  readonly "parameters": {} | null
  readonly "strict": boolean | null
}
export const FunctionTool = Schema.Struct({
  "type": Schema.Literal("function").annotate({ "description": "The type of the function tool. Always `function`." }),
  "name": Schema.String.annotate({ "description": "The name of the function to call." }),
  "description": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "A description of the function. Used by the model to determine whether or not to call the function."
      }),
      Schema.Null
    ])
  ),
  "parameters": Schema.Union([
    Schema.Struct({}).annotate({ "description": "A JSON schema object describing the parameters of the function." }),
    Schema.Null
  ]),
  "strict": Schema.Union([
    Schema.Boolean.annotate({ "description": "Whether to enforce strict parameter validation. Default `true`." }),
    Schema.Null
  ])
}).annotate({
  "title": "Function",
  "description":
    "Defines a function in your own code the model can choose to call. Learn more about [function calling](https://platform.openai.com/docs/guides/function-calling)."
})
export type ComputerUsePreviewTool = {
  readonly "type": "computer_use_preview"
  readonly "environment": "windows" | "mac" | "linux" | "ubuntu" | "browser"
  readonly "display_width": number
  readonly "display_height": number
}
export const ComputerUsePreviewTool = Schema.Struct({
  "type": Schema.Literal("computer_use_preview").annotate({
    "description": "The type of the computer use tool. Always `computer_use_preview`."
  }),
  "environment": Schema.Literals(["windows", "mac", "linux", "ubuntu", "browser"]).annotate({
    "description": "The type of computer environment to control."
  }),
  "display_width": Schema.Number.annotate({ "description": "The width of the computer display." }).check(
    Schema.isInt()
  ),
  "display_height": Schema.Number.annotate({ "description": "The height of the computer display." }).check(
    Schema.isInt()
  )
}).annotate({
  "title": "Computer use preview",
  "description":
    "A tool that controls a virtual computer. Learn more about the [computer tool](https://platform.openai.com/docs/guides/tools-computer-use)."
})
export type InputFidelity = "high" | "low"
export const InputFidelity = Schema.Literals(["high", "low"]).annotate({
  "description":
    "Control how much effort the model will exert to match the style and features, especially facial features, of input images. This parameter is only supported for `gpt-image-1` and `gpt-image-1.5` and later models, unsupported for `gpt-image-1-mini`. Supports `high` and `low`. Defaults to `low`."
})
export type LocalShellToolParam = { readonly "type": "local_shell" }
export const LocalShellToolParam = Schema.Struct({
  "type": Schema.Literal("local_shell").annotate({
    "description": "The type of the local shell tool. Always `local_shell`."
  })
}).annotate({
  "title": "Local shell tool",
  "description": "A tool that allows the model to execute shell commands in a local environment."
})
export type CustomTextFormatParam = { readonly "type": "text" }
export const CustomTextFormatParam = Schema.Struct({
  "type": Schema.Literal("text").annotate({ "description": "Unconstrained text format. Always `text`." })
}).annotate({ "title": "Text format", "description": "Unconstrained free-form text." })
export type CustomGrammarFormatParam = {
  readonly "type": "grammar"
  readonly "syntax": "lark" | "regex"
  readonly "definition": string
}
export const CustomGrammarFormatParam = Schema.Struct({
  "type": Schema.Literal("grammar").annotate({ "description": "Grammar format. Always `grammar`." }),
  "syntax": Schema.Literals(["lark", "regex"]).annotate({
    "description": "The syntax of the grammar definition. One of `lark` or `regex`."
  }),
  "definition": Schema.String.annotate({ "description": "The grammar definition." })
}).annotate({ "title": "Grammar format", "description": "A grammar defined by the user." })
export type WebSearchPreviewTool = {
  readonly "type": "web_search_preview" | "web_search_preview_2025_03_11"
  readonly "user_location"?: {
    readonly "type": "approximate"
    readonly "country"?: string | null
    readonly "region"?: string | null
    readonly "city"?: string | null
    readonly "timezone"?: string | null
  } | null
  readonly "search_context_size"?: "low" | "medium" | "high"
}
export const WebSearchPreviewTool = Schema.Struct({
  "type": Schema.Literals(["web_search_preview", "web_search_preview_2025_03_11"]).annotate({
    "description": "The type of the web search tool. One of `web_search_preview` or `web_search_preview_2025_03_11`."
  }),
  "user_location": Schema.optionalKey(Schema.Union([
    Schema.Struct({
      "type": Schema.Literal("approximate").annotate({
        "description": "The type of location approximation. Always `approximate`."
      }),
      "country": Schema.optionalKey(
        Schema.Union([
          Schema.String.annotate({
            "description":
              "The two-letter [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1) of the user, e.g. `US`."
          }),
          Schema.Null
        ])
      ),
      "region": Schema.optionalKey(
        Schema.Union([
          Schema.String.annotate({ "description": "Free text input for the region of the user, e.g. `California`." }),
          Schema.Null
        ])
      ),
      "city": Schema.optionalKey(
        Schema.Union([
          Schema.String.annotate({ "description": "Free text input for the city of the user, e.g. `San Francisco`." }),
          Schema.Null
        ])
      ),
      "timezone": Schema.optionalKey(
        Schema.Union([
          Schema.String.annotate({
            "description":
              "The [IANA timezone](https://timeapi.io/documentation/iana-timezones) of the user, e.g. `America/Los_Angeles`."
          }),
          Schema.Null
        ])
      )
    }).annotate({ "description": "The user's location." }),
    Schema.Null
  ])),
  "search_context_size": Schema.optionalKey(
    Schema.Literals(["low", "medium", "high"]).annotate({
      "description":
        "High level guidance for the amount of context window space to use for the search. One of `low`, `medium`, or `high`. `medium` is the default."
    })
  )
}).annotate({
  "title": "Web search preview",
  "description":
    "This tool searches the web for relevant results to use in a response. Learn more about the [web search tool](https://platform.openai.com/docs/guides/tools-web-search)."
})
export type ApplyPatchToolParam = { readonly "type": "apply_patch" }
export const ApplyPatchToolParam = Schema.Struct({
  "type": Schema.Literal("apply_patch").annotate({ "description": "The type of the tool. Always `apply_patch`." })
}).annotate({
  "title": "Apply patch tool",
  "description": "Allows the assistant to create, delete, or update files using unified diffs."
})
export type ImageGenOutputTokensDetails = { readonly "image_tokens": number; readonly "text_tokens": number }
export const ImageGenOutputTokensDetails = Schema.Struct({
  "image_tokens": Schema.Number.annotate({ "description": "The number of image output tokens generated by the model." })
    .check(Schema.isInt()),
  "text_tokens": Schema.Number.annotate({ "description": "The number of text output tokens generated by the model." })
    .check(Schema.isInt())
}).annotate({
  "title": "Image generation output token details",
  "description": "The output token details for the image generation."
})
export type ImageGenInputUsageDetails = { readonly "text_tokens": number; readonly "image_tokens": number }
export const ImageGenInputUsageDetails = Schema.Struct({
  "text_tokens": Schema.Number.annotate({ "description": "The number of text tokens in the input prompt." }).check(
    Schema.isInt()
  ),
  "image_tokens": Schema.Number.annotate({ "description": "The number of image tokens in the input prompt." }).check(
    Schema.isInt()
  )
}).annotate({
  "title": "Input usage details",
  "description": "The input tokens detailed information for the image generation."
})
export type SpecificApplyPatchParam = { readonly "type": "apply_patch" }
export const SpecificApplyPatchParam = Schema.Struct({
  "type": Schema.Literal("apply_patch").annotate({ "description": "The tool to call. Always `apply_patch`." })
}).annotate({
  "title": "Specific apply patch tool choice",
  "description": "Forces the model to call the apply_patch tool when executing a tool call."
})
export type SpecificFunctionShellParam = { readonly "type": "shell" }
export const SpecificFunctionShellParam = Schema.Struct({
  "type": Schema.Literal("shell").annotate({ "description": "The tool to call. Always `shell`." })
}).annotate({
  "title": "Specific shell tool choice",
  "description": "Forces the model to call the shell tool when a tool call is required."
})
export type ConversationParam_2 = { readonly "id": string }
export const ConversationParam_2 = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The unique ID of the conversation." })
}).annotate({ "title": "Conversation object", "description": "The conversation that this response belongs to." })
export type ContextManagementParam = { readonly "type": string; readonly "compact_threshold"?: number | null }
export const ContextManagementParam = Schema.Struct({
  "type": Schema.String.annotate({
    "description": "The context management entry type. Currently only 'compaction' is supported."
  }),
  "compact_threshold": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description": "Token threshold at which compaction should be triggered for this entry."
      }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1000)),
      Schema.Null
    ])
  )
})
export type CompactionBody = {
  readonly "type": "compaction"
  readonly "id": string
  readonly "encrypted_content": string
  readonly "created_by"?: string
}
export const CompactionBody = Schema.Struct({
  "type": Schema.Literal("compaction").annotate({ "description": "The type of the item. Always `compaction`." }),
  "id": Schema.String.annotate({ "description": "The unique ID of the compaction item." }),
  "encrypted_content": Schema.String.annotate({
    "description": "The encrypted content that was produced by compaction."
  }),
  "created_by": Schema.optionalKey(
    Schema.String.annotate({ "description": "The identifier of the actor that created the item." })
  )
}).annotate({
  "title": "Compaction item",
  "description":
    "A compaction item generated by the [`v1/responses/compact` API](/docs/api-reference/responses/compact)."
})
export type Conversation_2 = { readonly "id": string }
export const Conversation_2 = Schema.Struct({
  "id": Schema.String.annotate({
    "description": "The unique ID of the conversation that this response was associated with."
  })
}).annotate({
  "title": "Conversation",
  "description":
    "The conversation that this response belonged to. Input items and output items from this response were automatically added to this conversation."
})
export type UpdateConversationBody = { readonly "metadata": {} | null }
export const UpdateConversationBody = Schema.Struct({
  "metadata": Schema.Union([
    Schema.Struct({}).annotate({
      "description":
        "Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard.\n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n"
    }),
    Schema.Null
  ]).annotate({
    "description":
      "Set of 16 key-value pairs that can be attached to an object. This can be         useful for storing additional information about the object in a structured         format, and querying for objects via API or the dashboard.\n        Keys are strings with a maximum length of 64 characters. Values are strings         with a maximum length of 512 characters."
  })
})
export type DeletedConversationResource = {
  readonly "object": "conversation.deleted"
  readonly "deleted": boolean
  readonly "id": string
}
export const DeletedConversationResource = Schema.Struct({
  "object": Schema.Literal("conversation.deleted"),
  "deleted": Schema.Boolean,
  "id": Schema.String
})
export type OrderEnum = "asc" | "desc"
export const OrderEnum = Schema.Literals(["asc", "desc"])
export type VideoResource = {
  readonly "id": string
  readonly "object": "video"
  readonly "model":
    | string
    | "sora-2"
    | "sora-2-pro"
    | "sora-2-2025-10-06"
    | "sora-2-pro-2025-10-06"
    | "sora-2-2025-12-08"
  readonly "status": "queued" | "in_progress" | "completed" | "failed"
  readonly "progress": number
  readonly "created_at": number
  readonly "completed_at": number | null
  readonly "expires_at": number | null
  readonly "prompt": string | null
  readonly "size": "720x1280" | "1280x720" | "1024x1792" | "1792x1024"
  readonly "seconds": "4" | "8" | "12"
  readonly "remixed_from_video_id": string | null
  readonly "error": { readonly "code": string; readonly "message": string } | null
}
export const VideoResource = Schema.Struct({
  "id": Schema.String.annotate({ "description": "Unique identifier for the video job." }),
  "object": Schema.Literal("video").annotate({ "description": "The object type, which is always `video`." }),
  "model": Schema.Union([
    Schema.String,
    Schema.Literals(["sora-2", "sora-2-pro", "sora-2-2025-10-06", "sora-2-pro-2025-10-06", "sora-2-2025-12-08"])
  ]).annotate({ "description": "The video generation model that produced the job." }),
  "status": Schema.Literals(["queued", "in_progress", "completed", "failed"]).annotate({
    "description": "Current lifecycle status of the video job."
  }),
  "progress": Schema.Number.annotate({ "description": "Approximate completion percentage for the generation task." })
    .check(Schema.isInt()),
  "created_at": Schema.Number.annotate({ "description": "Unix timestamp (seconds) for when the job was created." })
    .check(Schema.isInt()),
  "completed_at": Schema.Union([
    Schema.Number.annotate({ "description": "Unix timestamp (seconds) for when the job completed, if finished." })
      .check(Schema.isInt()),
    Schema.Null
  ]),
  "expires_at": Schema.Union([
    Schema.Number.annotate({
      "description": "Unix timestamp (seconds) for when the downloadable assets expire, if set."
    }).check(Schema.isInt()),
    Schema.Null
  ]),
  "prompt": Schema.Union([
    Schema.String.annotate({ "description": "The prompt that was used to generate the video." }),
    Schema.Null
  ]),
  "size": Schema.Literals(["720x1280", "1280x720", "1024x1792", "1792x1024"]).annotate({
    "description": "The resolution of the generated video."
  }),
  "seconds": Schema.Literals(["4", "8", "12"]).annotate({
    "description": "Duration of the generated clip in seconds."
  }),
  "remixed_from_video_id": Schema.Union([
    Schema.String.annotate({ "description": "Identifier of the source video if this video is a remix." }),
    Schema.Null
  ]),
  "error": Schema.Union([
    Schema.Struct({
      "code": Schema.String.annotate({ "description": "A machine-readable error code that was returned." }),
      "message": Schema.String.annotate({
        "description": "A human-readable description of the error that was returned."
      })
    }).annotate({
      "title": "Error",
      "description": "Error payload that explains why generation failed, if applicable."
    }),
    Schema.Null
  ])
}).annotate({ "title": "Video job", "description": "Structured information describing a generated video job." })
export type CreateVideoBody = {
  readonly "model"?:
    | string
    | "sora-2"
    | "sora-2-pro"
    | "sora-2-2025-10-06"
    | "sora-2-pro-2025-10-06"
    | "sora-2-2025-12-08"
  readonly "prompt": string
  readonly "input_reference"?: string
  readonly "seconds"?: "4" | "8" | "12"
  readonly "size"?: "720x1280" | "1280x720" | "1024x1792" | "1792x1024"
}
export const CreateVideoBody = Schema.Struct({
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.String,
      Schema.Literals(["sora-2", "sora-2-pro", "sora-2-2025-10-06", "sora-2-pro-2025-10-06", "sora-2-2025-12-08"])
    ]).annotate({
      "description": "The video generation model to use (allowed values: sora-2, sora-2-pro). Defaults to `sora-2`."
    })
  ),
  "prompt": Schema.String.annotate({ "description": "Text prompt that describes the video to generate." }).check(
    Schema.isMinLength(1)
  ).check(Schema.isMaxLength(32000)),
  "input_reference": Schema.optionalKey(
    Schema.String.annotate({ "description": "Optional image reference that guides generation.", "format": "binary" })
  ),
  "seconds": Schema.optionalKey(
    Schema.Literals(["4", "8", "12"]).annotate({
      "description": "Clip duration in seconds (allowed values: 4, 8, 12). Defaults to 4 seconds."
    })
  ),
  "size": Schema.optionalKey(
    Schema.Literals(["720x1280", "1280x720", "1024x1792", "1792x1024"]).annotate({
      "description":
        "Output resolution formatted as width x height (allowed values: 720x1280, 1280x720, 1024x1792, 1792x1024). Defaults to 720x1280."
    })
  )
}).annotate({ "title": "Create video request", "description": "Parameters for creating a new video generation job." })
export type DeletedVideoResource = {
  readonly "object": "video.deleted"
  readonly "deleted": boolean
  readonly "id": string
}
export const DeletedVideoResource = Schema.Struct({
  "object": Schema.Literal("video.deleted").annotate({
    "description": "The object type that signals the deletion response."
  }),
  "deleted": Schema.Boolean.annotate({ "description": "Indicates that the video resource was deleted." }),
  "id": Schema.String.annotate({ "description": "Identifier of the deleted video." })
}).annotate({
  "title": "Deleted video response",
  "description": "Confirmation payload returned after deleting a video."
})
export type VideoContentVariant = "video" | "thumbnail" | "spritesheet"
export const VideoContentVariant = Schema.Literals(["video", "thumbnail", "spritesheet"])
export type CreateVideoRemixBody = { readonly "prompt": string }
export const CreateVideoRemixBody = Schema.Struct({
  "prompt": Schema.String.annotate({ "description": "Updated text prompt that directs the remix generation." }).check(
    Schema.isMinLength(1)
  ).check(Schema.isMaxLength(32000))
}).annotate({
  "title": "Create video remix request",
  "description": "Parameters for remixing an existing generated video."
})
export type TokenCountsResource = { readonly "object": "response.input_tokens"; readonly "input_tokens": number }
export const TokenCountsResource = Schema.Struct({
  "object": Schema.Literal("response.input_tokens"),
  "input_tokens": Schema.Number.check(Schema.isInt())
}).annotate({ "title": "Token counts" })
export type SkillResource = {
  readonly "id": string
  readonly "object": "skill"
  readonly "name": string
  readonly "description": string
  readonly "created_at": number
  readonly "default_version": string
  readonly "latest_version": string
}
export const SkillResource = Schema.Struct({
  "id": Schema.String.annotate({ "description": "Unique identifier for the skill." }),
  "object": Schema.Literal("skill").annotate({ "description": "The object type, which is `skill`." }),
  "name": Schema.String.annotate({ "description": "Name of the skill." }),
  "description": Schema.String.annotate({ "description": "Description of the skill." }),
  "created_at": Schema.Number.annotate({ "description": "Unix timestamp (seconds) for when the skill was created." })
    .check(Schema.isInt()),
  "default_version": Schema.String.annotate({ "description": "Default version for the skill." }),
  "latest_version": Schema.String.annotate({ "description": "Latest version for the skill." })
})
export type CreateSkillBody = { readonly "files": ReadonlyArray<string> | string }
export const CreateSkillBody = Schema.Struct({
  "files": Schema.Union([
    Schema.Array(Schema.String.annotate({ "format": "binary" })).annotate({
      "description": "Skill files to upload (directory upload) or a single zip file."
    }).check(Schema.isMaxLength(500)),
    Schema.String.annotate({ "description": "Skill zip file to upload.", "format": "binary" })
  ], { mode: "oneOf" })
}).annotate({
  "title": "Create skill request",
  "description": "Uploads a skill either as a directory (multipart `files[]`) or as a single zip file."
})
export type SetDefaultSkillVersionBody = { readonly "default_version": string }
export const SetDefaultSkillVersionBody = Schema.Struct({
  "default_version": Schema.String.annotate({ "description": "The skill version number to set as default." })
}).annotate({ "title": "Update skill request", "description": "Updates the default version pointer for a skill." })
export type DeletedSkillResource = {
  readonly "object": "skill.deleted"
  readonly "deleted": boolean
  readonly "id": string
}
export const DeletedSkillResource = Schema.Struct({
  "object": Schema.Literal("skill.deleted"),
  "deleted": Schema.Boolean,
  "id": Schema.String
})
export type SkillVersionResource = {
  readonly "object": "skill.version"
  readonly "id": string
  readonly "skill_id": string
  readonly "version": string
  readonly "created_at": number
  readonly "name": string
  readonly "description": string
}
export const SkillVersionResource = Schema.Struct({
  "object": Schema.Literal("skill.version").annotate({ "description": "The object type, which is `skill.version`." }),
  "id": Schema.String.annotate({ "description": "Unique identifier for the skill version." }),
  "skill_id": Schema.String.annotate({ "description": "Identifier of the skill for this version." }),
  "version": Schema.String.annotate({ "description": "Version number for this skill." }),
  "created_at": Schema.Number.annotate({ "description": "Unix timestamp (seconds) for when the version was created." })
    .check(Schema.isInt()),
  "name": Schema.String.annotate({ "description": "Name of the skill version." }),
  "description": Schema.String.annotate({ "description": "Description of the skill version." })
})
export type CreateSkillVersionBody = { readonly "files": ReadonlyArray<string> | string; readonly "default"?: boolean }
export const CreateSkillVersionBody = Schema.Struct({
  "files": Schema.Union([
    Schema.Array(Schema.String.annotate({ "format": "binary" })).annotate({
      "description": "Skill files to upload (directory upload) or a single zip file."
    }).check(Schema.isMaxLength(500)),
    Schema.String.annotate({ "description": "Skill zip file to upload.", "format": "binary" })
  ], { mode: "oneOf" }),
  "default": Schema.optionalKey(
    Schema.Boolean.annotate({ "description": "Whether to set this version as the default." })
  )
}).annotate({ "title": "Create skill version request", "description": "Uploads a new immutable version of a skill." })
export type DeletedSkillVersionResource = {
  readonly "object": "skill.version.deleted"
  readonly "deleted": boolean
  readonly "id": string
  readonly "version": string
}
export const DeletedSkillVersionResource = Schema.Struct({
  "object": Schema.Literal("skill.version.deleted"),
  "deleted": Schema.Boolean,
  "id": Schema.String,
  "version": Schema.String.annotate({ "description": "The deleted skill version." })
})
export type ChatSessionResource = {
  readonly "id": string
  readonly "object": "chatkit.session"
  readonly "expires_at": number
  readonly "client_secret": string
  readonly "workflow": {
    readonly "id": string
    readonly "version": string | null
    readonly "state_variables": {} | null
    readonly "tracing": { readonly "enabled": boolean }
  }
  readonly "user": string
  readonly "rate_limits": { readonly "max_requests_per_1_minute": number }
  readonly "max_requests_per_1_minute": number
  readonly "status": "active" | "expired" | "cancelled"
  readonly "chatkit_configuration": {
    readonly "automatic_thread_titling": { readonly "enabled": boolean }
    readonly "file_upload": {
      readonly "enabled": boolean
      readonly "max_file_size": number | null
      readonly "max_files": number | null
    }
    readonly "history": { readonly "enabled": boolean; readonly "recent_threads": number | null }
  }
}
export const ChatSessionResource = Schema.Struct({
  "id": Schema.String.annotate({ "description": "Identifier for the ChatKit session." }),
  "object": Schema.Literal("chatkit.session").annotate({
    "description": "Type discriminator that is always `chatkit.session`."
  }),
  "expires_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) for when the session expires." })
    .check(Schema.isInt()),
  "client_secret": Schema.String.annotate({
    "description": "Ephemeral client secret that authenticates session requests."
  }),
  "workflow": Schema.Struct({
    "id": Schema.String.annotate({ "description": "Identifier of the workflow backing the session." }),
    "version": Schema.Union([
      Schema.String.annotate({
        "description":
          "Specific workflow version used for the session. Defaults to null when using the latest deployment."
      }),
      Schema.Null
    ]),
    "state_variables": Schema.Union([
      Schema.Struct({}).annotate({
        "description":
          "State variable key-value pairs applied when invoking the workflow. Defaults to null when no overrides were provided."
      }),
      Schema.Null
    ]),
    "tracing": Schema.Struct({
      "enabled": Schema.Boolean.annotate({ "description": "Indicates whether tracing is enabled." })
    }).annotate({ "title": "Tracing Configuration", "description": "Tracing settings applied to the workflow." })
  }).annotate({ "title": "Workflow", "description": "Workflow metadata for the session." }),
  "user": Schema.String.annotate({ "description": "User identifier associated with the session." }),
  "rate_limits": Schema.Struct({
    "max_requests_per_1_minute": Schema.Number.annotate({
      "description": "Maximum allowed requests per one-minute window."
    }).check(Schema.isInt())
  }).annotate({ "title": "Rate limits", "description": "Resolved rate limit values." }),
  "max_requests_per_1_minute": Schema.Number.annotate({
    "description": "Convenience copy of the per-minute request limit."
  }).check(Schema.isInt()),
  "status": Schema.Literals(["active", "expired", "cancelled"]).annotate({
    "description": "Current lifecycle state of the session."
  }),
  "chatkit_configuration": Schema.Struct({
    "automatic_thread_titling": Schema.Struct({
      "enabled": Schema.Boolean.annotate({ "description": "Whether automatic thread titling is enabled." })
    }).annotate({ "title": "Automatic thread titling", "description": "Automatic thread titling preferences." }),
    "file_upload": Schema.Struct({
      "enabled": Schema.Boolean.annotate({ "description": "Indicates if uploads are enabled for the session." }),
      "max_file_size": Schema.Union([
        Schema.Number.annotate({ "description": "Maximum upload size in megabytes." }).check(Schema.isInt()),
        Schema.Null
      ]),
      "max_files": Schema.Union([
        Schema.Number.annotate({ "description": "Maximum number of uploads allowed during the session." }).check(
          Schema.isInt()
        ),
        Schema.Null
      ])
    }).annotate({ "title": "File upload settings", "description": "Upload settings for the session." }),
    "history": Schema.Struct({
      "enabled": Schema.Boolean.annotate({ "description": "Indicates if chat history is persisted for the session." }),
      "recent_threads": Schema.Union([
        Schema.Number.annotate({
          "description":
            "Number of prior threads surfaced in history views. Defaults to null when all history is retained."
        }).check(Schema.isInt()),
        Schema.Null
      ])
    }).annotate({ "title": "History settings", "description": "History retention configuration." })
  }).annotate({
    "title": "ChatKit configuration",
    "description": "Resolved ChatKit feature configuration for the session."
  })
}).annotate({
  "title": "The chat session object",
  "description": "Represents a ChatKit session and its resolved configuration."
})
export type CreateChatSessionBody = {
  readonly "workflow": {
    readonly "id": string
    readonly "version"?: string
    readonly "state_variables"?: {}
    readonly "tracing"?: { readonly "enabled"?: boolean }
  }
  readonly "user": string
  readonly "expires_after"?: { readonly "anchor": "created_at"; readonly "seconds": number }
  readonly "rate_limits"?: { readonly "max_requests_per_1_minute"?: number }
  readonly "chatkit_configuration"?: {
    readonly "automatic_thread_titling"?: { readonly "enabled"?: boolean }
    readonly "file_upload"?: {
      readonly "enabled"?: boolean
      readonly "max_file_size"?: number
      readonly "max_files"?: number
    }
    readonly "history"?: { readonly "enabled"?: boolean; readonly "recent_threads"?: number }
  }
}
export const CreateChatSessionBody = Schema.Struct({
  "workflow": Schema.Struct({
    "id": Schema.String.annotate({ "description": "Identifier for the workflow invoked by the session." }),
    "version": Schema.optionalKey(
      Schema.String.annotate({
        "description": "Specific workflow version to run. Defaults to the latest deployed version."
      })
    ),
    "state_variables": Schema.optionalKey(
      Schema.Struct({}).annotate({
        "description":
          "State variables forwarded to the workflow. Keys may be up to 64 characters, values must be primitive types, and the map defaults to an empty object."
      }).check(Schema.isMaxProperties(64))
    ),
    "tracing": Schema.optionalKey(
      Schema.Struct({
        "enabled": Schema.optionalKey(
          Schema.Boolean.annotate({ "description": "Whether tracing is enabled during the session. Defaults to true." })
        )
      }).annotate({
        "title": "Tracing Configuration",
        "description":
          "Optional tracing overrides for the workflow invocation. When omitted, tracing is enabled by default."
      })
    )
  }).annotate({ "title": "Workflow settings", "description": "Workflow that powers the session." }),
  "user": Schema.String.annotate({
    "description":
      "A free-form string that identifies your end user; ensures this Session can access other objects that have the same `user` scope."
  }).check(Schema.isMinLength(1)),
  "expires_after": Schema.optionalKey(
    Schema.Struct({
      "anchor": Schema.Literal("created_at").annotate({
        "description": "Base timestamp used to calculate expiration. Currently fixed to `created_at`."
      }),
      "seconds": Schema.Number.annotate({
        "description": "Number of seconds after the anchor when the session expires."
      }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(Schema.isLessThanOrEqualTo(600))
    }).annotate({
      "title": "Expiration overrides",
      "description": "Optional override for session expiration timing in seconds from creation. Defaults to 10 minutes."
    })
  ),
  "rate_limits": Schema.optionalKey(
    Schema.Struct({
      "max_requests_per_1_minute": Schema.optionalKey(
        Schema.Number.annotate({
          "description": "Maximum number of requests allowed per minute for the session. Defaults to 10."
        }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1))
      )
    }).annotate({
      "title": "Rate limit overrides",
      "description": "Optional override for per-minute request limits. When omitted, defaults to 10."
    })
  ),
  "chatkit_configuration": Schema.optionalKey(
    Schema.Struct({
      "automatic_thread_titling": Schema.optionalKey(
        Schema.Struct({
          "enabled": Schema.optionalKey(
            Schema.Boolean.annotate({ "description": "Enable automatic thread title generation. Defaults to true." })
          )
        }).annotate({
          "title": "Automatic thread titling configuration",
          "description":
            "Configuration for automatic thread titling. When omitted, automatic thread titling is enabled by default."
        })
      ),
      "file_upload": Schema.optionalKey(
        Schema.Struct({
          "enabled": Schema.optionalKey(
            Schema.Boolean.annotate({ "description": "Enable uploads for this session. Defaults to false." })
          ),
          "max_file_size": Schema.optionalKey(
            Schema.Number.annotate({
              "description":
                "Maximum size in megabytes for each uploaded file. Defaults to 512 MB, which is the maximum allowable size."
            }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(Schema.isLessThanOrEqualTo(512))
          ),
          "max_files": Schema.optionalKey(
            Schema.Number.annotate({
              "description": "Maximum number of files that can be uploaded to the session. Defaults to 10."
            }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1))
          )
        }).annotate({
          "title": "File upload configuration",
          "description":
            "Configuration for upload enablement and limits. When omitted, uploads are disabled by default (max_files 10, max_file_size 512 MB)."
        })
      ),
      "history": Schema.optionalKey(
        Schema.Struct({
          "enabled": Schema.optionalKey(
            Schema.Boolean.annotate({
              "description": "Enables chat users to access previous ChatKit threads. Defaults to true."
            })
          ),
          "recent_threads": Schema.optionalKey(
            Schema.Number.annotate({
              "description": "Number of recent ChatKit threads users have access to. Defaults to unlimited when unset."
            }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1))
          )
        }).annotate({
          "title": "Chat history configuration",
          "description":
            "Configuration for chat history retention. When omitted, history is enabled by default with no limit on recent_threads (null)."
        })
      )
    }).annotate({
      "title": "ChatKit configuration overrides",
      "description": "Optional overrides for ChatKit runtime configuration features"
    })
  )
}).annotate({
  "title": "Create chat session request",
  "description": "Parameters for provisioning a new ChatKit session."
})
export type UserMessageInputText = { readonly "type": "input_text"; readonly "text": string }
export const UserMessageInputText = Schema.Struct({
  "type": Schema.Literal("input_text").annotate({ "description": "Type discriminator that is always `input_text`." }),
  "text": Schema.String.annotate({ "description": "Plain-text content supplied by the user." })
}).annotate({ "title": "User message input", "description": "Text block that a user contributed to the thread." })
export type UserMessageQuotedText = { readonly "type": "quoted_text"; readonly "text": string }
export const UserMessageQuotedText = Schema.Struct({
  "type": Schema.Literal("quoted_text").annotate({ "description": "Type discriminator that is always `quoted_text`." }),
  "text": Schema.String.annotate({ "description": "Quoted text content." })
}).annotate({
  "title": "User message quoted text",
  "description": "Quoted snippet that the user referenced in their message."
})
export type Attachment = {
  readonly "type": "image" | "file"
  readonly "id": string
  readonly "name": string
  readonly "mime_type": string
  readonly "preview_url": string | null
}
export const Attachment = Schema.Struct({
  "type": Schema.Literals(["image", "file"]).annotate({ "description": "Attachment discriminator." }),
  "id": Schema.String.annotate({ "description": "Identifier for the attachment." }),
  "name": Schema.String.annotate({ "description": "Original display name for the attachment." }),
  "mime_type": Schema.String.annotate({ "description": "MIME type of the attachment." }),
  "preview_url": Schema.Union([
    Schema.String.annotate({ "description": "Preview URL for rendering the attachment inline." }),
    Schema.Null
  ])
}).annotate({ "title": "Attachment", "description": "Attachment metadata included on thread items." })
export type FileAnnotation = {
  readonly "type": "file"
  readonly "source": { readonly "type": "file"; readonly "filename": string }
}
export const FileAnnotation = Schema.Struct({
  "type": Schema.Literal("file").annotate({
    "description": "Type discriminator that is always `file` for this annotation."
  }),
  "source": Schema.Struct({
    "type": Schema.Literal("file").annotate({ "description": "Type discriminator that is always `file`." }),
    "filename": Schema.String.annotate({ "description": "Filename referenced by the annotation." })
  }).annotate({ "title": "File annotation source", "description": "File attachment referenced by the annotation." })
}).annotate({ "title": "File annotation", "description": "Annotation that references an uploaded file." })
export type UrlAnnotation = {
  readonly "type": "url"
  readonly "source": { readonly "type": "url"; readonly "url": string }
}
export const UrlAnnotation = Schema.Struct({
  "type": Schema.Literal("url").annotate({
    "description": "Type discriminator that is always `url` for this annotation."
  }),
  "source": Schema.Struct({
    "type": Schema.Literal("url").annotate({ "description": "Type discriminator that is always `url`." }),
    "url": Schema.String.annotate({ "description": "URL referenced by the annotation." })
  }).annotate({ "title": "URL annotation source", "description": "URL referenced by the annotation." })
}).annotate({ "title": "URL annotation", "description": "Annotation that references a URL." })
export type WidgetMessageItem = {
  readonly "id": string
  readonly "object": "chatkit.thread_item"
  readonly "created_at": number
  readonly "thread_id": string
  readonly "type": "chatkit.widget"
  readonly "widget": string
}
export const WidgetMessageItem = Schema.Struct({
  "id": Schema.String.annotate({ "description": "Identifier of the thread item." }),
  "object": Schema.Literal("chatkit.thread_item").annotate({
    "description": "Type discriminator that is always `chatkit.thread_item`."
  }),
  "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) for when the item was created." })
    .check(Schema.isInt()),
  "thread_id": Schema.String.annotate({ "description": "Identifier of the parent thread." }),
  "type": Schema.Literal("chatkit.widget").annotate({
    "description": "Type discriminator that is always `chatkit.widget`."
  }),
  "widget": Schema.String.annotate({ "description": "Serialized widget payload rendered in the UI." })
}).annotate({ "title": "Widget message", "description": "Thread item that renders a widget payload." })
export type ClientToolCallItem = {
  readonly "id": string
  readonly "object": "chatkit.thread_item"
  readonly "created_at": number
  readonly "thread_id": string
  readonly "type": "chatkit.client_tool_call"
  readonly "status": "in_progress" | "completed"
  readonly "call_id": string
  readonly "name": string
  readonly "arguments": string
  readonly "output": string | null
}
export const ClientToolCallItem = Schema.Struct({
  "id": Schema.String.annotate({ "description": "Identifier of the thread item." }),
  "object": Schema.Literal("chatkit.thread_item").annotate({
    "description": "Type discriminator that is always `chatkit.thread_item`."
  }),
  "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) for when the item was created." })
    .check(Schema.isInt()),
  "thread_id": Schema.String.annotate({ "description": "Identifier of the parent thread." }),
  "type": Schema.Literal("chatkit.client_tool_call").annotate({
    "description": "Type discriminator that is always `chatkit.client_tool_call`."
  }),
  "status": Schema.Literals(["in_progress", "completed"]).annotate({
    "description": "Execution status for the tool call."
  }),
  "call_id": Schema.String.annotate({ "description": "Identifier for the client tool call." }),
  "name": Schema.String.annotate({ "description": "Tool name that was invoked." }),
  "arguments": Schema.String.annotate({ "description": "JSON-encoded arguments that were sent to the tool." }),
  "output": Schema.Union([
    Schema.String.annotate({
      "description": "JSON-encoded output captured from the tool. Defaults to null while execution is in progress."
    }),
    Schema.Null
  ])
}).annotate({
  "title": "Client tool call",
  "description": "Record of a client side tool invocation initiated by the assistant."
})
export type TaskItem = {
  readonly "id": string
  readonly "object": "chatkit.thread_item"
  readonly "created_at": number
  readonly "thread_id": string
  readonly "type": "chatkit.task"
  readonly "task_type": "custom" | "thought"
  readonly "heading": string | null
  readonly "summary": string | null
}
export const TaskItem = Schema.Struct({
  "id": Schema.String.annotate({ "description": "Identifier of the thread item." }),
  "object": Schema.Literal("chatkit.thread_item").annotate({
    "description": "Type discriminator that is always `chatkit.thread_item`."
  }),
  "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) for when the item was created." })
    .check(Schema.isInt()),
  "thread_id": Schema.String.annotate({ "description": "Identifier of the parent thread." }),
  "type": Schema.Literal("chatkit.task").annotate({
    "description": "Type discriminator that is always `chatkit.task`."
  }),
  "task_type": Schema.Literals(["custom", "thought"]).annotate({ "description": "Subtype for the task." }),
  "heading": Schema.Union([
    Schema.String.annotate({ "description": "Optional heading for the task. Defaults to null when not provided." }),
    Schema.Null
  ]),
  "summary": Schema.Union([
    Schema.String.annotate({
      "description": "Optional summary that describes the task. Defaults to null when omitted."
    }),
    Schema.Null
  ])
}).annotate({
  "title": "Task item",
  "description": "Task emitted by the workflow to show progress and status updates."
})
export type TaskGroupTask = {
  readonly "type": "custom" | "thought"
  readonly "heading": string | null
  readonly "summary": string | null
}
export const TaskGroupTask = Schema.Struct({
  "type": Schema.Literals(["custom", "thought"]).annotate({ "description": "Subtype for the grouped task." }),
  "heading": Schema.Union([
    Schema.String.annotate({
      "description": "Optional heading for the grouped task. Defaults to null when not provided."
    }),
    Schema.Null
  ]),
  "summary": Schema.Union([
    Schema.String.annotate({
      "description": "Optional summary that describes the grouped task. Defaults to null when omitted."
    }),
    Schema.Null
  ])
}).annotate({ "title": "Task group task", "description": "Task entry that appears within a TaskGroup." })
export type ActiveStatus = { readonly "type": "active" }
export const ActiveStatus = Schema.Struct({
  "type": Schema.Literal("active").annotate({ "description": "Status discriminator that is always `active`." })
}).annotate({ "title": "Active thread status", "description": "Indicates that a thread is active." })
export type LockedStatus = { readonly "type": "locked"; readonly "reason": string | null }
export const LockedStatus = Schema.Struct({
  "type": Schema.Literal("locked").annotate({ "description": "Status discriminator that is always `locked`." }),
  "reason": Schema.Union([
    Schema.String.annotate({
      "description": "Reason that the thread was locked. Defaults to null when no reason is recorded."
    }),
    Schema.Null
  ])
}).annotate({
  "title": "Locked thread status",
  "description": "Indicates that a thread is locked and cannot accept new input."
})
export type ClosedStatus = { readonly "type": "closed"; readonly "reason": string | null }
export const ClosedStatus = Schema.Struct({
  "type": Schema.Literal("closed").annotate({ "description": "Status discriminator that is always `closed`." }),
  "reason": Schema.Union([
    Schema.String.annotate({
      "description": "Reason that the thread was closed. Defaults to null when no reason is recorded."
    }),
    Schema.Null
  ])
}).annotate({ "title": "Closed thread status", "description": "Indicates that a thread has been closed." })
export type DeletedThreadResource = {
  readonly "id": string
  readonly "object": "chatkit.thread.deleted"
  readonly "deleted": boolean
}
export const DeletedThreadResource = Schema.Struct({
  "id": Schema.String.annotate({ "description": "Identifier of the deleted thread." }),
  "object": Schema.Literal("chatkit.thread.deleted").annotate({
    "description": "Type discriminator that is always `chatkit.thread.deleted`."
  }),
  "deleted": Schema.Boolean.annotate({ "description": "Indicates that the thread has been deleted." })
}).annotate({ "title": "Deleted thread", "description": "Confirmation payload returned after deleting a thread." })
export type ResponseApplyPatchCallOperationDiffDeltaEvent = {
  readonly "type": "response.apply_patch_call_operation_diff.delta"
  readonly "sequence_number": number
  readonly "output_index": number
  readonly "item_id": string
  readonly "delta": string
}
export const ResponseApplyPatchCallOperationDiffDeltaEvent = Schema.Struct({
  "type": Schema.Literal("response.apply_patch_call_operation_diff.delta").annotate({
    "description": "The event type identifier."
  }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  ),
  "output_index": Schema.Number.annotate({ "description": "The index of the output this delta applies to." }).check(
    Schema.isInt()
  ),
  "item_id": Schema.String.annotate({
    "description": "Unique identifier for the API item associated with this event."
  }),
  "delta": Schema.String.annotate({ "description": "The incremental diff data for the apply_patch tool call." })
}).annotate({
  "title": "ResponseApplyPatchCallOperationDiffDelta",
  "description": "Event representing a delta for an apply_patch tool call operation diff."
})
export type ResponseApplyPatchCallOperationDiffDoneEvent = {
  readonly "type": "response.apply_patch_call_operation_diff.done"
  readonly "sequence_number": number
  readonly "output_index": number
  readonly "item_id": string
  readonly "delta"?: string
}
export const ResponseApplyPatchCallOperationDiffDoneEvent = Schema.Struct({
  "type": Schema.Literal("response.apply_patch_call_operation_diff.done").annotate({
    "description": "The event type identifier."
  }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  ),
  "output_index": Schema.Number.annotate({ "description": "The index of the output this event applies to." }).check(
    Schema.isInt()
  ),
  "item_id": Schema.String.annotate({
    "description": "Unique identifier for the API item associated with this event."
  }),
  "delta": Schema.optionalKey(
    Schema.String.annotate({ "description": "The final diff data for the apply_patch tool call." })
  )
}).annotate({
  "title": "ResponseApplyPatchCallOperationDiffDone",
  "description": "Event indicating that the operation diff for an apply_patch tool call is complete."
})
export type ApiKeyList = {
  readonly "object"?: string
  readonly "data"?: ReadonlyArray<AdminApiKey>
  readonly "has_more"?: boolean
  readonly "first_id"?: string
  readonly "last_id"?: string
}
export const ApiKeyList = Schema.Struct({
  "object": Schema.optionalKey(Schema.String),
  "data": Schema.optionalKey(Schema.Array(AdminApiKey)),
  "has_more": Schema.optionalKey(Schema.Boolean),
  "first_id": Schema.optionalKey(Schema.String),
  "last_id": Schema.optionalKey(Schema.String)
})
export type RoleListResource = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<AssignedRoleDetails>
  readonly "has_more": boolean
  readonly "next": string | null
}
export const RoleListResource = Schema.Struct({
  "object": Schema.Literal("list").annotate({ "description": "Always `list`." }),
  "data": Schema.Array(AssignedRoleDetails).annotate({
    "description": "Role assignments returned in the current page."
  }),
  "has_more": Schema.Boolean.annotate({
    "description": "Whether additional assignments are available when paginating."
  }),
  "next": Schema.Union([Schema.String, Schema.Null]).annotate({
    "description": "Cursor to fetch the next page of results, or `null` when there are no more assignments."
  })
}).annotate({ "description": "Paginated list of roles assigned to a principal." })
export type AuditLogActorApiKey = {
  readonly "id"?: string
  readonly "type"?: "user" | "service_account"
  readonly "user"?: AuditLogActorUser
  readonly "service_account"?: AuditLogActorServiceAccount
}
export const AuditLogActorApiKey = Schema.Struct({
  "id": Schema.optionalKey(Schema.String.annotate({ "description": "The tracking id of the API key." })),
  "type": Schema.optionalKey(
    Schema.Literals(["user", "service_account"]).annotate({
      "description": "The type of API key. Can be either `user` or `service_account`."
    })
  ),
  "user": Schema.optionalKey(AuditLogActorUser),
  "service_account": Schema.optionalKey(AuditLogActorServiceAccount)
}).annotate({ "description": "The API Key used to perform the audit logged action." })
export type AuditLogActorSession = { readonly "user"?: AuditLogActorUser; readonly "ip_address"?: string }
export const AuditLogActorSession = Schema.Struct({
  "user": Schema.optionalKey(AuditLogActorUser),
  "ip_address": Schema.optionalKey(
    Schema.String.annotate({ "description": "The IP address from which the action was performed." })
  )
}).annotate({ "description": "The session in which the audit logged action was performed." })
export type ListCertificatesResponse = {
  readonly "data": ReadonlyArray<Certificate>
  readonly "first_id"?: string
  readonly "last_id"?: string
  readonly "has_more": boolean
  readonly "object": "list"
}
export const ListCertificatesResponse = Schema.Struct({
  "data": Schema.Array(Certificate),
  "first_id": Schema.optionalKey(Schema.String),
  "last_id": Schema.optionalKey(Schema.String),
  "has_more": Schema.Boolean,
  "object": Schema.Literal("list")
})
export type ChatCompletionAllowedToolsChoice = {
  readonly "type": "allowed_tools"
  readonly "allowed_tools": ChatCompletionAllowedTools
}
export const ChatCompletionAllowedToolsChoice = Schema.Struct({
  "type": Schema.Literal("allowed_tools").annotate({
    "description": "Allowed tool configuration type. Always `allowed_tools`."
  }),
  "allowed_tools": ChatCompletionAllowedTools
}).annotate({
  "title": "Allowed tools",
  "description": "Constrains the tools available to the model to a pre-defined set.\n"
})
export type ChatCompletionMessageToolCalls = ReadonlyArray<
  ChatCompletionMessageToolCall | ChatCompletionMessageCustomToolCall
>
export const ChatCompletionMessageToolCalls = Schema.Array(
  Schema.Union([ChatCompletionMessageToolCall, ChatCompletionMessageCustomToolCall], { mode: "oneOf" })
).annotate({ "description": "The tool calls generated by the model, such as function calls." })
export type ChatCompletionStreamResponseDelta = {
  readonly "content"?: string | null
  readonly "function_call"?: { readonly "arguments"?: string; readonly "name"?: string }
  readonly "tool_calls"?: ReadonlyArray<ChatCompletionMessageToolCallChunk>
  readonly "role"?: "developer" | "system" | "user" | "assistant" | "tool"
  readonly "refusal"?: string | null
}
export const ChatCompletionStreamResponseDelta = Schema.Struct({
  "content": Schema.optionalKey(
    Schema.Union([Schema.String.annotate({ "description": "The contents of the chunk message." }), Schema.Null])
  ),
  "function_call": Schema.optionalKey(
    Schema.Struct({
      "arguments": Schema.optionalKey(Schema.String.annotate({
        "description":
          "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."
      })),
      "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the function to call." }))
    }).annotate({
      "description":
        "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."
    })
  ),
  "tool_calls": Schema.optionalKey(Schema.Array(ChatCompletionMessageToolCallChunk)),
  "role": Schema.optionalKey(
    Schema.Literals(["developer", "system", "user", "assistant", "tool"]).annotate({
      "description": "The role of the author of this message."
    })
  ),
  "refusal": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "The refusal message generated by the model." }),
      Schema.Null
    ])
  )
}).annotate({ "description": "A chat completion delta generated by streamed model responses." })
export type ChatCompletionRequestAssistantMessageContentPart =
  | ChatCompletionRequestMessageContentPartText
  | ChatCompletionRequestMessageContentPartRefusal
export const ChatCompletionRequestAssistantMessageContentPart = Schema.Union([
  ChatCompletionRequestMessageContentPartText,
  ChatCompletionRequestMessageContentPartRefusal
], { mode: "oneOf" })
export type ChatCompletionRequestDeveloperMessage = {
  readonly "content": string | ReadonlyArray<ChatCompletionRequestMessageContentPartText>
  readonly "role": "developer"
  readonly "name"?: string
}
export const ChatCompletionRequestDeveloperMessage = Schema.Struct({
  "content": Schema.Union([
    Schema.String.annotate({ "title": "Text content", "description": "The contents of the developer message." }),
    Schema.Array(ChatCompletionRequestMessageContentPartText).annotate({
      "title": "Array of content parts",
      "description":
        "An array of content parts with a defined type. For developer messages, only type `text` is supported."
    }).check(Schema.isMinLength(1))
  ], { mode: "oneOf" }).annotate({ "description": "The contents of the developer message." }),
  "role": Schema.Literal("developer").annotate({
    "description": "The role of the messages author, in this case `developer`."
  }),
  "name": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "An optional name for the participant. Provides the model information to differentiate between participants of the same role."
    })
  )
}).annotate({
  "title": "Developer message",
  "description":
    "Developer-provided instructions that the model should follow, regardless of\nmessages sent by the user. With o1 models and newer, `developer` messages\nreplace the previous `system` messages.\n"
})
export type ChatCompletionRequestSystemMessageContentPart = ChatCompletionRequestMessageContentPartText
export const ChatCompletionRequestSystemMessageContentPart = Schema.Union(
  [ChatCompletionRequestMessageContentPartText],
  { mode: "oneOf" }
)
export type ChatCompletionRequestToolMessageContentPart = ChatCompletionRequestMessageContentPartText
export const ChatCompletionRequestToolMessageContentPart = Schema.Union([ChatCompletionRequestMessageContentPartText], {
  mode: "oneOf"
})
export type ChatCompletionRequestUserMessageContentPart =
  | ChatCompletionRequestMessageContentPartText
  | ChatCompletionRequestMessageContentPartImage
  | ChatCompletionRequestMessageContentPartAudio
  | ChatCompletionRequestMessageContentPartFile
export const ChatCompletionRequestUserMessageContentPart = Schema.Union([
  ChatCompletionRequestMessageContentPartText,
  ChatCompletionRequestMessageContentPartImage,
  ChatCompletionRequestMessageContentPartAudio,
  ChatCompletionRequestMessageContentPartFile
], { mode: "oneOf" })
export type PredictionContent = {
  readonly "type": "content"
  readonly "content": string | ReadonlyArray<ChatCompletionRequestMessageContentPartText>
}
export const PredictionContent = Schema.Struct({
  "type": Schema.Literal("content").annotate({
    "description": "The type of the predicted content you want to provide. This type is\ncurrently always `content`.\n"
  }),
  "content": Schema.Union([
    Schema.String.annotate({
      "title": "Text content",
      "description":
        "The content used for a Predicted Output. This is often the\ntext of a file you are regenerating with minor changes.\n"
    }),
    Schema.Array(ChatCompletionRequestMessageContentPartText).annotate({
      "title": "Array of content parts",
      "description":
        "An array of content parts with a defined type. Supported options differ based on the [model](/docs/models) being used to generate the response. Can contain text inputs."
    }).check(Schema.isMinLength(1))
  ], { mode: "oneOf" }).annotate({
    "description":
      "The content that should be matched when generating a model response.\nIf generated tokens would match this content, the entire model response\ncan be returned much more quickly.\n"
  })
}).annotate({
  "title": "Static Content",
  "description": "Static predicted output content, such as the content of a text file that is\nbeing regenerated.\n"
})
export type CompoundFilter = {
  readonly "type": "and" | "or"
  readonly "filters": ReadonlyArray<ComparisonFilter | unknown>
}
export const CompoundFilter = Schema.Struct({
  "type": Schema.Literals(["and", "or"]).annotate({ "description": "Type of operation: `and` or `or`." }),
  "filters": Schema.Array(Schema.Union([ComparisonFilter, Schema.Unknown], { mode: "oneOf" })).annotate({
    "description": "Array of filters to combine. Items can be `ComparisonFilter` or `CompoundFilter`."
  })
}).annotate({ "title": "Compound Filter", "description": "Combine multiple filters using `and` or `or`." })
export type CreateCompletionResponse = {
  readonly "id": string
  readonly "choices": ReadonlyArray<
    {
      readonly "finish_reason": "stop" | "length" | "content_filter"
      readonly "index": number
      readonly "logprobs": {
        readonly "text_offset"?: ReadonlyArray<number>
        readonly "token_logprobs"?: ReadonlyArray<number>
        readonly "tokens"?: ReadonlyArray<string>
        readonly "top_logprobs"?: ReadonlyArray<{}>
      } | null
      readonly "text": string
    }
  >
  readonly "created": number
  readonly "model": string
  readonly "system_fingerprint"?: string
  readonly "object": "text_completion"
  readonly "usage"?: CompletionUsage
}
export const CreateCompletionResponse = Schema.Struct({
  "id": Schema.String.annotate({ "description": "A unique identifier for the completion." }),
  "choices": Schema.Array(Schema.Struct({
    "finish_reason": Schema.Literals(["stop", "length", "content_filter"]).annotate({
      "description":
        "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\nor `content_filter` if content was omitted due to a flag from our content filters.\n"
    }),
    "index": Schema.Number.check(Schema.isInt()),
    "logprobs": Schema.Union([
      Schema.Struct({
        "text_offset": Schema.optionalKey(Schema.Array(Schema.Number.check(Schema.isInt()))),
        "token_logprobs": Schema.optionalKey(Schema.Array(Schema.Number.check(Schema.isFinite()))),
        "tokens": Schema.optionalKey(Schema.Array(Schema.String)),
        "top_logprobs": Schema.optionalKey(Schema.Array(Schema.Struct({})))
      }),
      Schema.Null
    ]),
    "text": Schema.String
  })).annotate({ "description": "The list of completion choices the model generated for the input prompt." }),
  "created": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) of when the completion was created."
  }).check(Schema.isInt()),
  "model": Schema.String.annotate({ "description": "The model used for completion." }),
  "system_fingerprint": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "This fingerprint represents the backend configuration that the model runs with.\n\nCan be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.\n"
    })
  ),
  "object": Schema.Literal("text_completion").annotate({
    "description": "The object type, which is always \"text_completion\""
  }),
  "usage": Schema.optionalKey(CompletionUsage)
}).annotate({
  "description":
    "Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape (unlike the chat endpoint).\n"
})
export type ContainerFileListResource = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<ContainerFileResource>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const ContainerFileListResource = Schema.Struct({
  "object": Schema.Literal("list").annotate({ "description": "The type of object returned, must be 'list'." }),
  "data": Schema.Array(ContainerFileResource).annotate({ "description": "A list of container files." }),
  "first_id": Schema.String.annotate({ "description": "The ID of the first file in the list." }),
  "last_id": Schema.String.annotate({ "description": "The ID of the last file in the list." }),
  "has_more": Schema.Boolean.annotate({ "description": "Whether there are more files available." })
})
export type ContainerListResource = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<ContainerResource>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const ContainerListResource = Schema.Struct({
  "object": Schema.Literal("list").annotate({ "description": "The type of object returned, must be 'list'." }),
  "data": Schema.Array(ContainerResource).annotate({ "description": "A list of containers." }),
  "first_id": Schema.String.annotate({ "description": "The ID of the first container in the list." }),
  "last_id": Schema.String.annotate({ "description": "The ID of the last container in the list." }),
  "has_more": Schema.Boolean.annotate({ "description": "Whether there are more containers available." })
})
export type CreateEmbeddingResponse = {
  readonly "data": ReadonlyArray<Embedding>
  readonly "model": string
  readonly "object": "list"
  readonly "usage": { readonly "prompt_tokens": number; readonly "total_tokens": number }
}
export const CreateEmbeddingResponse = Schema.Struct({
  "data": Schema.Array(Embedding).annotate({ "description": "The list of embeddings generated by the model." }),
  "model": Schema.String.annotate({ "description": "The name of the model used to generate the embedding." }),
  "object": Schema.Literal("list").annotate({ "description": "The object type, which is always \"list\"." }),
  "usage": Schema.Struct({
    "prompt_tokens": Schema.Number.annotate({ "description": "The number of tokens used by the prompt." }).check(
      Schema.isInt()
    ),
    "total_tokens": Schema.Number.annotate({ "description": "The total number of tokens used by the request." }).check(
      Schema.isInt()
    )
  }).annotate({ "description": "The usage information for the request." })
})
export type ErrorEvent = { readonly "event": "error"; readonly "data": Error }
export const ErrorEvent = Schema.Struct({ "event": Schema.Literal("error"), "data": Error }).annotate({
  "description":
    "Occurs when an [error](/docs/guides/error-codes#api-errors) occurs. This can happen due to an internal server error or a timeout."
})
export type ErrorResponse = { readonly "error": Error }
export const ErrorResponse = Schema.Struct({ "error": Error })
export type CreateEvalJsonlRunDataSource = {
  readonly "type": "jsonl"
  readonly "source": EvalJsonlFileContentSource | EvalJsonlFileIdSource
}
export const CreateEvalJsonlRunDataSource = Schema.Struct({
  "type": Schema.Literal("jsonl").annotate({ "description": "The type of data source. Always `jsonl`." }),
  "source": Schema.Union([EvalJsonlFileContentSource, EvalJsonlFileIdSource], { mode: "oneOf" }).annotate({
    "description": "Determines what populates the `item` namespace in the data source."
  })
}).annotate({
  "title": "JsonlRunDataSource",
  "description": "A JsonlRunDataSource object with that specifies a JSONL file that matches the eval \n"
})
export type EvalRunOutputItem = {
  readonly "object": "eval.run.output_item"
  readonly "id": string
  readonly "run_id": string
  readonly "eval_id": string
  readonly "created_at": number
  readonly "status": string
  readonly "datasource_item_id": number
  readonly "datasource_item": {}
  readonly "results": ReadonlyArray<EvalRunOutputItemResult>
  readonly "sample": {
    readonly "input": ReadonlyArray<{ readonly "role": string; readonly "content": string }>
    readonly "output": ReadonlyArray<{ readonly "role"?: string; readonly "content"?: string }>
    readonly "finish_reason": string
    readonly "model": string
    readonly "usage": {
      readonly "total_tokens": number
      readonly "completion_tokens": number
      readonly "prompt_tokens": number
      readonly "cached_tokens": number
    }
    readonly "error": EvalApiError
    readonly "temperature": number
    readonly "max_completion_tokens": number
    readonly "top_p": number
    readonly "seed": number
  }
}
export const EvalRunOutputItem = Schema.Struct({
  "object": Schema.Literal("eval.run.output_item").annotate({
    "description": "The type of the object. Always \"eval.run.output_item\"."
  }),
  "id": Schema.String.annotate({ "description": "Unique identifier for the evaluation run output item." }),
  "run_id": Schema.String.annotate({
    "description": "The identifier of the evaluation run associated with this output item."
  }),
  "eval_id": Schema.String.annotate({ "description": "The identifier of the evaluation group." }),
  "created_at": Schema.Number.annotate({
    "description": "Unix timestamp (in seconds) when the evaluation run was created."
  }).check(Schema.isInt()),
  "status": Schema.String.annotate({ "description": "The status of the evaluation run." }),
  "datasource_item_id": Schema.Number.annotate({ "description": "The identifier for the data source item." }).check(
    Schema.isInt()
  ),
  "datasource_item": Schema.Struct({}).annotate({ "description": "Details of the input data source item." }),
  "results": Schema.Array(EvalRunOutputItemResult).annotate({
    "description": "A list of grader results for this output item."
  }),
  "sample": Schema.Struct({
    "input": Schema.Array(
      Schema.Struct({
        "role": Schema.String.annotate({
          "description": "The role of the message sender (e.g., system, user, developer)."
        }),
        "content": Schema.String.annotate({ "description": "The content of the message." })
      }).annotate({ "description": "An input message." })
    ).annotate({ "description": "An array of input messages." }),
    "output": Schema.Array(
      Schema.Struct({
        "role": Schema.optionalKey(
          Schema.String.annotate({
            "description": "The role of the message (e.g. \"system\", \"assistant\", \"user\")."
          })
        ),
        "content": Schema.optionalKey(Schema.String.annotate({ "description": "The content of the message." }))
      })
    ).annotate({ "description": "An array of output messages." }),
    "finish_reason": Schema.String.annotate({ "description": "The reason why the sample generation was finished." }),
    "model": Schema.String.annotate({ "description": "The model used for generating the sample." }),
    "usage": Schema.Struct({
      "total_tokens": Schema.Number.annotate({ "description": "The total number of tokens used." }).check(
        Schema.isInt()
      ),
      "completion_tokens": Schema.Number.annotate({ "description": "The number of completion tokens generated." })
        .check(Schema.isInt()),
      "prompt_tokens": Schema.Number.annotate({ "description": "The number of prompt tokens used." }).check(
        Schema.isInt()
      ),
      "cached_tokens": Schema.Number.annotate({ "description": "The number of tokens retrieved from cache." }).check(
        Schema.isInt()
      )
    }).annotate({ "description": "Token usage details for the sample." }),
    "error": EvalApiError,
    "temperature": Schema.Number.annotate({ "description": "The sampling temperature used." }).check(Schema.isFinite()),
    "max_completion_tokens": Schema.Number.annotate({
      "description": "The maximum number of tokens allowed for completion."
    }).check(Schema.isInt()),
    "top_p": Schema.Number.annotate({ "description": "The top_p value used for sampling." }).check(Schema.isFinite()),
    "seed": Schema.Number.annotate({ "description": "The seed used for generating the sample." }).check(Schema.isInt())
  }).annotate({ "description": "A sample containing the input and output of the evaluation run." })
}).annotate({ "title": "EvalRunOutputItem", "description": "A schema representing an evaluation run output item.\n" })
export type CreateFileRequest = {
  readonly "file": string
  readonly "purpose": "assistants" | "batch" | "fine-tune" | "vision" | "user_data" | "evals"
  readonly "expires_after"?: FileExpirationAfter
}
export const CreateFileRequest = Schema.Struct({
  "file": Schema.String.annotate({
    "description": "The File object (not file name) to be uploaded.\n",
    "format": "binary"
  }),
  "purpose": Schema.Literals(["assistants", "batch", "fine-tune", "vision", "user_data", "evals"]).annotate({
    "description":
      "The intended purpose of the uploaded file. One of:\n- `assistants`: Used in the Assistants API\n- `batch`: Used in the Batch API\n- `fine-tune`: Used for fine-tuning\n- `vision`: Images used for vision fine-tuning\n- `user_data`: Flexible file type for any purpose\n- `evals`: Used for eval data sets\n"
  }),
  "expires_after": Schema.optionalKey(FileExpirationAfter)
})
export type CreateUploadRequest = {
  readonly "filename": string
  readonly "purpose": "assistants" | "batch" | "fine-tune" | "vision"
  readonly "bytes": number
  readonly "mime_type": string
  readonly "expires_after"?: FileExpirationAfter
}
export const CreateUploadRequest = Schema.Struct({
  "filename": Schema.String.annotate({ "description": "The name of the file to upload.\n" }),
  "purpose": Schema.Literals(["assistants", "batch", "fine-tune", "vision"]).annotate({
    "description":
      "The intended purpose of the uploaded file.\n\nSee the [documentation on File\npurposes](/docs/api-reference/files/create#files-create-purpose).\n"
  }),
  "bytes": Schema.Number.annotate({ "description": "The number of bytes in the file you are uploading.\n" }).check(
    Schema.isInt()
  ),
  "mime_type": Schema.String.annotate({
    "description":
      "The MIME type of the file.\n\n\nThis must fall within the supported MIME types for your file purpose. See\nthe supported MIME types for assistants and vision.\n"
  }),
  "expires_after": Schema.optionalKey(FileExpirationAfter)
})
export type FileSearchRankingOptions = { readonly "ranker"?: FileSearchRanker; readonly "score_threshold": number }
export const FileSearchRankingOptions = Schema.Struct({
  "ranker": Schema.optionalKey(FileSearchRanker),
  "score_threshold": Schema.Number.annotate({
    "description":
      "The score threshold for the file search. All values must be a floating point number between 0 and 1."
  }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1))
}).annotate({
  "title": "File search tool call ranking options",
  "description":
    "The ranking options for the file search. If not specified, the file search tool will use the `auto` ranker and a score_threshold of 0.\n\nSee the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.\n"
})
export type RunStepDetailsToolCallsFileSearchRankingOptionsObject = {
  readonly "ranker": FileSearchRanker
  readonly "score_threshold": number
}
export const RunStepDetailsToolCallsFileSearchRankingOptionsObject = Schema.Struct({
  "ranker": FileSearchRanker,
  "score_threshold": Schema.Number.annotate({
    "description":
      "The score threshold for the file search. All values must be a floating point number between 0 and 1."
  }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1))
}).annotate({
  "title": "File search tool call ranking options",
  "description": "The ranking options for the file search."
})
export type FineTuneDPOMethod = { readonly "hyperparameters"?: FineTuneDPOHyperparameters }
export const FineTuneDPOMethod = Schema.Struct({ "hyperparameters": Schema.optionalKey(FineTuneDPOHyperparameters) })
  .annotate({ "description": "Configuration for the DPO fine-tuning method." })
export type FineTuneSupervisedMethod = { readonly "hyperparameters"?: FineTuneSupervisedHyperparameters }
export const FineTuneSupervisedMethod = Schema.Struct({
  "hyperparameters": Schema.optionalKey(FineTuneSupervisedHyperparameters)
}).annotate({ "description": "Configuration for the supervised fine-tuning method." })
export type ListFineTuningCheckpointPermissionResponse = {
  readonly "data": ReadonlyArray<FineTuningCheckpointPermission>
  readonly "object": "list"
  readonly "first_id"?: string | null
  readonly "last_id"?: string | null
  readonly "has_more": boolean
}
export const ListFineTuningCheckpointPermissionResponse = Schema.Struct({
  "data": Schema.Array(FineTuningCheckpointPermission),
  "object": Schema.Literal("list"),
  "first_id": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null])),
  "last_id": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null])),
  "has_more": Schema.Boolean
})
export type ListFineTuningJobCheckpointsResponse = {
  readonly "data": ReadonlyArray<FineTuningJobCheckpoint>
  readonly "object": "list"
  readonly "first_id"?: string | null
  readonly "last_id"?: string | null
  readonly "has_more": boolean
}
export const ListFineTuningJobCheckpointsResponse = Schema.Struct({
  "data": Schema.Array(FineTuningJobCheckpoint),
  "object": Schema.Literal("list"),
  "first_id": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null])),
  "last_id": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null])),
  "has_more": Schema.Boolean
})
export type ListFineTuningJobEventsResponse = {
  readonly "data": ReadonlyArray<FineTuningJobEvent>
  readonly "object": "list"
  readonly "has_more": boolean
}
export const ListFineTuningJobEventsResponse = Schema.Struct({
  "data": Schema.Array(FineTuningJobEvent),
  "object": Schema.Literal("list"),
  "has_more": Schema.Boolean
})
export type ChatCompletionFunctions = {
  readonly "description"?: string
  readonly "name": string
  readonly "parameters"?: FunctionParameters
}
export const ChatCompletionFunctions = Schema.Struct({
  "description": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "A description of what the function does, used by the model to choose when and how to call the function."
    })
  ),
  "name": Schema.String.annotate({
    "description":
      "The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."
  }),
  "parameters": Schema.optionalKey(FunctionParameters)
})
export type FunctionObject = {
  readonly "description"?: string
  readonly "name": string
  readonly "parameters"?: FunctionParameters
  readonly "strict"?: boolean | null
}
export const FunctionObject = Schema.Struct({
  "description": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "A description of what the function does, used by the model to choose when and how to call the function."
    })
  ),
  "name": Schema.String.annotate({
    "description":
      "The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."
  }),
  "parameters": Schema.optionalKey(FunctionParameters),
  "strict": Schema.optionalKey(Schema.Union([
    Schema.Boolean.annotate({
      "description":
        "Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Learn more about Structured Outputs in the [function calling guide](/docs/guides/function-calling)."
    }),
    Schema.Null
  ]))
})
export type GroupListResource = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<GroupResponse>
  readonly "has_more": boolean
  readonly "next": string | null
}
export const GroupListResource = Schema.Struct({
  "object": Schema.Literal("list").annotate({ "description": "Always `list`." }),
  "data": Schema.Array(GroupResponse).annotate({ "description": "Groups returned in the current page." }),
  "has_more": Schema.Boolean.annotate({ "description": "Whether additional groups are available when paginating." }),
  "next": Schema.Union([Schema.String, Schema.Null]).annotate({
    "description": "Cursor to fetch the next page of results, or `null` if there are no more results."
  })
}).annotate({ "description": "Paginated list of organization groups." })
export type ImageEditCompletedEvent = {
  readonly "type": "image_edit.completed"
  readonly "b64_json": string
  readonly "created_at": number
  readonly "size": "1024x1024" | "1024x1536" | "1536x1024" | "auto"
  readonly "quality": "low" | "medium" | "high" | "auto"
  readonly "background": "transparent" | "opaque" | "auto"
  readonly "output_format": "png" | "webp" | "jpeg"
  readonly "usage": ImagesUsage
}
export const ImageEditCompletedEvent = Schema.Struct({
  "type": Schema.Literal("image_edit.completed").annotate({
    "description": "The type of the event. Always `image_edit.completed`.\n"
  }),
  "b64_json": Schema.String.annotate({
    "description": "Base64-encoded final edited image data, suitable for rendering as an image.\n"
  }),
  "created_at": Schema.Number.annotate({ "description": "The Unix timestamp when the event was created.\n" }).check(
    Schema.isInt()
  ),
  "size": Schema.Literals(["1024x1024", "1024x1536", "1536x1024", "auto"]).annotate({
    "description": "The size of the edited image.\n"
  }),
  "quality": Schema.Literals(["low", "medium", "high", "auto"]).annotate({
    "description": "The quality setting for the edited image.\n"
  }),
  "background": Schema.Literals(["transparent", "opaque", "auto"]).annotate({
    "description": "The background setting for the edited image.\n"
  }),
  "output_format": Schema.Literals(["png", "webp", "jpeg"]).annotate({
    "description": "The output format for the edited image.\n"
  }),
  "usage": ImagesUsage
}).annotate({ "description": "Emitted when image editing has completed and the final image is available.\n" })
export type ImageGenCompletedEvent = {
  readonly "type": "image_generation.completed"
  readonly "b64_json": string
  readonly "created_at": number
  readonly "size": "1024x1024" | "1024x1536" | "1536x1024" | "auto"
  readonly "quality": "low" | "medium" | "high" | "auto"
  readonly "background": "transparent" | "opaque" | "auto"
  readonly "output_format": "png" | "webp" | "jpeg"
  readonly "usage": ImagesUsage
}
export const ImageGenCompletedEvent = Schema.Struct({
  "type": Schema.Literal("image_generation.completed").annotate({
    "description": "The type of the event. Always `image_generation.completed`.\n"
  }),
  "b64_json": Schema.String.annotate({
    "description": "Base64-encoded image data, suitable for rendering as an image.\n"
  }),
  "created_at": Schema.Number.annotate({ "description": "The Unix timestamp when the event was created.\n" }).check(
    Schema.isInt()
  ),
  "size": Schema.Literals(["1024x1024", "1024x1536", "1536x1024", "auto"]).annotate({
    "description": "The size of the generated image.\n"
  }),
  "quality": Schema.Literals(["low", "medium", "high", "auto"]).annotate({
    "description": "The quality setting for the generated image.\n"
  }),
  "background": Schema.Literals(["transparent", "opaque", "auto"]).annotate({
    "description": "The background setting for the generated image.\n"
  }),
  "output_format": Schema.Literals(["png", "webp", "jpeg"]).annotate({
    "description": "The output format for the generated image.\n"
  }),
  "usage": ImagesUsage
}).annotate({ "description": "Emitted when image generation has completed and the final image is available.\n" })
export type InviteListResponse = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<Invite>
  readonly "first_id"?: string
  readonly "last_id"?: string
  readonly "has_more"?: boolean
}
export const InviteListResponse = Schema.Struct({
  "object": Schema.Literal("list").annotate({ "description": "The object type, which is always `list`" }),
  "data": Schema.Array(Invite),
  "first_id": Schema.optionalKey(
    Schema.String.annotate({ "description": "The first `invite_id` in the retrieved `list`" })
  ),
  "last_id": Schema.optionalKey(
    Schema.String.annotate({ "description": "The last `invite_id` in the retrieved `list`" })
  ),
  "has_more": Schema.optionalKey(
    Schema.Boolean.annotate({
      "description": "The `has_more` property is used for pagination to indicate there are additional results."
    })
  )
})
export type RealtimeServerEventConversationItemInputAudioTranscriptionCompleted = {
  readonly "event_id": string
  readonly "type": "conversation.item.input_audio_transcription.completed"
  readonly "item_id": string
  readonly "content_index": number
  readonly "transcript": string
  readonly "logprobs"?: ReadonlyArray<LogProbProperties> | null
  readonly "usage": {
    readonly "type": "tokens"
    readonly "input_tokens": number
    readonly "input_token_details"?: { readonly "text_tokens"?: number; readonly "audio_tokens"?: number }
    readonly "output_tokens": number
    readonly "total_tokens": number
  } | { readonly "type": "duration"; readonly "seconds": number }
}
export const RealtimeServerEventConversationItemInputAudioTranscriptionCompleted = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("conversation.item.input_audio_transcription.completed").annotate({
    "description": "The event type, must be\n`conversation.item.input_audio_transcription.completed`.\n"
  }),
  "item_id": Schema.String.annotate({
    "description": "The ID of the item containing the audio that is being transcribed."
  }),
  "content_index": Schema.Number.annotate({ "description": "The index of the content part containing the audio." })
    .check(Schema.isInt()),
  "transcript": Schema.String.annotate({ "description": "The transcribed text." }),
  "logprobs": Schema.optionalKey(
    Schema.Union([
      Schema.Array(LogProbProperties).annotate({ "description": "The log probabilities of the transcription." }),
      Schema.Null
    ])
  ),
  "usage": Schema.Union([
    Schema.Struct({
      "type": Schema.Literal("tokens").annotate({
        "description": "The type of the usage object. Always `tokens` for this variant."
      }),
      "input_tokens": Schema.Number.annotate({ "description": "Number of input tokens billed for this request." })
        .check(Schema.isInt()),
      "input_token_details": Schema.optionalKey(
        Schema.Struct({
          "text_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "Number of text tokens billed for this request." }).check(
              Schema.isInt()
            )
          ),
          "audio_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "Number of audio tokens billed for this request." }).check(
              Schema.isInt()
            )
          )
        }).annotate({ "description": "Details about the input tokens billed for this request." })
      ),
      "output_tokens": Schema.Number.annotate({ "description": "Number of output tokens generated." }).check(
        Schema.isInt()
      ),
      "total_tokens": Schema.Number.annotate({ "description": "Total number of tokens used (input + output)." }).check(
        Schema.isInt()
      )
    }).annotate({ "title": "Token Usage", "description": "Usage statistics for models billed by token usage." }),
    Schema.Struct({
      "type": Schema.Literal("duration").annotate({
        "description": "The type of the usage object. Always `duration` for this variant."
      }),
      "seconds": Schema.Number.annotate({ "description": "Duration of the input audio in seconds." }).check(
        Schema.isFinite()
      )
    }).annotate({
      "title": "Duration Usage",
      "description": "Usage statistics for models billed by audio input duration."
    })
  ], { mode: "oneOf" }).annotate({
    "description":
      "Usage statistics for the transcription, this is billed according to the ASR model's pricing rather than the realtime model's pricing."
  })
}).annotate({
  "description":
    "This event is the output of audio transcription for user audio written to the\nuser audio buffer. Transcription begins when the input audio buffer is\ncommitted by the client or server (when VAD is enabled). Transcription runs\nasynchronously with Response creation, so this event may come before or after\nthe Response events.\n\nRealtime API models accept audio natively, and thus input transcription is a\nseparate process run on a separate ASR (Automatic Speech Recognition) model.\nThe transcript may diverge somewhat from the model's interpretation, and\nshould be treated as a rough guide.\n"
})
export type RealtimeServerEventConversationItemInputAudioTranscriptionDelta = {
  readonly "event_id": string
  readonly "type": "conversation.item.input_audio_transcription.delta"
  readonly "item_id": string
  readonly "content_index"?: number
  readonly "delta"?: string
  readonly "logprobs"?: ReadonlyArray<LogProbProperties> | null
}
export const RealtimeServerEventConversationItemInputAudioTranscriptionDelta = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("conversation.item.input_audio_transcription.delta").annotate({
    "description": "The event type, must be `conversation.item.input_audio_transcription.delta`."
  }),
  "item_id": Schema.String.annotate({
    "description": "The ID of the item containing the audio that is being transcribed."
  }),
  "content_index": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(
      Schema.isInt()
    )
  ),
  "delta": Schema.optionalKey(Schema.String.annotate({ "description": "The text delta." })),
  "logprobs": Schema.optionalKey(Schema.Union([
    Schema.Array(LogProbProperties).annotate({
      "description":
        "The log probabilities of the transcription. These can be enabled by configurating the session with `\"include\": [\"item.input_audio_transcription.logprobs\"]`. Each entry in the array corresponds a log probability of which token would be selected for this chunk of transcription. This can help to identify if it was possible there were multiple valid options for a given chunk of transcription."
    }),
    Schema.Null
  ]))
}).annotate({
  "description":
    "Returned when the text value of an input audio transcription content part is updated with incremental transcription results.\n"
})
export type MCPListTools = {
  readonly "type": "mcp_list_tools"
  readonly "id": string
  readonly "server_label": string
  readonly "tools": ReadonlyArray<MCPListToolsTool>
  readonly "error"?: string | null
}
export const MCPListTools = Schema.Struct({
  "type": Schema.Literal("mcp_list_tools").annotate({
    "description": "The type of the item. Always `mcp_list_tools`.\n"
  }),
  "id": Schema.String.annotate({ "description": "The unique ID of the list.\n" }),
  "server_label": Schema.String.annotate({ "description": "The label of the MCP server.\n" }),
  "tools": Schema.Array(MCPListToolsTool).annotate({ "description": "The tools available on the server.\n" }),
  "error": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "Error message if the server could not list tools.\n" }),
      Schema.Null
    ])
  )
}).annotate({ "title": "MCP list tools", "description": "A list of tools available on an MCP server.\n" })
export type RealtimeMCPListTools = {
  readonly "type": "mcp_list_tools"
  readonly "id"?: string
  readonly "server_label": string
  readonly "tools": ReadonlyArray<MCPListToolsTool>
}
export const RealtimeMCPListTools = Schema.Struct({
  "type": Schema.Literal("mcp_list_tools").annotate({
    "description": "The type of the item. Always `mcp_list_tools`."
  }),
  "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the list." })),
  "server_label": Schema.String.annotate({ "description": "The label of the MCP server." }),
  "tools": Schema.Array(MCPListToolsTool).annotate({ "description": "The tools available on the server." })
}).annotate({
  "title": "Realtime MCP list tools",
  "description": "A Realtime item listing tools available on an MCP server.\n"
})
export type MCPTool = {
  readonly "type": "mcp"
  readonly "server_label": string
  readonly "server_url"?: string
  readonly "connector_id"?:
    | "connector_dropbox"
    | "connector_gmail"
    | "connector_googlecalendar"
    | "connector_googledrive"
    | "connector_microsoftteams"
    | "connector_outlookcalendar"
    | "connector_outlookemail"
    | "connector_sharepoint"
  readonly "authorization"?: string
  readonly "server_description"?: string
  readonly "headers"?: {} | null
  readonly "allowed_tools"?: ReadonlyArray<string> | MCPToolFilter | null
  readonly "require_approval"?:
    | { readonly "always"?: MCPToolFilter; readonly "never"?: MCPToolFilter }
    | "always"
    | "never"
    | null
}
export const MCPTool = Schema.Struct({
  "type": Schema.Literal("mcp").annotate({ "description": "The type of the MCP tool. Always `mcp`." }),
  "server_label": Schema.String.annotate({
    "description": "A label for this MCP server, used to identify it in tool calls.\n"
  }),
  "server_url": Schema.optionalKey(
    Schema.String.annotate({
      "description": "The URL for the MCP server. One of `server_url` or `connector_id` must be\nprovided.\n"
    })
  ),
  "connector_id": Schema.optionalKey(
    Schema.Literals([
      "connector_dropbox",
      "connector_gmail",
      "connector_googlecalendar",
      "connector_googledrive",
      "connector_microsoftteams",
      "connector_outlookcalendar",
      "connector_outlookemail",
      "connector_sharepoint"
    ]).annotate({
      "description":
        "Identifier for service connectors, like those available in ChatGPT. One of\n`server_url` or `connector_id` must be provided. Learn more about service\nconnectors [here](/docs/guides/tools-remote-mcp#connectors).\n\nCurrently supported `connector_id` values are:\n\n- Dropbox: `connector_dropbox`\n- Gmail: `connector_gmail`\n- Google Calendar: `connector_googlecalendar`\n- Google Drive: `connector_googledrive`\n- Microsoft Teams: `connector_microsoftteams`\n- Outlook Calendar: `connector_outlookcalendar`\n- Outlook Email: `connector_outlookemail`\n- SharePoint: `connector_sharepoint`\n"
    })
  ),
  "authorization": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "An OAuth access token that can be used with a remote MCP server, either\nwith a custom MCP server URL or a service connector. Your application\nmust handle the OAuth authorization flow and provide the token here.\n"
    })
  ),
  "server_description": Schema.optionalKey(
    Schema.String.annotate({ "description": "Optional description of the MCP server, used to provide more context.\n" })
  ),
  "headers": Schema.optionalKey(
    Schema.Union([
      Schema.Struct({}).annotate({
        "description": "Optional HTTP headers to send to the MCP server. Use for authentication\nor other purposes.\n"
      }),
      Schema.Null
    ])
  ),
  "allowed_tools": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        Schema.Array(Schema.String).annotate({
          "title": "MCP allowed tools",
          "description": "A string array of allowed tool names"
        }),
        MCPToolFilter
      ], { mode: "oneOf" }).annotate({ "description": "List of allowed tool names or a filter object.\n" }),
      Schema.Null
    ])
  ),
  "require_approval": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        Schema.Struct({ "always": Schema.optionalKey(MCPToolFilter), "never": Schema.optionalKey(MCPToolFilter) })
          .annotate({
            "title": "MCP tool approval filter",
            "description":
              "Specify which of the MCP server's tools require approval. Can be\n`always`, `never`, or a filter object associated with tools\nthat require approval.\n"
          }),
        Schema.Literals(["always", "never"]).annotate({
          "title": "MCP tool approval setting",
          "description":
            "Specify a single approval policy for all tools. One of `always` or\n`never`. When set to `always`, all tools will require approval. When\nset to `never`, all tools will not require approval.\n"
        })
      ], { mode: "oneOf" }).annotate({ "description": "Specify which of the MCP server's tools require approval." }),
      Schema.Null
    ])
  )
}).annotate({
  "title": "MCP tool",
  "description":
    "Give the model access to additional tools via remote Model Context Protocol\n(MCP) servers. [Learn more about MCP](/docs/guides/tools-remote-mcp).\n"
})
export type MessageContentTextObject = {
  readonly "type": "text"
  readonly "text": {
    readonly "value": string
    readonly "annotations": ReadonlyArray<
      MessageContentTextAnnotationsFileCitationObject | MessageContentTextAnnotationsFilePathObject
    >
  }
}
export const MessageContentTextObject = Schema.Struct({
  "type": Schema.Literal("text").annotate({ "description": "Always `text`." }),
  "text": Schema.Struct({
    "value": Schema.String.annotate({ "description": "The data that makes up the text." }),
    "annotations": Schema.Array(
      Schema.Union([MessageContentTextAnnotationsFileCitationObject, MessageContentTextAnnotationsFilePathObject], {
        mode: "oneOf"
      })
    )
  })
}).annotate({ "title": "Text", "description": "The text content that is part of a message." })
export type MessageDeltaContentTextObject = {
  readonly "index": number
  readonly "type": "text"
  readonly "text"?: {
    readonly "value"?: string
    readonly "annotations"?: ReadonlyArray<
      MessageDeltaContentTextAnnotationsFileCitationObject | MessageDeltaContentTextAnnotationsFilePathObject
    >
  }
}
export const MessageDeltaContentTextObject = Schema.Struct({
  "index": Schema.Number.annotate({ "description": "The index of the content part in the message." }).check(
    Schema.isInt()
  ),
  "type": Schema.Literal("text").annotate({ "description": "Always `text`." }),
  "text": Schema.optionalKey(Schema.Struct({
    "value": Schema.optionalKey(Schema.String.annotate({ "description": "The data that makes up the text." })),
    "annotations": Schema.optionalKey(
      Schema.Array(
        Schema.Union([
          MessageDeltaContentTextAnnotationsFileCitationObject,
          MessageDeltaContentTextAnnotationsFilePathObject
        ], { mode: "oneOf" })
      )
    )
  }))
}).annotate({ "title": "Text", "description": "The text content that is part of a message." })
export type Batch = {
  readonly "id": string
  readonly "object": "batch"
  readonly "endpoint": string
  readonly "model"?: string
  readonly "errors"?: {
    readonly "object"?: string
    readonly "data"?: ReadonlyArray<
      {
        readonly "code"?: string
        readonly "message"?: string
        readonly "param"?: string | null
        readonly "line"?: number | null
      }
    >
  }
  readonly "input_file_id": string
  readonly "completion_window": string
  readonly "status":
    | "validating"
    | "failed"
    | "in_progress"
    | "finalizing"
    | "completed"
    | "expired"
    | "cancelling"
    | "cancelled"
  readonly "output_file_id"?: string
  readonly "error_file_id"?: string
  readonly "created_at": number
  readonly "in_progress_at"?: number
  readonly "expires_at"?: number
  readonly "finalizing_at"?: number
  readonly "completed_at"?: number
  readonly "failed_at"?: number
  readonly "expired_at"?: number
  readonly "cancelling_at"?: number
  readonly "cancelled_at"?: number
  readonly "request_counts"?: { readonly "total": number; readonly "completed": number; readonly "failed": number }
  readonly "usage"?: {
    readonly "input_tokens": number
    readonly "input_tokens_details": { readonly "cached_tokens": number }
    readonly "output_tokens": number
    readonly "output_tokens_details": { readonly "reasoning_tokens": number }
    readonly "total_tokens": number
  }
  readonly "metadata"?: Metadata
}
export const Batch = Schema.Struct({
  "id": Schema.String,
  "object": Schema.Literal("batch").annotate({ "description": "The object type, which is always `batch`." }),
  "endpoint": Schema.String.annotate({ "description": "The OpenAI API endpoint used by the batch." }),
  "model": Schema.optionalKey(Schema.String.annotate({
    "description":
      "Model ID used to process the batch, like `gpt-5-2025-08-07`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model\nguide](/docs/models) to browse and compare available models.\n"
  })),
  "errors": Schema.optionalKey(Schema.Struct({
    "object": Schema.optionalKey(Schema.String.annotate({ "description": "The object type, which is always `list`." })),
    "data": Schema.optionalKey(Schema.Array(Schema.Struct({
      "code": Schema.optionalKey(
        Schema.String.annotate({ "description": "An error code identifying the error type." })
      ),
      "message": Schema.optionalKey(
        Schema.String.annotate({ "description": "A human-readable message providing more details about the error." })
      ),
      "param": Schema.optionalKey(
        Schema.Union([
          Schema.String.annotate({ "description": "The name of the parameter that caused the error, if applicable." }),
          Schema.Null
        ])
      ),
      "line": Schema.optionalKey(
        Schema.Union([
          Schema.Number.annotate({
            "description": "The line number of the input file where the error occurred, if applicable."
          }).check(Schema.isInt()),
          Schema.Null
        ])
      )
    })))
  })),
  "input_file_id": Schema.String.annotate({ "description": "The ID of the input file for the batch." }),
  "completion_window": Schema.String.annotate({
    "description": "The time frame within which the batch should be processed."
  }),
  "status": Schema.Literals([
    "validating",
    "failed",
    "in_progress",
    "finalizing",
    "completed",
    "expired",
    "cancelling",
    "cancelled"
  ]).annotate({ "description": "The current status of the batch." }),
  "output_file_id": Schema.optionalKey(
    Schema.String.annotate({
      "description": "The ID of the file containing the outputs of successfully executed requests."
    })
  ),
  "error_file_id": Schema.optionalKey(
    Schema.String.annotate({ "description": "The ID of the file containing the outputs of requests with errors." })
  ),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the batch was created."
  }).check(Schema.isInt()),
  "in_progress_at": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch started processing." })
      .check(Schema.isInt())
  ),
  "expires_at": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch will expire." }).check(
      Schema.isInt()
    )
  ),
  "finalizing_at": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch started finalizing." })
      .check(Schema.isInt())
  ),
  "completed_at": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch was completed." })
      .check(Schema.isInt())
  ),
  "failed_at": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch failed." }).check(
      Schema.isInt()
    )
  ),
  "expired_at": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch expired." }).check(
      Schema.isInt()
    )
  ),
  "cancelling_at": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch started cancelling." })
      .check(Schema.isInt())
  ),
  "cancelled_at": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch was cancelled." })
      .check(Schema.isInt())
  ),
  "request_counts": Schema.optionalKey(
    Schema.Struct({
      "total": Schema.Number.annotate({ "description": "Total number of requests in the batch." }).check(
        Schema.isInt()
      ),
      "completed": Schema.Number.annotate({
        "description": "Number of requests that have been completed successfully."
      }).check(Schema.isInt()),
      "failed": Schema.Number.annotate({ "description": "Number of requests that have failed." }).check(Schema.isInt())
    }).annotate({ "description": "The request counts for different statuses within the batch." })
  ),
  "usage": Schema.optionalKey(
    Schema.Struct({
      "input_tokens": Schema.Number.annotate({ "description": "The number of input tokens." }).check(Schema.isInt()),
      "input_tokens_details": Schema.Struct({
        "cached_tokens": Schema.Number.annotate({
          "description":
            "The number of tokens that were retrieved from the cache. [More on\nprompt caching](/docs/guides/prompt-caching).\n"
        }).check(Schema.isInt())
      }).annotate({ "description": "A detailed breakdown of the input tokens." }),
      "output_tokens": Schema.Number.annotate({ "description": "The number of output tokens." }).check(Schema.isInt()),
      "output_tokens_details": Schema.Struct({
        "reasoning_tokens": Schema.Number.annotate({ "description": "The number of reasoning tokens." }).check(
          Schema.isInt()
        )
      }).annotate({ "description": "A detailed breakdown of the output tokens." }),
      "total_tokens": Schema.Number.annotate({ "description": "The total number of tokens used." }).check(
        Schema.isInt()
      )
    }).annotate({
      "description":
        "Represents token usage details including input tokens, output tokens, a\nbreakdown of output tokens, and the total tokens used. Only populated on\nbatches created after September 7, 2025.\n"
    })
  ),
  "metadata": Schema.optionalKey(Metadata)
})
export type CreateMessageRequest = {
  readonly "role": "user" | "assistant"
  readonly "content":
    | string
    | ReadonlyArray<MessageContentImageFileObject | MessageContentImageUrlObject | MessageRequestContentTextObject>
  readonly "attachments"?:
    | ReadonlyArray<
      {
        readonly "file_id"?: string
        readonly "tools"?: ReadonlyArray<AssistantToolsCode | AssistantToolsFileSearchTypeOnly>
      }
    >
    | null
  readonly "metadata"?: Metadata
}
export const CreateMessageRequest = Schema.Struct({
  "role": Schema.Literals(["user", "assistant"]).annotate({
    "description":
      "The role of the entity that is creating the message. Allowed values include:\n- `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages.\n- `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation.\n"
  }),
  "content": Schema.Union([
    Schema.String.annotate({ "title": "Text content", "description": "The text contents of the message." }),
    Schema.Array(
      Schema.Union([MessageContentImageFileObject, MessageContentImageUrlObject, MessageRequestContentTextObject], {
        mode: "oneOf"
      })
    ).annotate({
      "title": "Array of content parts",
      "description":
        "An array of content parts with a defined type, each can be of type `text` or images can be passed with `image_url` or `image_file`. Image types are only supported on [Vision-compatible models](/docs/models)."
    }).check(Schema.isMinLength(1))
  ], { mode: "oneOf" }),
  "attachments": Schema.optionalKey(Schema.Union([
    Schema.Array(Schema.Struct({
      "file_id": Schema.optionalKey(
        Schema.String.annotate({ "description": "The ID of the file to attach to the message." })
      ),
      "tools": Schema.optionalKey(
        Schema.Array(Schema.Union([AssistantToolsCode, AssistantToolsFileSearchTypeOnly], { mode: "oneOf" })).annotate({
          "description": "The tools to add this file to."
        })
      )
    })).annotate({ "description": "A list of files attached to the message, and the tools they should be added to." }),
    Schema.Null
  ])),
  "metadata": Schema.optionalKey(Metadata)
})
export type EvalLogsDataSourceConfig = {
  readonly "type": "logs"
  readonly "metadata"?: Metadata
  readonly "schema": {}
}
export const EvalLogsDataSourceConfig = Schema.Struct({
  "type": Schema.Literal("logs").annotate({ "description": "The type of data source. Always `logs`." }),
  "metadata": Schema.optionalKey(Metadata),
  "schema": Schema.Struct({}).annotate({
    "description":
      "The json schema for the run data source items.\nLearn how to build JSON schemas [here](https://json-schema.org/).\n"
  })
}).annotate({
  "title": "LogsDataSourceConfig",
  "description":
    "A LogsDataSourceConfig which specifies the metadata property of your logs query.\nThis is usually metadata like `usecase=chatbot` or `prompt-version=v2`, etc.\nThe schema returned by this data source config is used to defined what variables are available in your evals.\n`item` and `sample` are both defined when using this data source config.\n"
})
export type EvalStoredCompletionsDataSourceConfig = {
  readonly "type": "stored_completions"
  readonly "metadata"?: Metadata
  readonly "schema": {}
}
export const EvalStoredCompletionsDataSourceConfig = Schema.Struct({
  "type": Schema.Literal("stored_completions").annotate({
    "description": "The type of data source. Always `stored_completions`."
  }),
  "metadata": Schema.optionalKey(Metadata),
  "schema": Schema.Struct({}).annotate({
    "description":
      "The json schema for the run data source items.\nLearn how to build JSON schemas [here](https://json-schema.org/).\n"
  })
}).annotate({
  "title": "StoredCompletionsDataSourceConfig",
  "description": "Deprecated in favor of LogsDataSourceConfig.\n"
})
export type EvalStoredCompletionsSource = {
  readonly "type": "stored_completions"
  readonly "metadata"?: Metadata
  readonly "model"?: string | null
  readonly "created_after"?: number | null
  readonly "created_before"?: number | null
  readonly "limit"?: number | null
}
export const EvalStoredCompletionsSource = Schema.Struct({
  "type": Schema.Literal("stored_completions").annotate({
    "description": "The type of source. Always `stored_completions`."
  }),
  "metadata": Schema.optionalKey(Metadata),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "An optional model to filter by (e.g., 'gpt-4o')." }),
      Schema.Null
    ])
  ),
  "created_after": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({ "description": "An optional Unix timestamp to filter items created after this time." })
        .check(Schema.isInt()),
      Schema.Null
    ])
  ),
  "created_before": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({ "description": "An optional Unix timestamp to filter items created before this time." })
        .check(Schema.isInt()),
      Schema.Null
    ])
  ),
  "limit": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({ "description": "An optional maximum number of items to return." }).check(Schema.isInt()),
      Schema.Null
    ])
  )
}).annotate({
  "title": "StoredCompletionsRunDataSource",
  "description": "A StoredCompletionsRunDataSource configuration describing a set of filters\n"
})
export type ModifyMessageRequest = { readonly "metadata"?: Metadata }
export const ModifyMessageRequest = Schema.Struct({ "metadata": Schema.optionalKey(Metadata) })
export type ModifyRunRequest = { readonly "metadata"?: Metadata }
export const ModifyRunRequest = Schema.Struct({ "metadata": Schema.optionalKey(Metadata) })
export type ModifyThreadRequest = {
  readonly "tool_resources"?: {
    readonly "code_interpreter"?: { readonly "file_ids"?: ReadonlyArray<string> }
    readonly "file_search"?: { readonly "vector_store_ids"?: ReadonlyArray<string> }
  } | null
  readonly "metadata"?: Metadata
}
export const ModifyThreadRequest = Schema.Struct({
  "tool_resources": Schema.optionalKey(Schema.Union([
    Schema.Struct({
      "code_interpreter": Schema.optionalKey(Schema.Struct({
        "file_ids": Schema.optionalKey(
          Schema.Array(Schema.String).annotate({
            "description":
              "A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"
          }).check(Schema.isMaxLength(20))
        )
      })),
      "file_search": Schema.optionalKey(Schema.Struct({
        "vector_store_ids": Schema.optionalKey(
          Schema.Array(Schema.String).annotate({
            "description":
              "The [vector store](/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.\n"
          }).check(Schema.isMaxLength(1))
        )
      }))
    }).annotate({
      "description":
        "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"
    }),
    Schema.Null
  ])),
  "metadata": Schema.optionalKey(Metadata)
})
export type ThreadObject = {
  readonly "id": string
  readonly "object": "thread"
  readonly "created_at": number
  readonly "tool_resources": {
    readonly "code_interpreter"?: { readonly "file_ids"?: ReadonlyArray<string> }
    readonly "file_search"?: { readonly "vector_store_ids"?: ReadonlyArray<string> }
  } | null
  readonly "metadata": Metadata
}
export const ThreadObject = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints." }),
  "object": Schema.Literal("thread").annotate({ "description": "The object type, which is always `thread`." }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the thread was created."
  }).check(Schema.isInt()),
  "tool_resources": Schema.Union([
    Schema.Struct({
      "code_interpreter": Schema.optionalKey(Schema.Struct({
        "file_ids": Schema.optionalKey(
          Schema.Array(Schema.String).annotate({
            "description":
              "A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"
          }).check(Schema.isMaxLength(20))
        )
      })),
      "file_search": Schema.optionalKey(Schema.Struct({
        "vector_store_ids": Schema.optionalKey(
          Schema.Array(Schema.String).annotate({
            "description":
              "The [vector store](/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.\n"
          }).check(Schema.isMaxLength(1))
        )
      }))
    }).annotate({
      "description":
        "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"
    }),
    Schema.Null
  ]),
  "metadata": Metadata
}).annotate({
  "title": "Thread",
  "description": "Represents a thread that contains [messages](/docs/api-reference/messages)."
})
export type UpdateVectorStoreRequest = {
  readonly "name"?: string | null
  readonly "expires_after"?: { readonly "anchor": "last_active_at"; readonly "days": number }
  readonly "metadata"?: Metadata
}
export const UpdateVectorStoreRequest = Schema.Struct({
  "name": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "The name of the vector store." })
  ),
  "expires_after": Schema.optionalKey(Schema.Union([
    Schema.Struct({
      "anchor": Schema.Literal("last_active_at").annotate({
        "description":
          "Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`."
      }),
      "days": Schema.Number.annotate({
        "description": "The number of days after the anchor time that the vector store will expire."
      }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(Schema.isLessThanOrEqualTo(365))
    }).annotate({
      "title": "Vector store expiration policy",
      "description": "The expiration policy for a vector store."
    })
  ])),
  "metadata": Schema.optionalKey(Metadata)
})
export type ListModelsResponse = { readonly "object": "list"; readonly "data": ReadonlyArray<Model> }
export const ListModelsResponse = Schema.Struct({ "object": Schema.Literal("list"), "data": Schema.Array(Model) })
export type ModelIdsResponses =
  | ModelIdsShared
  | "o1-pro"
  | "o1-pro-2025-03-19"
  | "o3-pro"
  | "o3-pro-2025-06-10"
  | "o3-deep-research"
  | "o3-deep-research-2025-06-26"
  | "o4-mini-deep-research"
  | "o4-mini-deep-research-2025-06-26"
  | "computer-use-preview"
  | "computer-use-preview-2025-03-11"
  | "gpt-5-codex"
  | "gpt-5-pro"
  | "gpt-5-pro-2025-10-06"
  | "gpt-5.1-codex-max"
export const ModelIdsResponses = Schema.Union([
  ModelIdsShared,
  Schema.Literals([
    "o1-pro",
    "o1-pro-2025-03-19",
    "o3-pro",
    "o3-pro-2025-06-10",
    "o3-deep-research",
    "o3-deep-research-2025-06-26",
    "o4-mini-deep-research",
    "o4-mini-deep-research-2025-06-26",
    "computer-use-preview",
    "computer-use-preview-2025-03-11",
    "gpt-5-codex",
    "gpt-5-pro",
    "gpt-5-pro-2025-10-06",
    "gpt-5.1-codex-max"
  ]).annotate({ "title": "ResponsesOnlyModel" })
])
export type RealtimeTranscriptionSessionCreateRequest = {
  readonly "turn_detection"?: {
    readonly "type"?: "server_vad"
    readonly "threshold"?: number
    readonly "prefix_padding_ms"?: number
    readonly "silence_duration_ms"?: number
  }
  readonly "input_audio_noise_reduction"?: { readonly "type"?: NoiseReductionType }
  readonly "input_audio_format"?: "pcm16" | "g711_ulaw" | "g711_alaw"
  readonly "input_audio_transcription"?: {
    readonly "model"?:
      | string
      | "whisper-1"
      | "gpt-4o-mini-transcribe"
      | "gpt-4o-mini-transcribe-2025-12-15"
      | "gpt-4o-transcribe"
      | "gpt-4o-transcribe-diarize"
    readonly "language"?: string
    readonly "prompt"?: string
  }
  readonly "include"?: ReadonlyArray<"item.input_audio_transcription.logprobs">
}
export const RealtimeTranscriptionSessionCreateRequest = Schema.Struct({
  "turn_detection": Schema.optionalKey(
    Schema.Struct({
      "type": Schema.optionalKey(
        Schema.Literal("server_vad").annotate({
          "description":
            "Type of turn detection. Only `server_vad` is currently supported for transcription sessions.\n"
        })
      ),
      "threshold": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\nhigher threshold will require louder audio to activate the model, and\nthus might perform better in noisy environments.\n"
        }).check(Schema.isFinite())
      ),
      "prefix_padding_ms": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "Amount of audio to include before the VAD detected speech (in\nmilliseconds). Defaults to 300ms.\n"
        }).check(Schema.isInt())
      ),
      "silence_duration_ms": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "Duration of silence to detect speech stop (in milliseconds). Defaults\nto 500ms. With shorter values the model will respond more quickly,\nbut may jump in on short pauses from the user.\n"
        }).check(Schema.isInt())
      )
    }).annotate({
      "description":
        "Configuration for turn detection. Can be set to `null` to turn off. Server VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\n"
    })
  ),
  "input_audio_noise_reduction": Schema.optionalKey(
    Schema.Struct({ "type": Schema.optionalKey(NoiseReductionType) }).annotate({
      "description":
        "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"
    })
  ),
  "input_audio_format": Schema.optionalKey(
    Schema.Literals(["pcm16", "g711_ulaw", "g711_alaw"]).annotate({
      "description":
        "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate,\nsingle channel (mono), and little-endian byte order.\n"
    })
  ),
  "input_audio_transcription": Schema.optionalKey(
    Schema.Struct({
      "model": Schema.optionalKey(
        Schema.Union([
          Schema.String,
          Schema.Literals([
            "whisper-1",
            "gpt-4o-mini-transcribe",
            "gpt-4o-mini-transcribe-2025-12-15",
            "gpt-4o-transcribe",
            "gpt-4o-transcribe-diarize"
          ])
        ]).annotate({
          "description":
            "The model to use for transcription. Current options are `whisper-1`, `gpt-4o-mini-transcribe`, `gpt-4o-mini-transcribe-2025-12-15`, `gpt-4o-transcribe`, and `gpt-4o-transcribe-diarize`. Use `gpt-4o-transcribe-diarize` when you need diarization with speaker labels.\n"
        })
      ),
      "language": Schema.optionalKey(
        Schema.String.annotate({
          "description":
            "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"
        })
      ),
      "prompt": Schema.optionalKey(Schema.String.annotate({
        "description":
          "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models (excluding `gpt-4o-transcribe-diarize`), the prompt is a free text string, for example \"expect words related to technology\".\n"
      }))
    }).annotate({
      "description":
        "Configuration for input audio transcription. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"
    })
  ),
  "include": Schema.optionalKey(
    Schema.Array(Schema.Literal("item.input_audio_transcription.logprobs")).annotate({
      "description":
        "The set of items to include in the transcription. Current available items are:\n`item.input_audio_transcription.logprobs`\n"
    })
  )
}).annotate({
  "title": "Realtime transcription session configuration",
  "description": "Realtime transcription session object configuration."
})
export type ListFilesResponse = {
  readonly "object": string
  readonly "data": ReadonlyArray<OpenAIFile>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const ListFilesResponse = Schema.Struct({
  "object": Schema.String,
  "data": Schema.Array(OpenAIFile),
  "first_id": Schema.String,
  "last_id": Schema.String,
  "has_more": Schema.Boolean
})
export type CreateImageRequest = {
  readonly "prompt": string
  readonly "model"?: string | "gpt-image-1.5" | "dall-e-2" | "dall-e-3" | "gpt-image-1" | "gpt-image-1-mini" | null
  readonly "n"?: number | null
  readonly "quality"?: "standard" | "hd" | "low" | "medium" | "high" | "auto" | null
  readonly "response_format"?: "url" | "b64_json" | null
  readonly "output_format"?: "png" | "jpeg" | "webp" | null
  readonly "output_compression"?: number | null
  readonly "stream"?: boolean | null
  readonly "partial_images"?: PartialImages
  readonly "size"?:
    | "auto"
    | "1024x1024"
    | "1536x1024"
    | "1024x1536"
    | "256x256"
    | "512x512"
    | "1792x1024"
    | "1024x1792"
    | null
  readonly "moderation"?: "low" | "auto" | null
  readonly "background"?: "transparent" | "opaque" | "auto" | null
  readonly "style"?: "vivid" | "natural" | null
  readonly "user"?: string
}
export const CreateImageRequest = Schema.Struct({
  "prompt": Schema.String.annotate({
    "description":
      "A text description of the desired image(s). The maximum length is 32000 characters for the GPT image models, 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`."
  }),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        Schema.String,
        Schema.Literals(["gpt-image-1.5", "dall-e-2", "dall-e-3", "gpt-image-1", "gpt-image-1-mini"])
      ]).annotate({
        "description":
          "The model to use for image generation. One of `dall-e-2`, `dall-e-3`, or a GPT image model (`gpt-image-1`, `gpt-image-1-mini`, `gpt-image-1.5`). Defaults to `dall-e-2` unless a parameter specific to the GPT image models is used."
      }),
      Schema.Null
    ])
  ),
  "n": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported."
    })
  ),
  "quality": Schema.optionalKey(
    Schema.Union([
      Schema.Literal("standard"),
      Schema.Literal("hd"),
      Schema.Literal("low"),
      Schema.Literal("medium"),
      Schema.Literal("high"),
      Schema.Literal("auto"),
      Schema.Null
    ]).annotate({
      "description":
        "The quality of the image that will be generated.\n\n- `auto` (default value) will automatically select the best quality for the given model.\n- `high`, `medium` and `low` are supported for the GPT image models.\n- `hd` and `standard` are supported for `dall-e-3`.\n- `standard` is the only option for `dall-e-2`.\n"
    })
  ),
  "response_format": Schema.optionalKey(
    Schema.Union([Schema.Literal("url"), Schema.Literal("b64_json"), Schema.Null]).annotate({
      "description":
        "The format in which generated images with `dall-e-2` and `dall-e-3` are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated. This parameter isn't supported for the GPT image models, which always return base64-encoded images."
    })
  ),
  "output_format": Schema.optionalKey(
    Schema.Union([Schema.Literal("png"), Schema.Literal("jpeg"), Schema.Literal("webp"), Schema.Null]).annotate({
      "description":
        "The format in which the generated images are returned. This parameter is only supported for the GPT image models. Must be one of `png`, `jpeg`, or `webp`."
    })
  ),
  "output_compression": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "The compression level (0-100%) for the generated images. This parameter is only supported for the GPT image models with the `webp` or `jpeg` output formats, and defaults to 100."
    })
  ),
  "stream": Schema.optionalKey(
    Schema.Union([Schema.Boolean, Schema.Null]).annotate({
      "description":
        "Generate the image in streaming mode. Defaults to `false`. See the\n[Image generation guide](/docs/guides/image-generation) for more information.\nThis parameter is only supported for the GPT image models.\n"
    })
  ),
  "partial_images": Schema.optionalKey(PartialImages),
  "size": Schema.optionalKey(
    Schema.Union([
      Schema.Literal("auto"),
      Schema.Literal("1024x1024"),
      Schema.Literal("1536x1024"),
      Schema.Literal("1024x1536"),
      Schema.Literal("256x256"),
      Schema.Literal("512x512"),
      Schema.Literal("1792x1024"),
      Schema.Literal("1024x1792"),
      Schema.Null
    ]).annotate({
      "description":
        "The size of the generated images. Must be one of `1024x1024`, `1536x1024` (landscape), `1024x1536` (portrait), or `auto` (default value) for the GPT image models, one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`, and one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3`."
    })
  ),
  "moderation": Schema.optionalKey(
    Schema.Union([Schema.Literal("low"), Schema.Literal("auto"), Schema.Null]).annotate({
      "description":
        "Control the content-moderation level for images generated by the GPT image models. Must be either `low` for less restrictive filtering or `auto` (default value)."
    })
  ),
  "background": Schema.optionalKey(
    Schema.Union([Schema.Literal("transparent"), Schema.Literal("opaque"), Schema.Literal("auto"), Schema.Null])
      .annotate({
        "description":
          "Allows to set transparency for the background of the generated image(s).\nThis parameter is only supported for the GPT image models. Must be one of\n`transparent`, `opaque` or `auto` (default value). When `auto` is used, the\nmodel will automatically determine the best background for the image.\n\nIf `transparent`, the output format needs to support transparency, so it\nshould be set to either `png` (default value) or `webp`.\n"
      })
  ),
  "style": Schema.optionalKey(
    Schema.Union([Schema.Literal("vivid"), Schema.Literal("natural"), Schema.Null]).annotate({
      "description":
        "The style of the generated images. This parameter is only supported for `dall-e-3`. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images."
    })
  ),
  "user": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).\n"
    })
  )
})
export type EditImageBodyJsonParam = {
  readonly "model"?: string | "gpt-image-1.5" | "gpt-image-1" | "gpt-image-1-mini" | "chatgpt-image-latest" | null
  readonly "images": ReadonlyArray<ImageRefParam>
  readonly "mask"?: ImageRefParam
  readonly "prompt": string
  readonly "n"?: number | null
  readonly "quality"?: "low" | "medium" | "high" | "auto" | null
  readonly "input_fidelity"?: "high" | "low" | null
  readonly "size"?: "auto" | "1024x1024" | "1536x1024" | "1024x1536" | null
  readonly "user"?: string
  readonly "output_format"?: "png" | "jpeg" | "webp" | null
  readonly "output_compression"?: number | null
  readonly "moderation"?: "low" | "auto" | null
  readonly "background"?: "transparent" | "opaque" | "auto" | null
  readonly "stream"?: boolean | null
  readonly "partial_images"?: PartialImages
}
export const EditImageBodyJsonParam = Schema.Struct({
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.String,
      Schema.Literals(["gpt-image-1.5", "gpt-image-1", "gpt-image-1-mini", "chatgpt-image-latest"]),
      Schema.Null
    ]).annotate({ "description": "The model to use for image editing." })
  ),
  "images": Schema.Array(ImageRefParam).annotate({
    "description": "Input image references to edit.\nFor GPT image models, you can provide up to 16 images.\n"
  }).check(Schema.isMinLength(1)).check(Schema.isMaxLength(16)),
  "mask": Schema.optionalKey(ImageRefParam),
  "prompt": Schema.String.annotate({ "description": "A text description of the desired image edit." }).check(
    Schema.isMinLength(1)
  ).check(Schema.isMaxLength(32000)),
  "n": Schema.optionalKey(
    Schema.Union([
      Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(Schema.isLessThanOrEqualTo(10)),
      Schema.Null
    ]).annotate({ "description": "The number of edited images to generate." })
  ),
  "quality": Schema.optionalKey(
    Schema.Union([Schema.Literals(["low", "medium", "high", "auto"]), Schema.Null]).annotate({
      "description": "Output quality for GPT image models.\n"
    })
  ),
  "input_fidelity": Schema.optionalKey(
    Schema.Union([Schema.Literals(["high", "low"]), Schema.Null]).annotate({
      "description": "Controls fidelity to the original input image(s)."
    })
  ),
  "size": Schema.optionalKey(
    Schema.Union([Schema.Literals(["auto", "1024x1024", "1536x1024", "1024x1536"]), Schema.Null]).annotate({
      "description": "Requested output image size."
    })
  ),
  "user": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "A unique identifier representing your end-user, which can help OpenAI\nmonitor and detect abuse.\n"
    })
  ),
  "output_format": Schema.optionalKey(
    Schema.Union([Schema.Literals(["png", "jpeg", "webp"]), Schema.Null]).annotate({
      "description": "Output image format. Supported for GPT image models."
    })
  ),
  "output_compression": Schema.optionalKey(
    Schema.Union([
      Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(
        Schema.isLessThanOrEqualTo(100)
      ),
      Schema.Null
    ]).annotate({ "description": "Compression level for `jpeg` or `webp` output." })
  ),
  "moderation": Schema.optionalKey(
    Schema.Union([Schema.Literals(["low", "auto"]), Schema.Null]).annotate({
      "description": "Moderation level for GPT image models."
    })
  ),
  "background": Schema.optionalKey(
    Schema.Union([Schema.Literals(["transparent", "opaque", "auto"]), Schema.Null]).annotate({
      "description": "Background behavior for generated image output."
    })
  ),
  "stream": Schema.optionalKey(
    Schema.Union([Schema.Boolean, Schema.Null]).annotate({ "description": "Stream partial image results as events." })
  ),
  "partial_images": Schema.optionalKey(PartialImages)
}).annotate({
  "description":
    "JSON request body for image edits.\n\nUse `images` (array of `ImageRefParam`) instead of multipart `image` uploads.\nYou can reference images via external URLs, data URLs, or uploaded file IDs.\nJSON edits support GPT image models only; DALL-E edits require multipart (`dall-e-2` only).\n"
})
export type ProjectListResponse = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<Project>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const ProjectListResponse = Schema.Struct({
  "object": Schema.Literal("list"),
  "data": Schema.Array(Project),
  "first_id": Schema.String,
  "last_id": Schema.String,
  "has_more": Schema.Boolean
})
export type ProjectGroupListResource = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<ProjectGroup>
  readonly "has_more": boolean
  readonly "next": string | null
}
export const ProjectGroupListResource = Schema.Struct({
  "object": Schema.Literal("list").annotate({ "description": "Always `list`." }),
  "data": Schema.Array(ProjectGroup).annotate({
    "description": "Project group memberships returned in the current page."
  }),
  "has_more": Schema.Boolean.annotate({ "description": "Whether additional project group memberships are available." }),
  "next": Schema.Union([Schema.String, Schema.Null]).annotate({
    "description": "Cursor to fetch the next page of results, or `null` when there are no more results."
  })
}).annotate({ "description": "Paginated list of groups that have access to a project." })
export type ProjectRateLimitListResponse = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<ProjectRateLimit>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const ProjectRateLimitListResponse = Schema.Struct({
  "object": Schema.Literal("list"),
  "data": Schema.Array(ProjectRateLimit),
  "first_id": Schema.String,
  "last_id": Schema.String,
  "has_more": Schema.Boolean
})
export type ProjectServiceAccountListResponse = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<ProjectServiceAccount>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const ProjectServiceAccountListResponse = Schema.Struct({
  "object": Schema.Literal("list"),
  "data": Schema.Array(ProjectServiceAccount),
  "first_id": Schema.String,
  "last_id": Schema.String,
  "has_more": Schema.Boolean
})
export type ProjectServiceAccountCreateResponse = {
  readonly "object": "organization.project.service_account"
  readonly "id": string
  readonly "name": string
  readonly "role": "member"
  readonly "created_at": number
  readonly "api_key": ProjectServiceAccountApiKey
}
export const ProjectServiceAccountCreateResponse = Schema.Struct({
  "object": Schema.Literal("organization.project.service_account"),
  "id": Schema.String,
  "name": Schema.String,
  "role": Schema.Literal("member").annotate({
    "description": "Service accounts can only have one role of type `member`"
  }),
  "created_at": Schema.Number.check(Schema.isInt()),
  "api_key": ProjectServiceAccountApiKey
})
export type ProjectApiKey = {
  readonly "object": "organization.project.api_key"
  readonly "redacted_value": string
  readonly "name": string
  readonly "created_at": number
  readonly "last_used_at": number
  readonly "id": string
  readonly "owner": {
    readonly "type"?: "user" | "service_account"
    readonly "user"?: ProjectUser
    readonly "service_account"?: ProjectServiceAccount
  }
}
export const ProjectApiKey = Schema.Struct({
  "object": Schema.Literal("organization.project.api_key").annotate({
    "description": "The object type, which is always `organization.project.api_key`"
  }),
  "redacted_value": Schema.String.annotate({ "description": "The redacted value of the API key" }),
  "name": Schema.String.annotate({ "description": "The name of the API key" }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) of when the API key was created"
  }).check(Schema.isInt()),
  "last_used_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) of when the API key was last used."
  }).check(Schema.isInt()),
  "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" }),
  "owner": Schema.Struct({
    "type": Schema.optionalKey(
      Schema.Literals(["user", "service_account"]).annotate({ "description": "`user` or `service_account`" })
    ),
    "user": Schema.optionalKey(ProjectUser),
    "service_account": Schema.optionalKey(ProjectServiceAccount)
  })
}).annotate({ "description": "Represents an individual API key in a project." })
export type ProjectUserListResponse = {
  readonly "object": string
  readonly "data": ReadonlyArray<ProjectUser>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const ProjectUserListResponse = Schema.Struct({
  "object": Schema.String,
  "data": Schema.Array(ProjectUser),
  "first_id": Schema.String,
  "last_id": Schema.String,
  "has_more": Schema.Boolean
})
export type RealtimeTranscriptionSessionCreateResponseGA = {
  readonly "type": "transcription"
  readonly "id": string
  readonly "object": string
  readonly "expires_at"?: number
  readonly "include"?: ReadonlyArray<"item.input_audio_transcription.logprobs">
  readonly "audio"?: {
    readonly "input"?: {
      readonly "format"?: RealtimeAudioFormats
      readonly "transcription"?: {
        readonly "model"?:
          | string
          | "whisper-1"
          | "gpt-4o-mini-transcribe"
          | "gpt-4o-mini-transcribe-2025-12-15"
          | "gpt-4o-transcribe"
          | "gpt-4o-transcribe-diarize"
        readonly "language"?: string
        readonly "prompt"?: string
      }
      readonly "noise_reduction"?: { readonly "type"?: NoiseReductionType }
      readonly "turn_detection"?: {
        readonly "type"?: string
        readonly "threshold"?: number
        readonly "prefix_padding_ms"?: number
        readonly "silence_duration_ms"?: number
      }
    }
  }
}
export const RealtimeTranscriptionSessionCreateResponseGA = Schema.Struct({
  "type": Schema.Literal("transcription").annotate({
    "description": "The type of session. Always `transcription` for transcription sessions.\n"
  }),
  "id": Schema.String.annotate({
    "description": "Unique identifier for the session that looks like `sess_1234567890abcdef`.\n"
  }),
  "object": Schema.String.annotate({ "description": "The object type. Always `realtime.transcription_session`." }),
  "expires_at": Schema.optionalKey(
    Schema.Number.annotate({ "description": "Expiration timestamp for the session, in seconds since epoch." }).check(
      Schema.isInt()
    )
  ),
  "include": Schema.optionalKey(
    Schema.Array(Schema.Literal("item.input_audio_transcription.logprobs")).annotate({
      "description":
        "Additional fields to include in server outputs.\n- `item.input_audio_transcription.logprobs`: Include logprobs for input audio transcription.\n"
    })
  ),
  "audio": Schema.optionalKey(
    Schema.Struct({
      "input": Schema.optionalKey(Schema.Struct({
        "format": Schema.optionalKey(RealtimeAudioFormats),
        "transcription": Schema.optionalKey(
          Schema.Struct({
            "model": Schema.optionalKey(
              Schema.Union([
                Schema.String,
                Schema.Literals([
                  "whisper-1",
                  "gpt-4o-mini-transcribe",
                  "gpt-4o-mini-transcribe-2025-12-15",
                  "gpt-4o-transcribe",
                  "gpt-4o-transcribe-diarize"
                ])
              ]).annotate({
                "description":
                  "The model to use for transcription. Current options are `whisper-1`, `gpt-4o-mini-transcribe`, `gpt-4o-mini-transcribe-2025-12-15`, `gpt-4o-transcribe`, and `gpt-4o-transcribe-diarize`. Use `gpt-4o-transcribe-diarize` when you need diarization with speaker labels.\n"
              })
            ),
            "language": Schema.optionalKey(
              Schema.String.annotate({
                "description":
                  "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"
              })
            ),
            "prompt": Schema.optionalKey(Schema.String.annotate({
              "description":
                "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models (excluding `gpt-4o-transcribe-diarize`), the prompt is a free text string, for example \"expect words related to technology\".\n"
            }))
          }).annotate({ "description": "Configuration of the transcription model.\n" })
        ),
        "noise_reduction": Schema.optionalKey(
          Schema.Struct({ "type": Schema.optionalKey(NoiseReductionType) }).annotate({
            "description": "Configuration for input audio noise reduction.\n"
          })
        ),
        "turn_detection": Schema.optionalKey(
          Schema.Struct({
            "type": Schema.optionalKey(
              Schema.String.annotate({
                "description": "Type of turn detection, only `server_vad` is currently supported.\n"
              })
            ),
            "threshold": Schema.optionalKey(
              Schema.Number.annotate({
                "description":
                  "Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\nhigher threshold will require louder audio to activate the model, and\nthus might perform better in noisy environments.\n"
              }).check(Schema.isFinite())
            ),
            "prefix_padding_ms": Schema.optionalKey(
              Schema.Number.annotate({
                "description":
                  "Amount of audio to include before the VAD detected speech (in\nmilliseconds). Defaults to 300ms.\n"
              }).check(Schema.isInt())
            ),
            "silence_duration_ms": Schema.optionalKey(
              Schema.Number.annotate({
                "description":
                  "Duration of silence to detect speech stop (in milliseconds). Defaults\nto 500ms. With shorter values the model will respond more quickly,\nbut may jump in on short pauses from the user.\n"
              }).check(Schema.isInt())
            )
          }).annotate({
            "description":
              "Configuration for turn detection. Can be set to `null` to turn off. Server\nVAD means that the model will detect the start and end of speech based on\naudio volume and respond at the end of user speech.\n"
          })
        )
      }))
    }).annotate({ "description": "Configuration for input audio for the session.\n" })
  )
}).annotate({
  "title": "Realtime transcription session configuration object",
  "description": "A Realtime transcription session configuration object.\n"
})
export type RealtimeMCPToolCall = {
  readonly "type": "mcp_call"
  readonly "id": string
  readonly "server_label": string
  readonly "name": string
  readonly "arguments": string
  readonly "approval_request_id"?: string | null
  readonly "output"?: string | null
  readonly "error"?: RealtimeMCPProtocolError | RealtimeMCPToolExecutionError | RealtimeMCPHTTPError | null
}
export const RealtimeMCPToolCall = Schema.Struct({
  "type": Schema.Literal("mcp_call").annotate({ "description": "The type of the item. Always `mcp_call`." }),
  "id": Schema.String.annotate({ "description": "The unique ID of the tool call." }),
  "server_label": Schema.String.annotate({ "description": "The label of the MCP server running the tool." }),
  "name": Schema.String.annotate({ "description": "The name of the tool that was run." }),
  "arguments": Schema.String.annotate({ "description": "A JSON string of the arguments passed to the tool." }),
  "approval_request_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "The ID of an associated approval request, if any." }),
      Schema.Null
    ])
  ),
  "output": Schema.optionalKey(
    Schema.Union([Schema.String.annotate({ "description": "The output from the tool call." }), Schema.Null])
  ),
  "error": Schema.optionalKey(
    Schema.Union([
      Schema.Union([RealtimeMCPProtocolError, RealtimeMCPToolExecutionError, RealtimeMCPHTTPError], { mode: "oneOf" })
        .annotate({ "description": "The error from the tool call, if any." }),
      Schema.Null
    ])
  )
}).annotate({
  "title": "Realtime MCP tool call",
  "description": "A Realtime item representing an invocation of a tool on an MCP server.\n"
})
export type RealtimeTranscriptionSessionCreateRequestGA = {
  readonly "type": "transcription"
  readonly "audio"?: {
    readonly "input"?: {
      readonly "format"?: RealtimeAudioFormats
      readonly "transcription"?: {
        readonly "model"?:
          | string
          | "whisper-1"
          | "gpt-4o-mini-transcribe"
          | "gpt-4o-mini-transcribe-2025-12-15"
          | "gpt-4o-transcribe"
          | "gpt-4o-transcribe-diarize"
        readonly "language"?: string
        readonly "prompt"?: string
      }
      readonly "noise_reduction"?: { readonly "type"?: NoiseReductionType }
      readonly "turn_detection"?: RealtimeTurnDetection
    }
  }
  readonly "include"?: ReadonlyArray<"item.input_audio_transcription.logprobs">
}
export const RealtimeTranscriptionSessionCreateRequestGA = Schema.Struct({
  "type": Schema.Literal("transcription").annotate({
    "description": "The type of session to create. Always `transcription` for transcription sessions.\n"
  }),
  "audio": Schema.optionalKey(
    Schema.Struct({
      "input": Schema.optionalKey(Schema.Struct({
        "format": Schema.optionalKey(RealtimeAudioFormats),
        "transcription": Schema.optionalKey(
          Schema.Struct({
            "model": Schema.optionalKey(
              Schema.Union([
                Schema.String,
                Schema.Literals([
                  "whisper-1",
                  "gpt-4o-mini-transcribe",
                  "gpt-4o-mini-transcribe-2025-12-15",
                  "gpt-4o-transcribe",
                  "gpt-4o-transcribe-diarize"
                ])
              ]).annotate({
                "description":
                  "The model to use for transcription. Current options are `whisper-1`, `gpt-4o-mini-transcribe`, `gpt-4o-mini-transcribe-2025-12-15`, `gpt-4o-transcribe`, and `gpt-4o-transcribe-diarize`. Use `gpt-4o-transcribe-diarize` when you need diarization with speaker labels.\n"
              })
            ),
            "language": Schema.optionalKey(
              Schema.String.annotate({
                "description":
                  "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"
              })
            ),
            "prompt": Schema.optionalKey(Schema.String.annotate({
              "description":
                "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models (excluding `gpt-4o-transcribe-diarize`), the prompt is a free text string, for example \"expect words related to technology\".\n"
            }))
          }).annotate({
            "description":
              "Configuration for input audio transcription, defaults to off and can be set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs asynchronously through [the /audio/transcriptions endpoint](/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"
          })
        ),
        "noise_reduction": Schema.optionalKey(
          Schema.Struct({ "type": Schema.optionalKey(NoiseReductionType) }).annotate({
            "description":
              "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"
          })
        ),
        "turn_detection": Schema.optionalKey(RealtimeTurnDetection)
      }))
    }).annotate({ "description": "Configuration for input and output audio.\n" })
  ),
  "include": Schema.optionalKey(
    Schema.Array(Schema.Literal("item.input_audio_transcription.logprobs")).annotate({
      "description":
        "Additional fields to include in server outputs.\n\n`item.input_audio_transcription.logprobs`: Include logprobs for input audio transcription.\n"
    })
  )
}).annotate({
  "title": "Realtime transcription session configuration",
  "description": "Realtime transcription session object configuration."
})
export type Reasoning = {
  readonly "effort"?: ReasoningEffort
  readonly "summary"?: "auto" | "concise" | "detailed" | null
  readonly "generate_summary"?: "auto" | "concise" | "detailed" | null
}
export const Reasoning = Schema.Struct({
  "effort": Schema.optionalKey(ReasoningEffort),
  "summary": Schema.optionalKey(Schema.Union([
    Schema.Literals(["auto", "concise", "detailed"]).annotate({
      "description":
        "A summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model's reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n\n`concise` is supported for `computer-use-preview` models and all reasoning models after `gpt-5`.\n"
    }),
    Schema.Null
  ])),
  "generate_summary": Schema.optionalKey(
    Schema.Union([
      Schema.Literals(["auto", "concise", "detailed"]).annotate({
        "description":
          "**Deprecated:** use `summary` instead.\n\nA summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model's reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n"
      }),
      Schema.Null
    ])
  )
}).annotate({
  "title": "Reasoning",
  "description":
    "**gpt-5 and o-series models only**\n\nConfiguration options for\n[reasoning models](https://platform.openai.com/docs/guides/reasoning).\n"
})
export type ResponseError = { readonly "code": ResponseErrorCode; readonly "message": string } | null
export const ResponseError = Schema.Union([
  Schema.Struct({
    "code": ResponseErrorCode,
    "message": Schema.String.annotate({ "description": "A human-readable description of the error.\n" })
  }).annotate({ "description": "An error object returned when the model fails to generate a Response.\n" }),
  Schema.Null
])
export type ResponseFormatJsonSchema = {
  readonly "type": "json_schema"
  readonly "json_schema": {
    readonly "description"?: string
    readonly "name": string
    readonly "schema"?: ResponseFormatJsonSchemaSchema
    readonly "strict"?: boolean | null
  }
}
export const ResponseFormatJsonSchema = Schema.Struct({
  "type": Schema.Literal("json_schema").annotate({
    "description": "The type of response format being defined. Always `json_schema`."
  }),
  "json_schema": Schema.Struct({
    "description": Schema.optionalKey(
      Schema.String.annotate({
        "description":
          "A description of what the response format is for, used by the model to\ndetermine how to respond in the format.\n"
      })
    ),
    "name": Schema.String.annotate({
      "description":
        "The name of the response format. Must be a-z, A-Z, 0-9, or contain\nunderscores and dashes, with a maximum length of 64.\n"
    }),
    "schema": Schema.optionalKey(ResponseFormatJsonSchemaSchema),
    "strict": Schema.optionalKey(Schema.Union([
      Schema.Boolean.annotate({
        "description":
          "Whether to enable strict schema adherence when generating the output.\nIf set to true, the model will always follow the exact schema defined\nin the `schema` field. Only a subset of JSON Schema is supported when\n`strict` is `true`. To learn more, read the [Structured Outputs\nguide](/docs/guides/structured-outputs).\n"
      }),
      Schema.Null
    ]))
  }).annotate({
    "title": "JSON schema",
    "description": "Structured Outputs configuration options, including a JSON Schema.\n"
  })
}).annotate({
  "title": "JSON schema",
  "description":
    "JSON Schema response format. Used to generate structured JSON responses.\nLearn more about [Structured Outputs](/docs/guides/structured-outputs).\n"
})
export type TextResponseFormatJsonSchema = {
  readonly "type": "json_schema"
  readonly "description"?: string
  readonly "name": string
  readonly "schema": ResponseFormatJsonSchemaSchema
  readonly "strict"?: boolean | null
}
export const TextResponseFormatJsonSchema = Schema.Struct({
  "type": Schema.Literal("json_schema").annotate({
    "description": "The type of response format being defined. Always `json_schema`."
  }),
  "description": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "A description of what the response format is for, used by the model to\ndetermine how to respond in the format.\n"
    })
  ),
  "name": Schema.String.annotate({
    "description":
      "The name of the response format. Must be a-z, A-Z, 0-9, or contain\nunderscores and dashes, with a maximum length of 64.\n"
  }),
  "schema": ResponseFormatJsonSchemaSchema,
  "strict": Schema.optionalKey(Schema.Union([
    Schema.Boolean.annotate({
      "description":
        "Whether to enable strict schema adherence when generating the output.\nIf set to true, the model will always follow the exact schema defined\nin the `schema` field. Only a subset of JSON Schema is supported when\n`strict` is `true`. To learn more, read the [Structured Outputs\nguide](/docs/guides/structured-outputs).\n"
    }),
    Schema.Null
  ]))
}).annotate({
  "title": "JSON schema",
  "description":
    "JSON Schema response format. Used to generate structured JSON responses.\nLearn more about [Structured Outputs](/docs/guides/structured-outputs).\n"
})
export type ResponseTextDeltaEvent = {
  readonly "type": "response.output_text.delta"
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
  readonly "delta": string
  readonly "sequence_number": number
  readonly "logprobs": ReadonlyArray<ResponseLogProb>
}
export const ResponseTextDeltaEvent = Schema.Struct({
  "type": Schema.Literal("response.output_text.delta").annotate({
    "description": "The type of the event. Always `response.output_text.delta`.\n"
  }),
  "item_id": Schema.String.annotate({ "description": "The ID of the output item that the text delta was added to.\n" }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item that the text delta was added to.\n"
  }).check(Schema.isInt()),
  "content_index": Schema.Number.annotate({
    "description": "The index of the content part that the text delta was added to.\n"
  }).check(Schema.isInt()),
  "delta": Schema.String.annotate({ "description": "The text delta that was added.\n" }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number for this event." }).check(
    Schema.isInt()
  ),
  "logprobs": Schema.Array(ResponseLogProb).annotate({
    "description": "The log probabilities of the tokens in the delta.\n"
  })
}).annotate({ "description": "Emitted when there is an additional text delta." })
export type ResponseTextDoneEvent = {
  readonly "type": "response.output_text.done"
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
  readonly "text": string
  readonly "sequence_number": number
  readonly "logprobs": ReadonlyArray<ResponseLogProb>
}
export const ResponseTextDoneEvent = Schema.Struct({
  "type": Schema.Literal("response.output_text.done").annotate({
    "description": "The type of the event. Always `response.output_text.done`.\n"
  }),
  "item_id": Schema.String.annotate({
    "description": "The ID of the output item that the text content is finalized.\n"
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item that the text content is finalized.\n"
  }).check(Schema.isInt()),
  "content_index": Schema.Number.annotate({
    "description": "The index of the content part that the text content is finalized.\n"
  }).check(Schema.isInt()),
  "text": Schema.String.annotate({ "description": "The text content that is finalized.\n" }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number for this event." }).check(
    Schema.isInt()
  ),
  "logprobs": Schema.Array(ResponseLogProb).annotate({
    "description": "The log probabilities of the tokens in the delta.\n"
  })
}).annotate({ "description": "Emitted when text content is finalized." })
export type Prompt = {
  readonly "id": string
  readonly "version"?: string | null
  readonly "variables"?: ResponsePromptVariables
} | null
export const Prompt = Schema.Union([
  Schema.Struct({
    "id": Schema.String.annotate({ "description": "The unique identifier of the prompt template to use." }),
    "version": Schema.optionalKey(
      Schema.Union([Schema.String.annotate({ "description": "Optional version of the prompt template." }), Schema.Null])
    ),
    "variables": Schema.optionalKey(ResponsePromptVariables)
  }).annotate({
    "description":
      "Reference to a prompt template and its variables.\n[Learn more](/docs/guides/text?api-mode=responses#reusable-prompts).\n"
  }),
  Schema.Null
])
export type GroupRoleAssignment = { readonly "object": "group.role"; readonly "group": Group; readonly "role": Role }
export const GroupRoleAssignment = Schema.Struct({
  "object": Schema.Literal("group.role").annotate({ "description": "Always `group.role`." }),
  "group": Group,
  "role": Role
}).annotate({ "description": "Role assignment linking a group to a role." })
export type PublicRoleListResource = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<Role>
  readonly "has_more": boolean
  readonly "next": string | null
}
export const PublicRoleListResource = Schema.Struct({
  "object": Schema.Literal("list").annotate({ "description": "Always `list`." }),
  "data": Schema.Array(Role).annotate({ "description": "Roles returned in the current page." }),
  "has_more": Schema.Boolean.annotate({ "description": "Whether more roles are available when paginating." }),
  "next": Schema.Union([Schema.String, Schema.Null]).annotate({
    "description": "Cursor to fetch the next page of results, or `null` when there are no additional roles."
  })
}).annotate({ "description": "Paginated list of roles available on an organization or project." })
export type RunStepDeltaStepDetailsToolCallsCodeObject = {
  readonly "index": number
  readonly "id"?: string
  readonly "type": "code_interpreter"
  readonly "code_interpreter"?: {
    readonly "input"?: string
    readonly "outputs"?: ReadonlyArray<
      RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject | RunStepDeltaStepDetailsToolCallsCodeOutputImageObject
    >
  }
}
export const RunStepDeltaStepDetailsToolCallsCodeObject = Schema.Struct({
  "index": Schema.Number.annotate({ "description": "The index of the tool call in the tool calls array." }).check(
    Schema.isInt()
  ),
  "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the tool call." })),
  "type": Schema.Literal("code_interpreter").annotate({
    "description": "The type of tool call. This is always going to be `code_interpreter` for this type of tool call."
  }),
  "code_interpreter": Schema.optionalKey(
    Schema.Struct({
      "input": Schema.optionalKey(
        Schema.String.annotate({ "description": "The input to the Code Interpreter tool call." })
      ),
      "outputs": Schema.optionalKey(
        Schema.Array(
          Schema.Union([
            RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject,
            RunStepDeltaStepDetailsToolCallsCodeOutputImageObject
          ], { mode: "oneOf" })
        ).annotate({
          "description":
            "The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type."
        })
      )
    }).annotate({ "description": "The Code Interpreter tool call definition." })
  )
}).annotate({
  "title": "Code interpreter tool call",
  "description": "Details of the Code Interpreter tool call the run step was involved in."
})
export type RunStepDetailsToolCallsCodeObject = {
  readonly "id": string
  readonly "type": "code_interpreter"
  readonly "code_interpreter": {
    readonly "input": string
    readonly "outputs": ReadonlyArray<
      RunStepDetailsToolCallsCodeOutputLogsObject | RunStepDetailsToolCallsCodeOutputImageObject
    >
  }
}
export const RunStepDetailsToolCallsCodeObject = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The ID of the tool call." }),
  "type": Schema.Literal("code_interpreter").annotate({
    "description": "The type of tool call. This is always going to be `code_interpreter` for this type of tool call."
  }),
  "code_interpreter": Schema.Struct({
    "input": Schema.String.annotate({ "description": "The input to the Code Interpreter tool call." }),
    "outputs": Schema.Array(
      Schema.Union([RunStepDetailsToolCallsCodeOutputLogsObject, RunStepDetailsToolCallsCodeOutputImageObject], {
        mode: "oneOf"
      })
    ).annotate({
      "description":
        "The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type."
    })
  }).annotate({ "description": "The Code Interpreter tool call definition." })
}).annotate({
  "title": "Code Interpreter tool call",
  "description": "Details of the Code Interpreter tool call the run step was involved in."
})
export type CreateSpeechResponseStreamEvent = SpeechAudioDeltaEvent | SpeechAudioDoneEvent
export const CreateSpeechResponseStreamEvent = Schema.Union([SpeechAudioDeltaEvent, SpeechAudioDoneEvent])
export type StaticChunkingStrategyRequestParam = {
  readonly "type": "static"
  readonly "static": StaticChunkingStrategy
}
export const StaticChunkingStrategyRequestParam = Schema.Struct({
  "type": Schema.Literal("static").annotate({ "description": "Always `static`." }),
  "static": StaticChunkingStrategy
}).annotate({
  "title": "Static Chunking Strategy",
  "description": "Customize your own chunking strategy by setting chunk size and chunk overlap."
})
export type StaticChunkingStrategyResponseParam = {
  readonly "type": "static"
  readonly "static": StaticChunkingStrategy
}
export const StaticChunkingStrategyResponseParam = Schema.Struct({
  "type": Schema.Literal("static").annotate({ "description": "Always `static`." }),
  "static": StaticChunkingStrategy
}).annotate({ "title": "Static Chunking Strategy" })
export type CreateCompletionRequest = {
  readonly "model": string | "gpt-3.5-turbo-instruct" | "davinci-002" | "babbage-002"
  readonly "prompt":
    | string
    | ReadonlyArray<string>
    | ReadonlyArray<number>
    | ReadonlyArray<ReadonlyArray<number>>
    | null
  readonly "best_of"?: number | null
  readonly "echo"?: boolean | null
  readonly "frequency_penalty"?: number | null
  readonly "logit_bias"?: {} | null
  readonly "logprobs"?: number | null
  readonly "max_tokens"?: number | null
  readonly "n"?: number | null
  readonly "presence_penalty"?: number | null
  readonly "seed"?: number | null
  readonly "stop"?: StopConfiguration
  readonly "stream"?: boolean | null
  readonly "stream_options"?: ChatCompletionStreamOptions
  readonly "suffix"?: string | null
  readonly "temperature"?: number | null
  readonly "top_p"?: number | null
  readonly "user"?: string
}
export const CreateCompletionRequest = Schema.Struct({
  "model": Schema.Union([Schema.String, Schema.Literals(["gpt-3.5-turbo-instruct", "davinci-002", "babbage-002"])])
    .annotate({
      "description":
        "ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.\n"
    }),
  "prompt": Schema.Union([
    Schema.Union([
      Schema.String,
      Schema.Array(Schema.String),
      Schema.Array(Schema.Number.check(Schema.isInt())).check(Schema.isMinLength(1)),
      Schema.Array(Schema.Array(Schema.Number.check(Schema.isInt())).check(Schema.isMinLength(1))).check(
        Schema.isMinLength(1)
      )
    ], { mode: "oneOf" }).annotate({
      "description":
        "The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.\n\nNote that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.\n"
    }),
    Schema.Null
  ]),
  "best_of": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "Generates `best_of` completions server-side and returns the \"best\" (the one with the highest log probability per token). Results cannot be streamed.\n\nWhen used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return  `best_of` must be greater than `n`.\n\n**Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.\n"
    })
  ),
  "echo": Schema.optionalKey(
    Schema.Union([Schema.Boolean, Schema.Null]).annotate({
      "description": "Echo back the prompt in addition to the completion\n"
    })
  ),
  "frequency_penalty": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({
      "description":
        "Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.\n\n[See more information about frequency and presence penalties.](/docs/guides/text-generation)\n"
    })
  ),
  "logit_bias": Schema.optionalKey(
    Schema.Union([Schema.Struct({}), Schema.Null]).annotate({
      "description":
        "Modify the likelihood of specified tokens appearing in the completion.\n\nAccepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.\n\nAs an example, you can pass `{\"50256\": -100}` to prevent the <|endoftext|> token from being generated.\n"
    })
  ),
  "logprobs": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.\n\nThe maximum value for `logprobs` is 5.\n"
    })
  ),
  "max_tokens": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "The maximum number of [tokens](/tokenizer) that can be generated in the completion.\n\nThe token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.\n"
    })
  ),
  "n": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "How many completions to generate for each prompt.\n\n**Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.\n"
    })
  ),
  "presence_penalty": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({
      "description":
        "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.\n\n[See more information about frequency and presence penalties.](/docs/guides/text-generation)\n"
    })
  ),
  "seed": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.\n\nDeterminism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.\n",
      "format": "int64"
    })
  ),
  "stop": Schema.optionalKey(StopConfiguration),
  "stream": Schema.optionalKey(
    Schema.Union([Schema.Boolean, Schema.Null]).annotate({
      "description":
        "Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).\n"
    })
  ),
  "stream_options": Schema.optionalKey(ChatCompletionStreamOptions),
  "suffix": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "The suffix that comes after a completion of inserted text.\n\nThis parameter is only supported for `gpt-3.5-turbo-instruct`.\n"
    })
  ),
  "temperature": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({
      "description":
        "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n\nWe generally recommend altering this or `top_p` but not both.\n"
    })
  ),
  "top_p": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({
      "description":
        "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"
    })
  ),
  "user": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).\n"
    })
  )
})
export type TranscriptTextDoneEvent = {
  readonly "type": "transcript.text.done"
  readonly "text": string
  readonly "logprobs"?: ReadonlyArray<
    { readonly "token"?: string; readonly "logprob"?: number; readonly "bytes"?: ReadonlyArray<number> }
  >
  readonly "usage"?: TranscriptTextUsageTokens
}
export const TranscriptTextDoneEvent = Schema.Struct({
  "type": Schema.Literal("transcript.text.done").annotate({
    "description": "The type of the event. Always `transcript.text.done`.\n"
  }),
  "text": Schema.String.annotate({ "description": "The text that was transcribed.\n" }),
  "logprobs": Schema.optionalKey(
    Schema.Array(Schema.Struct({
      "token": Schema.optionalKey(
        Schema.String.annotate({ "description": "The token that was used to generate the log probability.\n" })
      ),
      "logprob": Schema.optionalKey(
        Schema.Number.annotate({ "description": "The log probability of the token.\n" }).check(Schema.isFinite())
      ),
      "bytes": Schema.optionalKey(
        Schema.Array(Schema.Number.check(Schema.isInt())).annotate({
          "description": "The bytes that were used to generate the log probability.\n"
        })
      )
    })).annotate({
      "description":
        "The log probabilities of the individual tokens in the transcription. Only included if you [create a transcription](/docs/api-reference/audio/create-transcription) with the `include[]` parameter set to `logprobs`.\n"
    })
  ),
  "usage": Schema.optionalKey(TranscriptTextUsageTokens)
}).annotate({
  "description":
    "Emitted when the transcription is complete. Contains the complete transcription text. Only emitted when you [create a transcription](/docs/api-reference/audio/create-transcription) with the `Stream` parameter set to `true`."
})
export type CreateTranscriptionResponseDiarizedJson = {
  readonly "task": "transcribe"
  readonly "duration": number
  readonly "text": string
  readonly "segments": ReadonlyArray<TranscriptionDiarizedSegment>
  readonly "usage"?: {
    readonly "type": "tokens"
    readonly "input_tokens": number
    readonly "input_token_details"?: { readonly "text_tokens"?: number; readonly "audio_tokens"?: number }
    readonly "output_tokens": number
    readonly "total_tokens": number
  } | { readonly "type": "duration"; readonly "seconds": number }
}
export const CreateTranscriptionResponseDiarizedJson = Schema.Struct({
  "task": Schema.Literal("transcribe").annotate({
    "description": "The type of task that was run. Always `transcribe`."
  }),
  "duration": Schema.Number.annotate({ "description": "Duration of the input audio in seconds." }).check(
    Schema.isFinite()
  ),
  "text": Schema.String.annotate({ "description": "The concatenated transcript text for the entire audio input." }),
  "segments": Schema.Array(TranscriptionDiarizedSegment).annotate({
    "description": "Segments of the transcript annotated with timestamps and speaker labels."
  }),
  "usage": Schema.optionalKey(
    Schema.Union([
      Schema.Struct({
        "type": Schema.Literal("tokens").annotate({
          "description": "The type of the usage object. Always `tokens` for this variant."
        }),
        "input_tokens": Schema.Number.annotate({ "description": "Number of input tokens billed for this request." })
          .check(Schema.isInt()),
        "input_token_details": Schema.optionalKey(
          Schema.Struct({
            "text_tokens": Schema.optionalKey(
              Schema.Number.annotate({ "description": "Number of text tokens billed for this request." }).check(
                Schema.isInt()
              )
            ),
            "audio_tokens": Schema.optionalKey(
              Schema.Number.annotate({ "description": "Number of audio tokens billed for this request." }).check(
                Schema.isInt()
              )
            )
          }).annotate({ "description": "Details about the input tokens billed for this request." })
        ),
        "output_tokens": Schema.Number.annotate({ "description": "Number of output tokens generated." }).check(
          Schema.isInt()
        ),
        "total_tokens": Schema.Number.annotate({ "description": "Total number of tokens used (input + output)." })
          .check(Schema.isInt())
      }).annotate({ "title": "Token Usage", "description": "Usage statistics for models billed by token usage." }),
      Schema.Struct({
        "type": Schema.Literal("duration").annotate({
          "description": "The type of the usage object. Always `duration` for this variant."
        }),
        "seconds": Schema.Number.annotate({ "description": "Duration of the input audio in seconds." }).check(
          Schema.isFinite()
        )
      }).annotate({
        "title": "Duration Usage",
        "description": "Usage statistics for models billed by audio input duration."
      })
    ], { mode: "oneOf" }).annotate({ "description": "Token or duration usage statistics for the request." })
  )
}).annotate({
  "description":
    "Represents a diarized transcription response returned by the model, including the combined transcript and speaker-segment annotations.\n"
})
export type CreateTranslationResponseVerboseJson = {
  readonly "language": string
  readonly "duration": number
  readonly "text": string
  readonly "segments"?: ReadonlyArray<TranscriptionSegment>
}
export const CreateTranslationResponseVerboseJson = Schema.Struct({
  "language": Schema.String.annotate({ "description": "The language of the output translation (always `english`)." }),
  "duration": Schema.Number.annotate({ "description": "The duration of the input audio." }).check(Schema.isFinite()),
  "text": Schema.String.annotate({ "description": "The translated text." }),
  "segments": Schema.optionalKey(
    Schema.Array(TranscriptionSegment).annotate({
      "description": "Segments of the translated text and their corresponding details."
    })
  )
})
export type CreateTranscriptionResponseVerboseJson = {
  readonly "language": string
  readonly "duration": number
  readonly "text": string
  readonly "words"?: ReadonlyArray<TranscriptionWord>
  readonly "segments"?: ReadonlyArray<TranscriptionSegment>
  readonly "usage"?: TranscriptTextUsageDuration
}
export const CreateTranscriptionResponseVerboseJson = Schema.Struct({
  "language": Schema.String.annotate({ "description": "The language of the input audio." }),
  "duration": Schema.Number.annotate({ "description": "The duration of the input audio." }).check(Schema.isFinite()),
  "text": Schema.String.annotate({ "description": "The transcribed text." }),
  "words": Schema.optionalKey(
    Schema.Array(TranscriptionWord).annotate({ "description": "Extracted words and their corresponding timestamps." })
  ),
  "segments": Schema.optionalKey(
    Schema.Array(TranscriptionSegment).annotate({
      "description": "Segments of the transcribed text and their corresponding details."
    })
  ),
  "usage": Schema.optionalKey(TranscriptTextUsageDuration)
}).annotate({
  "description": "Represents a verbose json transcription response returned by model, based on the provided input."
})
export type UsageTimeBucket = {
  readonly "object": "bucket"
  readonly "start_time": number
  readonly "end_time": number
  readonly "result": ReadonlyArray<
    | UsageCompletionsResult
    | UsageEmbeddingsResult
    | UsageModerationsResult
    | UsageImagesResult
    | UsageAudioSpeechesResult
    | UsageAudioTranscriptionsResult
    | UsageVectorStoresResult
    | UsageCodeInterpreterSessionsResult
    | CostsResult
  >
}
export const UsageTimeBucket = Schema.Struct({
  "object": Schema.Literal("bucket"),
  "start_time": Schema.Number.check(Schema.isInt()),
  "end_time": Schema.Number.check(Schema.isInt()),
  "result": Schema.Array(
    Schema.Union([
      UsageCompletionsResult,
      UsageEmbeddingsResult,
      UsageModerationsResult,
      UsageImagesResult,
      UsageAudioSpeechesResult,
      UsageAudioTranscriptionsResult,
      UsageVectorStoresResult,
      UsageCodeInterpreterSessionsResult,
      CostsResult
    ], { mode: "oneOf" })
  )
})
export type UserListResource = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<User>
  readonly "has_more": boolean
  readonly "next": string | null
}
export const UserListResource = Schema.Struct({
  "object": Schema.Literal("list").annotate({ "description": "Always `list`." }),
  "data": Schema.Array(User).annotate({ "description": "Users in the current page." }),
  "has_more": Schema.Boolean.annotate({ "description": "Whether more users are available when paginating." }),
  "next": Schema.Union([Schema.String, Schema.Null]).annotate({
    "description": "Cursor to fetch the next page of results, or `null` when no further users are available."
  })
}).annotate({ "description": "Paginated list of user objects returned when inspecting group membership." })
export type UserListResponse = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<User>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const UserListResponse = Schema.Struct({
  "object": Schema.Literal("list"),
  "data": Schema.Array(User),
  "first_id": Schema.String,
  "last_id": Schema.String,
  "has_more": Schema.Boolean
})
export type UserRoleAssignment = { readonly "object": "user.role"; readonly "user": User; readonly "role": Role }
export const UserRoleAssignment = Schema.Struct({
  "object": Schema.Literal("user.role").annotate({ "description": "Always `user.role`." }),
  "user": User,
  "role": Role
}).annotate({ "description": "Role assignment linking a user to a role." })
export type CreateTranscriptionRequest = {
  readonly "file": string
  readonly "model":
    | string
    | "whisper-1"
    | "gpt-4o-transcribe"
    | "gpt-4o-mini-transcribe"
    | "gpt-4o-mini-transcribe-2025-12-15"
    | "gpt-4o-transcribe-diarize"
  readonly "language"?: string
  readonly "prompt"?: string
  readonly "response_format"?: AudioResponseFormat
  readonly "temperature"?: number
  readonly "include"?: ReadonlyArray<TranscriptionInclude>
  readonly "timestamp_granularities"?: ReadonlyArray<"word" | "segment">
  readonly "stream"?: boolean | null
  readonly "chunking_strategy"?: "auto" | VadConfig | null
  readonly "known_speaker_names"?: ReadonlyArray<string>
  readonly "known_speaker_references"?: ReadonlyArray<string>
}
export const CreateTranscriptionRequest = Schema.Struct({
  "file": Schema.String.annotate({
    "description":
      "The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.\n",
    "format": "binary"
  }),
  "model": Schema.Union([
    Schema.String,
    Schema.Literals([
      "whisper-1",
      "gpt-4o-transcribe",
      "gpt-4o-mini-transcribe",
      "gpt-4o-mini-transcribe-2025-12-15",
      "gpt-4o-transcribe-diarize"
    ])
  ]).annotate({
    "description":
      "ID of the model to use. The options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, `gpt-4o-mini-transcribe-2025-12-15`, `whisper-1` (which is powered by our open source Whisper V2 model), and `gpt-4o-transcribe-diarize`.\n"
  }),
  "language": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format will improve accuracy and latency.\n"
    })
  ),
  "prompt": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "An optional text to guide the model's style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should match the audio language. This field is not supported when using `gpt-4o-transcribe-diarize`.\n"
    })
  ),
  "response_format": Schema.optionalKey(AudioResponseFormat),
  "temperature": Schema.optionalKey(
    Schema.Number.annotate({
      "description":
        "The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.\n"
    }).check(Schema.isFinite())
  ),
  "include": Schema.optionalKey(
    Schema.Array(TranscriptionInclude).annotate({
      "description":
        "Additional information to include in the transcription response.\n`logprobs` will return the log probabilities of the tokens in the\nresponse to understand the model's confidence in the transcription.\n`logprobs` only works with response_format set to `json` and only with\nthe models `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `gpt-4o-mini-transcribe-2025-12-15`. This field is not supported when using `gpt-4o-transcribe-diarize`.\n"
    })
  ),
  "timestamp_granularities": Schema.optionalKey(
    Schema.Array(Schema.Literals(["word", "segment"])).annotate({
      "description":
        "The timestamp granularities to populate for this transcription. `response_format` must be set `verbose_json` to use timestamp granularities. Either or both of these options are supported: `word`, or `segment`. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency.\nThis option is not available for `gpt-4o-transcribe-diarize`.\n"
    })
  ),
  "stream": Schema.optionalKey(Schema.Union([
    Schema.Boolean.annotate({
      "description":
        "If set to true, the model response data will be streamed to the client\nas it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).\nSee the [Streaming section of the Speech-to-Text guide](/docs/guides/speech-to-text?lang=curl#streaming-transcriptions)\nfor more information.\n\nNote: Streaming is not supported for the `whisper-1` model and will be ignored.\n"
    }),
    Schema.Null
  ])),
  "chunking_strategy": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        Schema.Literal("auto").annotate({
          "description": "Automatically set chunking parameters based on the audio. Must be set to `\"auto\"`.\n"
        }),
        VadConfig
      ]).annotate({
        "description":
          "Controls how the audio is cut into chunks. When set to `\"auto\"`, the server first normalizes loudness and then uses voice activity detection (VAD) to choose boundaries. `server_vad` object can be provided to tweak VAD detection parameters manually. If unset, the audio is transcribed as a single block. Required when using `gpt-4o-transcribe-diarize` for inputs longer than 30 seconds. "
      }),
      Schema.Null
    ])
  ),
  "known_speaker_names": Schema.optionalKey(
    Schema.Array(Schema.String).annotate({
      "description":
        "Optional list of speaker names that correspond to the audio samples provided in `known_speaker_references[]`. Each entry should be a short identifier (for example `customer` or `agent`). Up to 4 speakers are supported.\n"
    }).check(Schema.isMaxLength(4))
  ),
  "known_speaker_references": Schema.optionalKey(
    Schema.Array(Schema.String).annotate({
      "description":
        "Optional list of audio samples (as [data URLs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs)) that contain known speaker references matching `known_speaker_names[]`. Each sample must be between 2 and 10 seconds, and can use any of the same input audio formats supported by `file`.\n"
    }).check(Schema.isMaxLength(4))
  )
})
export type VectorStoreObject = {
  readonly "id": string
  readonly "object": "vector_store"
  readonly "created_at": number
  readonly "name": string
  readonly "usage_bytes": number
  readonly "file_counts": {
    readonly "in_progress": number
    readonly "completed": number
    readonly "failed": number
    readonly "cancelled": number
    readonly "total": number
  }
  readonly "status": "expired" | "in_progress" | "completed"
  readonly "expires_after"?: VectorStoreExpirationAfter
  readonly "expires_at"?: number | null
  readonly "last_active_at": number | null
  readonly "metadata": Metadata
}
export const VectorStoreObject = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints." }),
  "object": Schema.Literal("vector_store").annotate({
    "description": "The object type, which is always `vector_store`."
  }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the vector store was created."
  }).check(Schema.isInt()),
  "name": Schema.String.annotate({ "description": "The name of the vector store." }),
  "usage_bytes": Schema.Number.annotate({
    "description": "The total number of bytes used by the files in the vector store."
  }).check(Schema.isInt()),
  "file_counts": Schema.Struct({
    "in_progress": Schema.Number.annotate({ "description": "The number of files that are currently being processed." })
      .check(Schema.isInt()),
    "completed": Schema.Number.annotate({ "description": "The number of files that have been successfully processed." })
      .check(Schema.isInt()),
    "failed": Schema.Number.annotate({ "description": "The number of files that have failed to process." }).check(
      Schema.isInt()
    ),
    "cancelled": Schema.Number.annotate({ "description": "The number of files that were cancelled." }).check(
      Schema.isInt()
    ),
    "total": Schema.Number.annotate({ "description": "The total number of files." }).check(Schema.isInt())
  }),
  "status": Schema.Literals(["expired", "in_progress", "completed"]).annotate({
    "description":
      "The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use."
  }),
  "expires_after": Schema.optionalKey(VectorStoreExpirationAfter),
  "expires_at": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description": "The Unix timestamp (in seconds) for when the vector store will expire."
      }).check(Schema.isInt()),
      Schema.Null
    ])
  ),
  "last_active_at": Schema.Union([
    Schema.Number.annotate({
      "description": "The Unix timestamp (in seconds) for when the vector store was last active."
    }).check(Schema.isInt()),
    Schema.Null
  ]),
  "metadata": Metadata
}).annotate({
  "title": "Vector store",
  "description": "A vector store is a collection of processed files can be used by the `file_search` tool."
})
export type FileSearchToolCall = {
  readonly "id": string
  readonly "type": "file_search_call"
  readonly "status": "in_progress" | "searching" | "completed" | "incomplete" | "failed"
  readonly "queries": ReadonlyArray<string>
  readonly "results"?:
    | ReadonlyArray<
      {
        readonly "file_id"?: string
        readonly "text"?: string
        readonly "filename"?: string
        readonly "attributes"?: VectorStoreFileAttributes
        readonly "score"?: number
      }
    >
    | null
}
export const FileSearchToolCall = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The unique ID of the file search tool call.\n" }),
  "type": Schema.Literal("file_search_call").annotate({
    "description": "The type of the file search tool call. Always `file_search_call`.\n"
  }),
  "status": Schema.Literals(["in_progress", "searching", "completed", "incomplete", "failed"]).annotate({
    "description":
      "The status of the file search tool call. One of `in_progress`,\n`searching`, `incomplete` or `failed`,\n"
  }),
  "queries": Schema.Array(Schema.String).annotate({ "description": "The queries used to search for files.\n" }),
  "results": Schema.optionalKey(Schema.Union([
    Schema.Array(Schema.Struct({
      "file_id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the file.\n" })),
      "text": Schema.optionalKey(
        Schema.String.annotate({ "description": "The text that was retrieved from the file.\n" })
      ),
      "filename": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the file.\n" })),
      "attributes": Schema.optionalKey(VectorStoreFileAttributes),
      "score": Schema.optionalKey(
        Schema.Number.annotate({
          "description": "The relevance score of the file - a value between 0 and 1.\n",
          "format": "float"
        }).check(Schema.isFinite())
      )
    })).annotate({ "description": "The results of the file search tool call.\n" }),
    Schema.Null
  ]))
}).annotate({
  "title": "File search tool call",
  "description":
    "The results of a file search tool call. See the\n[file search guide](/docs/guides/tools-file-search) for more information.\n"
})
export type UpdateVectorStoreFileAttributesRequest = { readonly "attributes": VectorStoreFileAttributes }
export const UpdateVectorStoreFileAttributesRequest = Schema.Struct({ "attributes": VectorStoreFileAttributes })
export type VectorStoreSearchResultItem = {
  readonly "file_id": string
  readonly "filename": string
  readonly "score": number
  readonly "attributes": VectorStoreFileAttributes
  readonly "content": ReadonlyArray<VectorStoreSearchResultContentObject>
}
export const VectorStoreSearchResultItem = Schema.Struct({
  "file_id": Schema.String.annotate({ "description": "The ID of the vector store file." }),
  "filename": Schema.String.annotate({ "description": "The name of the vector store file." }),
  "score": Schema.Number.annotate({ "description": "The similarity score for the result." }).check(Schema.isFinite())
    .check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1)),
  "attributes": VectorStoreFileAttributes,
  "content": Schema.Array(VectorStoreSearchResultContentObject).annotate({
    "description": "Content chunks from the file."
  })
})
export type VoiceConsentListResource = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<VoiceConsentResource>
  readonly "first_id"?: string | null
  readonly "last_id"?: string | null
  readonly "has_more": boolean
}
export const VoiceConsentListResource = Schema.Struct({
  "object": Schema.Literal("list"),
  "data": Schema.Array(VoiceConsentResource),
  "first_id": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null])),
  "last_id": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null])),
  "has_more": Schema.Boolean
})
export type RealtimeSessionCreateResponse = {
  readonly "id"?: string
  readonly "object"?: string
  readonly "expires_at"?: number
  readonly "include"?: ReadonlyArray<"item.input_audio_transcription.logprobs">
  readonly "model"?: string
  readonly "output_modalities"?: ReadonlyArray<"text" | "audio">
  readonly "instructions"?: string
  readonly "audio"?: {
    readonly "input"?: {
      readonly "format"?: RealtimeAudioFormats
      readonly "transcription"?: {
        readonly "model"?:
          | string
          | "whisper-1"
          | "gpt-4o-mini-transcribe"
          | "gpt-4o-mini-transcribe-2025-12-15"
          | "gpt-4o-transcribe"
          | "gpt-4o-transcribe-diarize"
        readonly "language"?: string
        readonly "prompt"?: string
      }
      readonly "noise_reduction"?: { readonly "type"?: NoiseReductionType }
      readonly "turn_detection"?: {
        readonly "type"?: string
        readonly "threshold"?: number
        readonly "prefix_padding_ms"?: number
        readonly "silence_duration_ms"?: number
      }
    }
    readonly "output"?: {
      readonly "format"?: RealtimeAudioFormats
      readonly "voice"?: VoiceIdsShared
      readonly "speed"?: number
    }
  }
  readonly "tracing"?: "auto" | {
    readonly "workflow_name"?: string
    readonly "group_id"?: string
    readonly "metadata"?: {}
  }
  readonly "turn_detection"?: {
    readonly "type"?: string
    readonly "threshold"?: number
    readonly "prefix_padding_ms"?: number
    readonly "silence_duration_ms"?: number
  }
  readonly "tools"?: ReadonlyArray<RealtimeFunctionTool>
  readonly "tool_choice"?: string
  readonly "max_output_tokens"?: number | "inf"
}
export const RealtimeSessionCreateResponse = Schema.Struct({
  "id": Schema.optionalKey(
    Schema.String.annotate({
      "description": "Unique identifier for the session that looks like `sess_1234567890abcdef`.\n"
    })
  ),
  "object": Schema.optionalKey(
    Schema.String.annotate({ "description": "The object type. Always `realtime.session`." })
  ),
  "expires_at": Schema.optionalKey(
    Schema.Number.annotate({ "description": "Expiration timestamp for the session, in seconds since epoch." }).check(
      Schema.isInt()
    )
  ),
  "include": Schema.optionalKey(
    Schema.Array(Schema.Literal("item.input_audio_transcription.logprobs")).annotate({
      "description":
        "Additional fields to include in server outputs.\n- `item.input_audio_transcription.logprobs`: Include logprobs for input audio transcription.\n"
    })
  ),
  "model": Schema.optionalKey(Schema.String.annotate({ "description": "The Realtime model used for this session." })),
  "output_modalities": Schema.optionalKey(
    Schema.Array(Schema.Literals(["text", "audio"])).annotate({
      "description": "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"
    })
  ),
  "instructions": Schema.optionalKey(Schema.String.annotate({
    "description":
      "The default system instructions (i.e. system message) prepended to model\ncalls. This field allows the client to guide the model on desired\nresponses. The model can be instructed on response content and format,\n(e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good\nresponses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion\ninto your voice\", \"laugh frequently\"). The instructions are not guaranteed\nto be followed by the model, but they provide guidance to the model on the\ndesired behavior.\n\nNote that the server sets default instructions which will be used if this\nfield is not set and are visible in the `session.created` event at the\nstart of the session.\n"
  })),
  "audio": Schema.optionalKey(
    Schema.Struct({
      "input": Schema.optionalKey(Schema.Struct({
        "format": Schema.optionalKey(RealtimeAudioFormats),
        "transcription": Schema.optionalKey(
          Schema.Struct({
            "model": Schema.optionalKey(
              Schema.Union([
                Schema.String,
                Schema.Literals([
                  "whisper-1",
                  "gpt-4o-mini-transcribe",
                  "gpt-4o-mini-transcribe-2025-12-15",
                  "gpt-4o-transcribe",
                  "gpt-4o-transcribe-diarize"
                ])
              ]).annotate({
                "description":
                  "The model to use for transcription. Current options are `whisper-1`, `gpt-4o-mini-transcribe`, `gpt-4o-mini-transcribe-2025-12-15`, `gpt-4o-transcribe`, and `gpt-4o-transcribe-diarize`. Use `gpt-4o-transcribe-diarize` when you need diarization with speaker labels.\n"
              })
            ),
            "language": Schema.optionalKey(
              Schema.String.annotate({
                "description":
                  "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"
              })
            ),
            "prompt": Schema.optionalKey(Schema.String.annotate({
              "description":
                "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models (excluding `gpt-4o-transcribe-diarize`), the prompt is a free text string, for example \"expect words related to technology\".\n"
            }))
          }).annotate({ "description": "Configuration for input audio transcription.\n" })
        ),
        "noise_reduction": Schema.optionalKey(
          Schema.Struct({ "type": Schema.optionalKey(NoiseReductionType) }).annotate({
            "description": "Configuration for input audio noise reduction.\n"
          })
        ),
        "turn_detection": Schema.optionalKey(
          Schema.Struct({
            "type": Schema.optionalKey(
              Schema.String.annotate({
                "description": "Type of turn detection, only `server_vad` is currently supported.\n"
              })
            ),
            "threshold": Schema.optionalKey(Schema.Number.check(Schema.isFinite())),
            "prefix_padding_ms": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
            "silence_duration_ms": Schema.optionalKey(Schema.Number.check(Schema.isInt()))
          }).annotate({ "description": "Configuration for turn detection.\n" })
        )
      })),
      "output": Schema.optionalKey(
        Schema.Struct({
          "format": Schema.optionalKey(RealtimeAudioFormats),
          "voice": Schema.optionalKey(VoiceIdsShared),
          "speed": Schema.optionalKey(Schema.Number.check(Schema.isFinite()))
        })
      )
    }).annotate({ "description": "Configuration for input and output audio for the session.\n" })
  ),
  "tracing": Schema.optionalKey(
    Schema.Union([
      Schema.Literal("auto").annotate({ "description": "Default tracing mode for the session.\n" }),
      Schema.Struct({
        "workflow_name": Schema.optionalKey(
          Schema.String.annotate({
            "description":
              "The name of the workflow to attach to this trace. This is used to\nname the trace in the traces dashboard.\n"
          })
        ),
        "group_id": Schema.optionalKey(
          Schema.String.annotate({
            "description":
              "The group id to attach to this trace to enable filtering and\ngrouping in the traces dashboard.\n"
          })
        ),
        "metadata": Schema.optionalKey(
          Schema.Struct({}).annotate({
            "description":
              "The arbitrary metadata to attach to this trace to enable\nfiltering in the traces dashboard.\n"
          })
        )
      }).annotate({ "title": "Tracing Configuration", "description": "Granular configuration for tracing.\n" })
    ], { mode: "oneOf" }).annotate({
      "title": "Tracing Configuration",
      "description":
        "Configuration options for tracing. Set to null to disable tracing. Once\ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the\nworkflow name, group id, and metadata.\n"
    })
  ),
  "turn_detection": Schema.optionalKey(
    Schema.Struct({
      "type": Schema.optionalKey(
        Schema.String.annotate({ "description": "Type of turn detection, only `server_vad` is currently supported.\n" })
      ),
      "threshold": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\nhigher threshold will require louder audio to activate the model, and\nthus might perform better in noisy environments.\n"
        }).check(Schema.isFinite())
      ),
      "prefix_padding_ms": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "Amount of audio to include before the VAD detected speech (in\nmilliseconds). Defaults to 300ms.\n"
        }).check(Schema.isInt())
      ),
      "silence_duration_ms": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "Duration of silence to detect speech stop (in milliseconds). Defaults\nto 500ms. With shorter values the model will respond more quickly,\nbut may jump in on short pauses from the user.\n"
        }).check(Schema.isInt())
      )
    }).annotate({
      "description":
        "Configuration for turn detection. Can be set to `null` to turn off. Server\nVAD means that the model will detect the start and end of speech based on\naudio volume and respond at the end of user speech.\n"
    })
  ),
  "tools": Schema.optionalKey(
    Schema.Array(RealtimeFunctionTool).annotate({ "description": "Tools (functions) available to the model." })
  ),
  "tool_choice": Schema.optionalKey(
    Schema.String.annotate({
      "description": "How the model chooses tools. Options are `auto`, `none`, `required`, or\nspecify a function.\n"
    })
  ),
  "max_output_tokens": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")], { mode: "oneOf" }).annotate({
      "description":
        "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"
    })
  )
}).annotate({
  "title": "Realtime session configuration object",
  "description": "A Realtime session configuration object.\n"
})
export type WebSearchToolCall = {
  readonly "id": string
  readonly "type": "web_search_call"
  readonly "status": "in_progress" | "searching" | "completed" | "failed"
  readonly "action": WebSearchActionSearch | WebSearchActionOpenPage | WebSearchActionFind
}
export const WebSearchToolCall = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The unique ID of the web search tool call.\n" }),
  "type": Schema.Literal("web_search_call").annotate({
    "description": "The type of the web search tool call. Always `web_search_call`.\n"
  }),
  "status": Schema.Literals(["in_progress", "searching", "completed", "failed"]).annotate({
    "description": "The status of the web search tool call.\n"
  }),
  "action": Schema.Union([WebSearchActionSearch, WebSearchActionOpenPage, WebSearchActionFind], { mode: "oneOf" })
    .annotate({
      "description":
        "An object describing the specific action taken in this web search call.\nIncludes details on how the model used the web (search, open_page, find_in_page).\n"
    })
}).annotate({
  "title": "Web search tool call",
  "description":
    "The results of a web search tool call. See the\n[web search guide](/docs/guides/tools-web-search) for more information.\n"
})
export type WebSearchTool = {
  readonly "type": "web_search" | "web_search_2025_08_26"
  readonly "filters"?: { readonly "allowed_domains"?: ReadonlyArray<string> | null } | null
  readonly "user_location"?: WebSearchApproximateLocation
  readonly "search_context_size"?: "low" | "medium" | "high"
}
export const WebSearchTool = Schema.Struct({
  "type": Schema.Literals(["web_search", "web_search_2025_08_26"]).annotate({
    "description": "The type of the web search tool. One of `web_search` or `web_search_2025_08_26`."
  }),
  "filters": Schema.optionalKey(Schema.Union([
    Schema.Struct({
      "allowed_domains": Schema.optionalKey(
        Schema.Union([
          Schema.Array(Schema.String.annotate({ "description": "Allowed domain for the search." })).annotate({
            "title": "Allowed domains for the search.",
            "description":
              "Allowed domains for the search. If not provided, all domains are allowed.\nSubdomains of the provided domains are allowed as well.\n\nExample: `[\"pubmed.ncbi.nlm.nih.gov\"]`\n"
          }),
          Schema.Null
        ])
      )
    }).annotate({ "description": "Filters for the search.\n" }),
    Schema.Null
  ])),
  "user_location": Schema.optionalKey(WebSearchApproximateLocation),
  "search_context_size": Schema.optionalKey(
    Schema.Literals(["low", "medium", "high"]).annotate({
      "description":
        "High level guidance for the amount of context window space to use for the search. One of `low`, `medium`, or `high`. `medium` is the default."
    })
  )
}).annotate({
  "title": "Web search",
  "description":
    "Search the Internet for sources related to the prompt. Learn more about the\n[web search tool](/docs/guides/tools-web-search).\n"
})
export type ContainerNetworkPolicyAllowlistParam = {
  readonly "type": "allowlist"
  readonly "allowed_domains": ReadonlyArray<string>
  readonly "domain_secrets"?: ReadonlyArray<ContainerNetworkPolicyDomainSecretParam>
}
export const ContainerNetworkPolicyAllowlistParam = Schema.Struct({
  "type": Schema.Literal("allowlist").annotate({
    "description": "Allow outbound network access only to specified domains. Always `allowlist`."
  }),
  "allowed_domains": Schema.Array(Schema.String).annotate({
    "description": "A list of allowed domains when type is `allowlist`."
  }).check(Schema.isMinLength(1)),
  "domain_secrets": Schema.optionalKey(
    Schema.Array(ContainerNetworkPolicyDomainSecretParam).annotate({
      "description": "Optional domain-scoped secrets for allowlisted domains."
    }).check(Schema.isMinLength(1))
  )
})
export type EvalItemContentItem =
  | EvalItemContentText
  | InputTextContent
  | EvalItemContentOutputText
  | EvalItemInputImage
  | InputAudio
export const EvalItemContentItem = Schema.Union([
  EvalItemContentText,
  InputTextContent,
  EvalItemContentOutputText,
  EvalItemInputImage,
  InputAudio
], { mode: "oneOf" }).annotate({
  "title": "Eval content item",
  "description": "A single content item: input text, output text, input image, or input audio.\n"
})
export type Annotation = FileCitationBody | UrlCitationBody | ContainerFileCitationBody | FilePath
export const Annotation = Schema.Union([FileCitationBody, UrlCitationBody, ContainerFileCitationBody, FilePath], {
  mode: "oneOf"
}).annotate({ "description": "An annotation that applies to a span of output text." })
export type LogProb = {
  readonly "token": string
  readonly "logprob": number
  readonly "bytes": ReadonlyArray<number>
  readonly "top_logprobs": ReadonlyArray<TopLogProb>
}
export const LogProb = Schema.Struct({
  "token": Schema.String,
  "logprob": Schema.Number.check(Schema.isFinite()),
  "bytes": Schema.Array(Schema.Number.check(Schema.isInt())),
  "top_logprobs": Schema.Array(TopLogProb)
}).annotate({ "title": "Log probability", "description": "The log probability of a token." })
export type ReasoningItem = {
  readonly "type": "reasoning"
  readonly "id": string
  readonly "encrypted_content"?: string | null
  readonly "summary": ReadonlyArray<SummaryTextContent>
  readonly "content"?: ReadonlyArray<ReasoningTextContent>
  readonly "status"?: "in_progress" | "completed" | "incomplete"
}
export const ReasoningItem = Schema.Struct({
  "type": Schema.Literal("reasoning").annotate({ "description": "The type of the object. Always `reasoning`.\n" }),
  "id": Schema.String.annotate({ "description": "The unique identifier of the reasoning content.\n" }),
  "encrypted_content": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "The encrypted content of the reasoning item - populated when a response is\ngenerated with `reasoning.encrypted_content` in the `include` parameter.\n"
      }),
      Schema.Null
    ])
  ),
  "summary": Schema.Array(SummaryTextContent).annotate({ "description": "Reasoning summary content.\n" }),
  "content": Schema.optionalKey(
    Schema.Array(ReasoningTextContent).annotate({ "description": "Reasoning text content.\n" })
  ),
  "status": Schema.optionalKey(
    Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
      "description":
        "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"
    })
  )
}).annotate({
  "title": "Reasoning",
  "description":
    "A description of the chain of thought used by a reasoning model while generating\na response. Be sure to include these items in your `input` to the Responses API\nfor subsequent turns of a conversation if you are manually\n[managing context](/docs/guides/conversation-state).\n"
})
export type FunctionAndCustomToolCallOutput = InputTextContent | InputImageContent | InputFileContent
export const FunctionAndCustomToolCallOutput = Schema.Union([InputTextContent, InputImageContent, InputFileContent], {
  mode: "oneOf"
})
export type InputContent = InputTextContent | InputImageContent | InputFileContent
export const InputContent = Schema.Union([InputTextContent, InputImageContent, InputFileContent], { mode: "oneOf" })
export type DragParam = { readonly "type": "drag"; readonly "path": ReadonlyArray<CoordParam> }
export const DragParam = Schema.Struct({
  "type": Schema.Literal("drag").annotate({
    "description": "Specifies the event type. For a drag action, this property is always set to `drag`."
  }),
  "path": Schema.Array(CoordParam).annotate({
    "description":
      "An array of coordinates representing the path of the drag action. Coordinates will appear as an array of objects, eg\n```\n[\n  { x: 100, y: 200 },\n  { x: 200, y: 300 }\n]\n```"
  })
}).annotate({ "title": "Drag", "description": "A drag action." })
export type ComputerToolCallOutputResource = {
  readonly "type": "computer_call_output"
  readonly "id": string
  readonly "call_id": string
  readonly "acknowledged_safety_checks"?: ReadonlyArray<ComputerCallSafetyCheckParam>
  readonly "output": ComputerScreenshotImage
  readonly "status"?: "in_progress" | "completed" | "incomplete"
}
export const ComputerToolCallOutputResource = Schema.Struct({
  "type": Schema.Literal("computer_call_output").annotate({
    "description": "The type of the computer tool call output. Always `computer_call_output`.\n"
  }),
  "id": Schema.String.annotate({ "description": "The unique ID of the computer call tool output.\n" }),
  "call_id": Schema.String.annotate({ "description": "The ID of the computer tool call that produced the output.\n" }),
  "acknowledged_safety_checks": Schema.optionalKey(
    Schema.Array(ComputerCallSafetyCheckParam).annotate({
      "description": "The safety checks reported by the API that have been acknowledged by the\ndeveloper.\n"
    })
  ),
  "output": ComputerScreenshotImage,
  "status": Schema.optionalKey(
    Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
      "description":
        "The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n"
    })
  )
}).annotate({ "title": "Computer tool call output", "description": "The output of a computer tool call.\n" })
export type ComputerCallOutputItemParam = {
  readonly "id"?: string | null
  readonly "call_id": string
  readonly "type": "computer_call_output"
  readonly "output": ComputerScreenshotImage
  readonly "acknowledged_safety_checks"?: ReadonlyArray<ComputerCallSafetyCheckParam> | null
  readonly "status"?: "in_progress" | "completed" | "incomplete" | null
}
export const ComputerCallOutputItemParam = Schema.Struct({
  "id": Schema.optionalKey(
    Schema.Union([Schema.String.annotate({ "description": "The ID of the computer tool call output." }), Schema.Null])
  ),
  "call_id": Schema.String.annotate({ "description": "The ID of the computer tool call that produced the output." })
    .check(Schema.isMinLength(1)).check(Schema.isMaxLength(64)),
  "type": Schema.Literal("computer_call_output").annotate({
    "description": "The type of the computer tool call output. Always `computer_call_output`."
  }),
  "output": ComputerScreenshotImage,
  "acknowledged_safety_checks": Schema.optionalKey(
    Schema.Union([
      Schema.Array(ComputerCallSafetyCheckParam).annotate({
        "description": "The safety checks reported by the API that have been acknowledged by the developer."
      }),
      Schema.Null
    ])
  ),
  "status": Schema.optionalKey(
    Schema.Union([
      Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
        "description":
          "The status of the message input. One of `in_progress`, `completed`, or `incomplete`. Populated when input items are returned via API."
      }),
      Schema.Null
    ])
  )
}).annotate({ "title": "Computer tool call output", "description": "The output of a computer tool call." })
export type CodeInterpreterToolCall = {
  readonly "type": "code_interpreter_call"
  readonly "id": string
  readonly "status": "in_progress" | "completed" | "incomplete" | "interpreting" | "failed"
  readonly "container_id": string
  readonly "code": string | null
  readonly "outputs": ReadonlyArray<CodeInterpreterOutputLogs | CodeInterpreterOutputImage> | null
}
export const CodeInterpreterToolCall = Schema.Struct({
  "type": Schema.Literal("code_interpreter_call").annotate({
    "description": "The type of the code interpreter tool call. Always `code_interpreter_call`.\n"
  }),
  "id": Schema.String.annotate({ "description": "The unique ID of the code interpreter tool call.\n" }),
  "status": Schema.Literals(["in_progress", "completed", "incomplete", "interpreting", "failed"]).annotate({
    "description":
      "The status of the code interpreter tool call. Valid values are `in_progress`, `completed`, `incomplete`, `interpreting`, and `failed`.\n"
  }),
  "container_id": Schema.String.annotate({ "description": "The ID of the container used to run the code.\n" }),
  "code": Schema.Union([
    Schema.String.annotate({ "description": "The code to run, or null if not available.\n" }),
    Schema.Null
  ]),
  "outputs": Schema.Union([
    Schema.Array(Schema.Union([CodeInterpreterOutputLogs, CodeInterpreterOutputImage], { mode: "oneOf" })).annotate({
      "description":
        "The outputs generated by the code interpreter, such as logs or images.\nCan be null if no outputs are available.\n"
    }),
    Schema.Null
  ])
}).annotate({ "title": "Code interpreter tool call", "description": "A tool call to run code.\n" })
export type LocalShellToolCall = {
  readonly "type": "local_shell_call"
  readonly "id": string
  readonly "call_id": string
  readonly "action": LocalShellExecAction
  readonly "status": "in_progress" | "completed" | "incomplete"
}
export const LocalShellToolCall = Schema.Struct({
  "type": Schema.Literal("local_shell_call").annotate({
    "description": "The type of the local shell call. Always `local_shell_call`.\n"
  }),
  "id": Schema.String.annotate({ "description": "The unique ID of the local shell call.\n" }),
  "call_id": Schema.String.annotate({
    "description": "The unique ID of the local shell tool call generated by the model.\n"
  }),
  "action": LocalShellExecAction,
  "status": Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
    "description": "The status of the local shell call.\n"
  })
}).annotate({ "title": "Local shell call", "description": "A tool call to run a command on the local shell.\n" })
export type FunctionShellCall = {
  readonly "type": "shell_call"
  readonly "id": string
  readonly "call_id": string
  readonly "action": {
    readonly "commands": ReadonlyArray<string>
    readonly "timeout_ms": number | null
    readonly "max_output_length": number | null
  }
  readonly "status": "in_progress" | "completed" | "incomplete"
  readonly "environment": LocalEnvironmentResource | ContainerReferenceResource | null
  readonly "created_by"?: string
}
export const FunctionShellCall = Schema.Struct({
  "type": Schema.Literal("shell_call").annotate({ "description": "The type of the item. Always `shell_call`." }),
  "id": Schema.String.annotate({
    "description": "The unique ID of the shell tool call. Populated when this item is returned via API."
  }),
  "call_id": Schema.String.annotate({ "description": "The unique ID of the shell tool call generated by the model." }),
  "action": Schema.Struct({
    "commands": Schema.Array(Schema.String.annotate({ "description": "A list of commands to run." })),
    "timeout_ms": Schema.Union([
      Schema.Number.annotate({ "description": "Optional timeout in milliseconds for the commands." }).check(
        Schema.isInt()
      ),
      Schema.Null
    ]),
    "max_output_length": Schema.Union([
      Schema.Number.annotate({ "description": "Optional maximum number of characters to return from each command." })
        .check(Schema.isInt()),
      Schema.Null
    ])
  }).annotate({
    "title": "Shell exec action",
    "description": "The shell commands and limits that describe how to run the tool call."
  }),
  "status": Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
    "description": "The status of the shell call. One of `in_progress`, `completed`, or `incomplete`."
  }),
  "environment": Schema.Union([
    Schema.Union([LocalEnvironmentResource, ContainerReferenceResource], { mode: "oneOf" }),
    Schema.Null
  ]),
  "created_by": Schema.optionalKey(
    Schema.String.annotate({ "description": "The ID of the entity that created this tool call." })
  )
}).annotate({
  "title": "Shell tool call",
  "description": "A tool call that executes one or more shell commands in a managed environment."
})
export type FunctionShellCallOutputContent = {
  readonly "stdout": string
  readonly "stderr": string
  readonly "outcome": FunctionShellCallOutputTimeoutOutcome | FunctionShellCallOutputExitOutcome
  readonly "created_by"?: string
}
export const FunctionShellCallOutputContent = Schema.Struct({
  "stdout": Schema.String.annotate({ "description": "The standard output that was captured." }),
  "stderr": Schema.String.annotate({ "description": "The standard error output that was captured." }),
  "outcome": Schema.Union([FunctionShellCallOutputTimeoutOutcome, FunctionShellCallOutputExitOutcome], {
    mode: "oneOf"
  }).annotate({
    "title": "Shell call outcome",
    "description":
      "Represents either an exit outcome (with an exit code) or a timeout outcome for a shell call output chunk."
  }),
  "created_by": Schema.optionalKey(
    Schema.String.annotate({ "description": "The identifier of the actor that created the item." })
  )
}).annotate({
  "title": "Shell call output content",
  "description": "The content of a shell tool call output that was emitted."
})
export type ApplyPatchToolCall = {
  readonly "type": "apply_patch_call"
  readonly "id": string
  readonly "call_id": string
  readonly "status": "in_progress" | "completed"
  readonly "operation": ApplyPatchCreateFileOperation | ApplyPatchDeleteFileOperation | ApplyPatchUpdateFileOperation
  readonly "created_by"?: string
}
export const ApplyPatchToolCall = Schema.Struct({
  "type": Schema.Literal("apply_patch_call").annotate({
    "description": "The type of the item. Always `apply_patch_call`."
  }),
  "id": Schema.String.annotate({
    "description": "The unique ID of the apply patch tool call. Populated when this item is returned via API."
  }),
  "call_id": Schema.String.annotate({
    "description": "The unique ID of the apply patch tool call generated by the model."
  }),
  "status": Schema.Literals(["in_progress", "completed"]).annotate({
    "description": "The status of the apply patch tool call. One of `in_progress` or `completed`."
  }),
  "operation": Schema.Union([
    ApplyPatchCreateFileOperation,
    ApplyPatchDeleteFileOperation,
    ApplyPatchUpdateFileOperation
  ], { mode: "oneOf" }).annotate({
    "title": "Apply patch operation",
    "description": "One of the create_file, delete_file, or update_file operations applied via apply_patch."
  }),
  "created_by": Schema.optionalKey(
    Schema.String.annotate({ "description": "The ID of the entity that created this tool call." })
  )
}).annotate({
  "title": "Apply patch tool call",
  "description": "A tool call that applies file diffs by creating, deleting, or updating files."
})
export type FunctionCallOutputItemParam = {
  readonly "id"?: string | null
  readonly "call_id": string
  readonly "type": "function_call_output"
  readonly "output":
    | string
    | ReadonlyArray<InputTextContentParam | InputImageContentParamAutoParam | InputFileContentParam>
  readonly "status"?: "in_progress" | "completed" | "incomplete" | null
}
export const FunctionCallOutputItemParam = Schema.Struct({
  "id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "The unique ID of the function tool call output. Populated when this item is returned via API."
      }),
      Schema.Null
    ])
  ),
  "call_id": Schema.String.annotate({
    "description": "The unique ID of the function tool call generated by the model."
  }).check(Schema.isMinLength(1)).check(Schema.isMaxLength(64)),
  "type": Schema.Literal("function_call_output").annotate({
    "description": "The type of the function tool call output. Always `function_call_output`."
  }),
  "output": Schema.Union([
    Schema.String.annotate({ "description": "A JSON string of the output of the function tool call." }).check(
      Schema.isMaxLength(10485760)
    ),
    Schema.Array(
      Schema.Union([InputTextContentParam, InputImageContentParamAutoParam, InputFileContentParam], { mode: "oneOf" })
        .annotate({ "description": "A piece of message content, such as text, an image, or a file." })
    ).annotate({ "description": "An array of content outputs (text, image, file) for the function tool call." })
  ], { mode: "oneOf" }).annotate({ "description": "Text, image, or file output of the function tool call." }),
  "status": Schema.optionalKey(
    Schema.Union([
      Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
        "description":
          "The status of the item. One of `in_progress`, `completed`, or `incomplete`. Populated when items are returned via API."
      }),
      Schema.Null
    ])
  )
}).annotate({ "title": "Function tool call output", "description": "The output of a function tool call." })
export type LocalEnvironmentParam = { readonly "type": "local"; readonly "skills"?: ReadonlyArray<LocalSkillParam> }
export const LocalEnvironmentParam = Schema.Struct({
  "type": Schema.Literal("local").annotate({ "description": "Use a local computer environment." }),
  "skills": Schema.optionalKey(
    Schema.Array(LocalSkillParam).annotate({ "description": "An optional list of skills." }).check(
      Schema.isMaxLength(200)
    )
  )
})
export type FunctionShellCallOutputContentParam = {
  readonly "stdout": string
  readonly "stderr": string
  readonly "outcome": FunctionShellCallOutputTimeoutOutcomeParam | FunctionShellCallOutputExitOutcomeParam
}
export const FunctionShellCallOutputContentParam = Schema.Struct({
  "stdout": Schema.String.annotate({ "description": "Captured stdout output for the shell call." }).check(
    Schema.isMaxLength(10485760)
  ),
  "stderr": Schema.String.annotate({ "description": "Captured stderr output for the shell call." }).check(
    Schema.isMaxLength(10485760)
  ),
  "outcome": Schema.Union([FunctionShellCallOutputTimeoutOutcomeParam, FunctionShellCallOutputExitOutcomeParam], {
    mode: "oneOf"
  }).annotate({
    "title": "Shell call outcome",
    "description": "The exit or timeout outcome associated with this shell call."
  })
}).annotate({
  "title": "Shell output content",
  "description": "Captured stdout and stderr for a portion of a shell tool call output."
})
export type ApplyPatchToolCallItemParam = {
  readonly "type": "apply_patch_call"
  readonly "id"?: string | null
  readonly "call_id": string
  readonly "status": "in_progress" | "completed"
  readonly "operation":
    | ApplyPatchCreateFileOperationParam
    | ApplyPatchDeleteFileOperationParam
    | ApplyPatchUpdateFileOperationParam
}
export const ApplyPatchToolCallItemParam = Schema.Struct({
  "type": Schema.Literal("apply_patch_call").annotate({
    "description": "The type of the item. Always `apply_patch_call`."
  }),
  "id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "The unique ID of the apply patch tool call. Populated when this item is returned via API."
      }),
      Schema.Null
    ])
  ),
  "call_id": Schema.String.annotate({
    "description": "The unique ID of the apply patch tool call generated by the model."
  }).check(Schema.isMinLength(1)).check(Schema.isMaxLength(64)),
  "status": Schema.Literals(["in_progress", "completed"]).annotate({
    "title": "Apply patch call status",
    "description": "The status of the apply patch tool call. One of `in_progress` or `completed`."
  }),
  "operation": Schema.Union([
    ApplyPatchCreateFileOperationParam,
    ApplyPatchDeleteFileOperationParam,
    ApplyPatchUpdateFileOperationParam
  ], { mode: "oneOf" }).annotate({
    "title": "Apply patch operation",
    "description": "The specific create, delete, or update instruction for the apply_patch tool call."
  })
}).annotate({
  "title": "Apply patch tool call",
  "description": "A tool call representing a request to create, delete, or update files using diff patches."
})
export type CreateImageEditRequest = {
  readonly "image": string | ReadonlyArray<string>
  readonly "prompt": string
  readonly "mask"?: string
  readonly "background"?: "transparent" | "opaque" | "auto" | null
  readonly "model"?:
    | string
    | "gpt-image-1.5"
    | "dall-e-2"
    | "gpt-image-1"
    | "gpt-image-1-mini"
    | "chatgpt-image-latest"
    | null
  readonly "n"?: number | null
  readonly "size"?: "256x256" | "512x512" | "1024x1024" | "1536x1024" | "1024x1536" | "auto" | null
  readonly "response_format"?: "url" | "b64_json" | null
  readonly "output_format"?: "png" | "jpeg" | "webp" | null
  readonly "output_compression"?: number | null
  readonly "user"?: string
  readonly "input_fidelity"?: InputFidelity | null
  readonly "stream"?: boolean | null
  readonly "partial_images"?: PartialImages
  readonly "quality"?: "standard" | "low" | "medium" | "high" | "auto" | null
}
export const CreateImageEditRequest = Schema.Struct({
  "image": Schema.Union([
    Schema.String.annotate({ "format": "binary" }),
    Schema.Array(Schema.String.annotate({ "format": "binary" })).check(Schema.isMaxLength(16))
  ]).annotate({
    "description":
      "The image(s) to edit. Must be a supported image file or an array of images.\n\nFor the GPT image models (`gpt-image-1`, `gpt-image-1-mini`, and `gpt-image-1.5`), each image should be a `png`, `webp`, or `jpg`\nfile less than 50MB. You can provide up to 16 images.\n`chatgpt-image-latest` follows the same input constraints as GPT image models.\n\nFor `dall-e-2`, you can only provide one image, and it should be a square\n`png` file less than 4MB.\n"
  }),
  "prompt": Schema.String.annotate({
    "description":
      "A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2`, and 32000 characters for the GPT image models."
  }),
  "mask": Schema.optionalKey(Schema.String.annotate({
    "description":
      "An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where `image` should be edited. If there are multiple images provided, the mask will be applied on the first image. Must be a valid PNG file, less than 4MB, and have the same dimensions as `image`.",
    "format": "binary"
  })),
  "background": Schema.optionalKey(
    Schema.Union([Schema.Literal("transparent"), Schema.Literal("opaque"), Schema.Literal("auto"), Schema.Null])
      .annotate({
        "description":
          "Allows to set transparency for the background of the generated image(s).\nThis parameter is only supported for the GPT image models. Must be one of\n`transparent`, `opaque` or `auto` (default value). When `auto` is used, the\nmodel will automatically determine the best background for the image.\n\nIf `transparent`, the output format needs to support transparency, so it\nshould be set to either `png` (default value) or `webp`.\n"
      })
  ),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        Schema.String,
        Schema.Literals(["gpt-image-1.5", "dall-e-2", "gpt-image-1", "gpt-image-1-mini", "chatgpt-image-latest"])
      ]).annotate({ "description": "The model to use for image generation. Defaults to `gpt-image-1.5`." }),
      Schema.Null
    ])
  ),
  "n": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description": "The number of images to generate. Must be between 1 and 10."
    })
  ),
  "size": Schema.optionalKey(
    Schema.Union([
      Schema.Literal("256x256"),
      Schema.Literal("512x512"),
      Schema.Literal("1024x1024"),
      Schema.Literal("1536x1024"),
      Schema.Literal("1024x1536"),
      Schema.Literal("auto"),
      Schema.Null
    ]).annotate({
      "description":
        "The size of the generated images. Must be one of `1024x1024`, `1536x1024` (landscape), `1024x1536` (portrait), or `auto` (default value) for the GPT image models, and one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`."
    })
  ),
  "response_format": Schema.optionalKey(
    Schema.Union([Schema.Literal("url"), Schema.Literal("b64_json"), Schema.Null]).annotate({
      "description":
        "The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated. This parameter is only supported for `dall-e-2` (default is `url` for `dall-e-2`), as GPT image models always return base64-encoded images."
    })
  ),
  "output_format": Schema.optionalKey(
    Schema.Union([Schema.Literal("png"), Schema.Literal("jpeg"), Schema.Literal("webp"), Schema.Null]).annotate({
      "description":
        "The format in which the generated images are returned. This parameter is\nonly supported for the GPT image models. Must be one of `png`, `jpeg`, or `webp`.\nThe default value is `png`.\n"
    })
  ),
  "output_compression": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "The compression level (0-100%) for the generated images. This parameter\nis only supported for the GPT image models with the `webp` or `jpeg` output\nformats, and defaults to 100.\n"
    })
  ),
  "user": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).\n"
    })
  ),
  "input_fidelity": Schema.optionalKey(Schema.Union([InputFidelity, Schema.Null])),
  "stream": Schema.optionalKey(
    Schema.Union([Schema.Boolean, Schema.Null]).annotate({
      "description":
        "Edit the image in streaming mode. Defaults to `false`. See the\n[Image generation guide](/docs/guides/image-generation) for more information.\n"
    })
  ),
  "partial_images": Schema.optionalKey(PartialImages),
  "quality": Schema.optionalKey(
    Schema.Union([
      Schema.Literal("standard"),
      Schema.Literal("low"),
      Schema.Literal("medium"),
      Schema.Literal("high"),
      Schema.Literal("auto"),
      Schema.Null
    ]).annotate({
      "description": "The quality of the image that will be generated for GPT image models. Defaults to `auto`.\n"
    })
  )
})
export type ImageGenTool = {
  readonly "type": "image_generation"
  readonly "model"?: string | "gpt-image-1" | "gpt-image-1-mini" | "gpt-image-1.5"
  readonly "quality"?: "low" | "medium" | "high" | "auto"
  readonly "size"?: "1024x1024" | "1024x1536" | "1536x1024" | "auto"
  readonly "output_format"?: "png" | "webp" | "jpeg"
  readonly "output_compression"?: number
  readonly "moderation"?: "auto" | "low"
  readonly "background"?: "transparent" | "opaque" | "auto"
  readonly "input_fidelity"?: InputFidelity | null
  readonly "input_image_mask"?: { readonly "image_url"?: string; readonly "file_id"?: string }
  readonly "partial_images"?: number
  readonly "action"?: "generate" | "edit" | "auto"
}
export const ImageGenTool = Schema.Struct({
  "type": Schema.Literal("image_generation").annotate({
    "description": "The type of the image generation tool. Always `image_generation`.\n"
  }),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.String,
      Schema.Literals(["gpt-image-1", "gpt-image-1-mini", "gpt-image-1.5"]).annotate({
        "description": "The image generation model to use. Default: `gpt-image-1`.\n"
      })
    ])
  ),
  "quality": Schema.optionalKey(
    Schema.Literals(["low", "medium", "high", "auto"]).annotate({
      "description":
        "The quality of the generated image. One of `low`, `medium`, `high`,\nor `auto`. Default: `auto`.\n"
    })
  ),
  "size": Schema.optionalKey(
    Schema.Literals(["1024x1024", "1024x1536", "1536x1024", "auto"]).annotate({
      "description":
        "The size of the generated image. One of `1024x1024`, `1024x1536`,\n`1536x1024`, or `auto`. Default: `auto`.\n"
    })
  ),
  "output_format": Schema.optionalKey(
    Schema.Literals(["png", "webp", "jpeg"]).annotate({
      "description": "The output format of the generated image. One of `png`, `webp`, or\n`jpeg`. Default: `png`.\n"
    })
  ),
  "output_compression": Schema.optionalKey(
    Schema.Number.annotate({ "description": "Compression level for the output image. Default: 100.\n" }).check(
      Schema.isInt()
    ).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(100))
  ),
  "moderation": Schema.optionalKey(
    Schema.Literals(["auto", "low"]).annotate({
      "description": "Moderation level for the generated image. Default: `auto`.\n"
    })
  ),
  "background": Schema.optionalKey(
    Schema.Literals(["transparent", "opaque", "auto"]).annotate({
      "description":
        "Background type for the generated image. One of `transparent`,\n`opaque`, or `auto`. Default: `auto`.\n"
    })
  ),
  "input_fidelity": Schema.optionalKey(Schema.Union([InputFidelity, Schema.Null])),
  "input_image_mask": Schema.optionalKey(
    Schema.Struct({
      "image_url": Schema.optionalKey(Schema.String.annotate({ "description": "Base64-encoded mask image.\n" })),
      "file_id": Schema.optionalKey(Schema.String.annotate({ "description": "File ID for the mask image.\n" }))
    }).annotate({
      "description":
        "Optional mask for inpainting. Contains `image_url`\n(string, optional) and `file_id` (string, optional).\n"
    })
  ),
  "partial_images": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "Number of partial images to generate in streaming mode, from 0 (default value) to 3.\n"
    }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(3))
  ),
  "action": Schema.optionalKey(
    Schema.Literals(["generate", "edit", "auto"]).annotate({
      "description": "Whether to generate a new image or edit an existing image. Default: `auto`.\n"
    })
  )
}).annotate({
  "title": "Image generation tool",
  "description": "A tool that generates images using the GPT image models.\n"
})
export type CustomToolParam = {
  readonly "type": "custom"
  readonly "name": string
  readonly "description"?: string
  readonly "format"?: CustomTextFormatParam | CustomGrammarFormatParam
}
export const CustomToolParam = Schema.Struct({
  "type": Schema.Literal("custom").annotate({ "description": "The type of the custom tool. Always `custom`." }),
  "name": Schema.String.annotate({ "description": "The name of the custom tool, used to identify it in tool calls." }),
  "description": Schema.optionalKey(
    Schema.String.annotate({ "description": "Optional description of the custom tool, used to provide more context." })
  ),
  "format": Schema.optionalKey(
    Schema.Union([CustomTextFormatParam, CustomGrammarFormatParam], { mode: "oneOf" }).annotate({
      "description": "The input format for the custom tool. Default is unconstrained text."
    })
  )
}).annotate({
  "title": "Custom tool",
  "description":
    "A custom tool that processes input using a specified format. Learn more about   [custom tools](/docs/guides/function-calling#custom-tools)"
})
export type ImageGenUsage = {
  readonly "input_tokens": number
  readonly "total_tokens": number
  readonly "output_tokens": number
  readonly "output_tokens_details"?: ImageGenOutputTokensDetails
  readonly "input_tokens_details": ImageGenInputUsageDetails
}
export const ImageGenUsage = Schema.Struct({
  "input_tokens": Schema.Number.annotate({
    "description": "The number of tokens (images and text) in the input prompt."
  }).check(Schema.isInt()),
  "total_tokens": Schema.Number.annotate({
    "description": "The total number of tokens (images and text) used for the image generation."
  }).check(Schema.isInt()),
  "output_tokens": Schema.Number.annotate({ "description": "The number of output tokens generated by the model." })
    .check(Schema.isInt()),
  "output_tokens_details": Schema.optionalKey(ImageGenOutputTokensDetails),
  "input_tokens_details": ImageGenInputUsageDetails
}).annotate({
  "title": "Image generation usage",
  "description": "For `gpt-image-1` only, the token usage information for the image generation."
})
export type ToolChoiceParam =
  | ToolChoiceOptions
  | ToolChoiceAllowed
  | ToolChoiceTypes
  | ToolChoiceFunction
  | ToolChoiceMCP
  | ToolChoiceCustom
  | SpecificApplyPatchParam
  | SpecificFunctionShellParam
export const ToolChoiceParam = Schema.Union([
  ToolChoiceOptions,
  ToolChoiceAllowed,
  ToolChoiceTypes,
  ToolChoiceFunction,
  ToolChoiceMCP,
  ToolChoiceCustom,
  SpecificApplyPatchParam,
  SpecificFunctionShellParam
], { mode: "oneOf" }).annotate({
  "description":
    "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"
})
export type ConversationParam = string | ConversationParam_2
export const ConversationParam = Schema.Union([
  Schema.String.annotate({ "title": "Conversation ID", "description": "The unique ID of the conversation.\n" }),
  ConversationParam_2
], { mode: "oneOf" }).annotate({
  "description":
    "The conversation that this response belongs to. Items from this conversation are prepended to `input_items` for this response request.\nInput items and output items from this response are automatically added to this conversation after this response completes.\n"
})
export type VideoListResource = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<VideoResource>
  readonly "first_id": string | null
  readonly "last_id": string | null
  readonly "has_more": boolean
}
export const VideoListResource = Schema.Struct({
  "object": Schema.Literal("list").annotate({ "description": "The type of object returned, must be `list`." }),
  "data": Schema.Array(VideoResource).annotate({ "description": "A list of items" }),
  "first_id": Schema.Union([
    Schema.String.annotate({ "description": "The ID of the first item in the list." }),
    Schema.Null
  ]),
  "last_id": Schema.Union([
    Schema.String.annotate({ "description": "The ID of the last item in the list." }),
    Schema.Null
  ]),
  "has_more": Schema.Boolean.annotate({ "description": "Whether there are more items available." })
})
export type SkillListResource = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<SkillResource>
  readonly "first_id": string | null
  readonly "last_id": string | null
  readonly "has_more": boolean
}
export const SkillListResource = Schema.Struct({
  "object": Schema.Literal("list").annotate({ "description": "The type of object returned, must be `list`." }),
  "data": Schema.Array(SkillResource).annotate({ "description": "A list of items" }),
  "first_id": Schema.Union([
    Schema.String.annotate({ "description": "The ID of the first item in the list." }),
    Schema.Null
  ]),
  "last_id": Schema.Union([
    Schema.String.annotate({ "description": "The ID of the last item in the list." }),
    Schema.Null
  ]),
  "has_more": Schema.Boolean.annotate({ "description": "Whether there are more items available." })
})
export type SkillVersionListResource = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<SkillVersionResource>
  readonly "first_id": string | null
  readonly "last_id": string | null
  readonly "has_more": boolean
}
export const SkillVersionListResource = Schema.Struct({
  "object": Schema.Literal("list").annotate({ "description": "The type of object returned, must be `list`." }),
  "data": Schema.Array(SkillVersionResource).annotate({ "description": "A list of items" }),
  "first_id": Schema.Union([
    Schema.String.annotate({ "description": "The ID of the first item in the list." }),
    Schema.Null
  ]),
  "last_id": Schema.Union([
    Schema.String.annotate({ "description": "The ID of the last item in the list." }),
    Schema.Null
  ]),
  "has_more": Schema.Boolean.annotate({ "description": "Whether there are more items available." })
})
export type UserMessageItem = {
  readonly "id": string
  readonly "object": "chatkit.thread_item"
  readonly "created_at": number
  readonly "thread_id": string
  readonly "type": "chatkit.user_message"
  readonly "content": ReadonlyArray<UserMessageInputText | UserMessageQuotedText>
  readonly "attachments": ReadonlyArray<Attachment>
  readonly "inference_options": {
    readonly "tool_choice": { readonly "id": string } | null
    readonly "model": string | null
  } | null
}
export const UserMessageItem = Schema.Struct({
  "id": Schema.String.annotate({ "description": "Identifier of the thread item." }),
  "object": Schema.Literal("chatkit.thread_item").annotate({
    "description": "Type discriminator that is always `chatkit.thread_item`."
  }),
  "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) for when the item was created." })
    .check(Schema.isInt()),
  "thread_id": Schema.String.annotate({ "description": "Identifier of the parent thread." }),
  "type": Schema.Literal("chatkit.user_message"),
  "content": Schema.Array(
    Schema.Union([UserMessageInputText, UserMessageQuotedText], { mode: "oneOf" }).annotate({
      "description": "Content blocks that comprise a user message."
    })
  ).annotate({ "description": "Ordered content elements supplied by the user." }),
  "attachments": Schema.Array(Attachment).annotate({
    "description": "Attachments associated with the user message. Defaults to an empty list."
  }),
  "inference_options": Schema.Union([
    Schema.Struct({
      "tool_choice": Schema.Union([
        Schema.Struct({ "id": Schema.String.annotate({ "description": "Identifier of the requested tool." }) })
          .annotate({
            "title": "Tool choice",
            "description": "Preferred tool to invoke. Defaults to null when ChatKit should auto-select."
          }),
        Schema.Null
      ]),
      "model": Schema.Union([
        Schema.String.annotate({
          "description": "Model name that generated the response. Defaults to null when using the session default."
        }),
        Schema.Null
      ])
    }).annotate({
      "title": "Inference options",
      "description": "Inference overrides applied to the message. Defaults to null when unset."
    }),
    Schema.Null
  ])
}).annotate({ "title": "User Message Item", "description": "User-authored messages within a thread." })
export type ResponseOutputText = {
  readonly "type": "output_text"
  readonly "text": string
  readonly "annotations": ReadonlyArray<FileAnnotation | UrlAnnotation>
}
export const ResponseOutputText = Schema.Struct({
  "type": Schema.Literal("output_text").annotate({ "description": "Type discriminator that is always `output_text`." }),
  "text": Schema.String.annotate({ "description": "Assistant generated text." }),
  "annotations": Schema.Array(
    Schema.Union([FileAnnotation, UrlAnnotation], { mode: "oneOf" }).annotate({
      "description": "Annotation object describing a cited source."
    })
  ).annotate({ "description": "Ordered list of annotations attached to the response text." })
}).annotate({
  "title": "Assistant message content",
  "description": "Assistant response text accompanied by optional annotations."
})
export type TaskGroupItem = {
  readonly "id": string
  readonly "object": "chatkit.thread_item"
  readonly "created_at": number
  readonly "thread_id": string
  readonly "type": "chatkit.task_group"
  readonly "tasks": ReadonlyArray<TaskGroupTask>
}
export const TaskGroupItem = Schema.Struct({
  "id": Schema.String.annotate({ "description": "Identifier of the thread item." }),
  "object": Schema.Literal("chatkit.thread_item").annotate({
    "description": "Type discriminator that is always `chatkit.thread_item`."
  }),
  "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) for when the item was created." })
    .check(Schema.isInt()),
  "thread_id": Schema.String.annotate({ "description": "Identifier of the parent thread." }),
  "type": Schema.Literal("chatkit.task_group").annotate({
    "description": "Type discriminator that is always `chatkit.task_group`."
  }),
  "tasks": Schema.Array(TaskGroupTask).annotate({ "description": "Tasks included in the group." })
}).annotate({ "title": "Task group", "description": "Collection of workflow tasks grouped together in the thread." })
export type ThreadResource = {
  readonly "id": string
  readonly "object": "chatkit.thread"
  readonly "created_at": number
  readonly "title": string | null
  readonly "status": ActiveStatus | LockedStatus | ClosedStatus
  readonly "user": string
}
export const ThreadResource = Schema.Struct({
  "id": Schema.String.annotate({ "description": "Identifier of the thread." }),
  "object": Schema.Literal("chatkit.thread").annotate({
    "description": "Type discriminator that is always `chatkit.thread`."
  }),
  "created_at": Schema.Number.annotate({
    "description": "Unix timestamp (in seconds) for when the thread was created."
  }).check(Schema.isInt()),
  "title": Schema.Union([
    Schema.String.annotate({
      "description": "Optional human-readable title for the thread. Defaults to null when no title has been generated."
    }),
    Schema.Null
  ]),
  "status": Schema.Union([ActiveStatus, LockedStatus, ClosedStatus], { mode: "oneOf" }).annotate({
    "description": "Current status for the thread. Defaults to `active` for newly created threads."
  }),
  "user": Schema.String.annotate({
    "description": "Free-form string that identifies your end user who owns the thread."
  })
}).annotate({ "title": "The thread object", "description": "Represents a ChatKit thread and its current status." })
export type AuditLogActor = {
  readonly "type"?: "session" | "api_key"
  readonly "session"?: AuditLogActorSession
  readonly "api_key"?: AuditLogActorApiKey
}
export const AuditLogActor = Schema.Struct({
  "type": Schema.optionalKey(
    Schema.Literals(["session", "api_key"]).annotate({
      "description": "The type of actor. Is either `session` or `api_key`."
    })
  ),
  "session": Schema.optionalKey(AuditLogActorSession),
  "api_key": Schema.optionalKey(AuditLogActorApiKey)
}).annotate({ "description": "The actor who performed the audit logged action." })
export type ChatCompletionToolChoiceOption =
  | "none"
  | "auto"
  | "required"
  | ChatCompletionAllowedToolsChoice
  | ChatCompletionNamedToolChoice
  | ChatCompletionNamedToolChoiceCustom
export const ChatCompletionToolChoiceOption = Schema.Union([
  Schema.Literals(["none", "auto", "required"]).annotate({
    "title": "Tool choice mode",
    "description":
      "`none` means the model will not call any tool and instead generates a message. `auto` means the model can pick between generating a message or calling one or more tools. `required` means the model must call one or more tools.\n"
  }),
  ChatCompletionAllowedToolsChoice,
  ChatCompletionNamedToolChoice,
  ChatCompletionNamedToolChoiceCustom
], { mode: "oneOf" }).annotate({
  "description":
    "Controls which (if any) tool is called by the model.\n`none` means the model will not call any tool and instead generates a message.\n`auto` means the model can pick between generating a message or calling one or more tools.\n`required` means the model must call one or more tools.\nSpecifying a particular tool via `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool.\n\n`none` is the default when no tools are present. `auto` is the default if tools are present.\n"
})
export type ChatCompletionMessageList = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<
    {
      readonly "content": string | null
      readonly "refusal": string | null
      readonly "tool_calls"?: ChatCompletionMessageToolCalls
      readonly "annotations"?: ReadonlyArray<
        {
          readonly "type": "url_citation"
          readonly "url_citation": {
            readonly "end_index": number
            readonly "start_index": number
            readonly "url": string
            readonly "title": string
          }
        }
      >
      readonly "role": "assistant"
      readonly "function_call"?: { readonly "arguments": string; readonly "name": string }
      readonly "audio"?: {
        readonly "id": string
        readonly "expires_at": number
        readonly "data": string
        readonly "transcript": string
      } | null
      readonly "id": string
      readonly "content_parts"?:
        | ReadonlyArray<ChatCompletionRequestMessageContentPartText | ChatCompletionRequestMessageContentPartImage>
        | null
    }
  >
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const ChatCompletionMessageList = Schema.Struct({
  "object": Schema.Literal("list").annotate({
    "description": "The type of this object. It is always set to \"list\".\n"
  }),
  "data": Schema.Array(
    Schema.Struct({
      "content": Schema.Union([Schema.String.annotate({ "description": "The contents of the message." }), Schema.Null]),
      "refusal": Schema.Union([
        Schema.String.annotate({ "description": "The refusal message generated by the model." }),
        Schema.Null
      ]),
      "tool_calls": Schema.optionalKey(ChatCompletionMessageToolCalls),
      "annotations": Schema.optionalKey(
        Schema.Array(
          Schema.Struct({
            "type": Schema.Literal("url_citation").annotate({
              "description": "The type of the URL citation. Always `url_citation`."
            }),
            "url_citation": Schema.Struct({
              "end_index": Schema.Number.annotate({
                "description": "The index of the last character of the URL citation in the message."
              }).check(Schema.isInt()),
              "start_index": Schema.Number.annotate({
                "description": "The index of the first character of the URL citation in the message."
              }).check(Schema.isInt()),
              "url": Schema.String.annotate({ "description": "The URL of the web resource." }),
              "title": Schema.String.annotate({ "description": "The title of the web resource." })
            }).annotate({ "description": "A URL citation when using web search." })
          }).annotate({ "description": "A URL citation when using web search.\n" })
        ).annotate({
          "description":
            "Annotations for the message, when applicable, as when using the\n[web search tool](/docs/guides/tools-web-search?api-mode=chat).\n"
        })
      ),
      "role": Schema.Literal("assistant").annotate({ "description": "The role of the author of this message." }),
      "function_call": Schema.optionalKey(
        Schema.Struct({
          "arguments": Schema.String.annotate({
            "description":
              "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."
          }),
          "name": Schema.String.annotate({ "description": "The name of the function to call." })
        }).annotate({
          "description":
            "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."
        })
      ),
      "audio": Schema.optionalKey(Schema.Union([
        Schema.Struct({
          "id": Schema.String.annotate({ "description": "Unique identifier for this audio response." }),
          "expires_at": Schema.Number.annotate({
            "description":
              "The Unix timestamp (in seconds) for when this audio response will\nno longer be accessible on the server for use in multi-turn\nconversations.\n"
          }).check(Schema.isInt()),
          "data": Schema.String.annotate({
            "description":
              "Base64 encoded audio bytes generated by the model, in the format\nspecified in the request.\n"
          }),
          "transcript": Schema.String.annotate({ "description": "Transcript of the audio generated by the model." })
        }).annotate({
          "description":
            "If the audio output modality is requested, this object contains data\nabout the audio response from the model. [Learn more](/docs/guides/audio).\n"
        }),
        Schema.Null
      ])),
      "id": Schema.String.annotate({ "description": "The identifier of the chat message." }),
      "content_parts": Schema.optionalKey(
        Schema.Union([
          Schema.Array(
            Schema.Union([ChatCompletionRequestMessageContentPartText, ChatCompletionRequestMessageContentPartImage], {
              mode: "oneOf"
            })
          ).annotate({
            "description":
              "If a content parts array was provided, this is an array of `text` and `image_url` parts.\nOtherwise, null.\n"
          }),
          Schema.Null
        ])
      )
    }).annotate({ "description": "A chat completion message generated by the model." })
  ).annotate({ "description": "An array of chat completion message objects.\n" }),
  "first_id": Schema.String.annotate({ "description": "The identifier of the first chat message in the data array." }),
  "last_id": Schema.String.annotate({ "description": "The identifier of the last chat message in the data array." }),
  "has_more": Schema.Boolean.annotate({ "description": "Indicates whether there are more chat messages available." })
}).annotate({
  "title": "ChatCompletionMessageList",
  "description": "An object representing a list of chat completion messages.\n"
})
export type ChatCompletionResponseMessage = {
  readonly "content": string | null
  readonly "refusal": string | null
  readonly "tool_calls"?: ChatCompletionMessageToolCalls
  readonly "annotations"?: ReadonlyArray<
    {
      readonly "type": "url_citation"
      readonly "url_citation": {
        readonly "end_index": number
        readonly "start_index": number
        readonly "url": string
        readonly "title": string
      }
    }
  >
  readonly "role": "assistant"
  readonly "function_call"?: { readonly "arguments": string; readonly "name": string }
  readonly "audio"?: {
    readonly "id": string
    readonly "expires_at": number
    readonly "data": string
    readonly "transcript": string
  } | null
}
export const ChatCompletionResponseMessage = Schema.Struct({
  "content": Schema.Union([Schema.String.annotate({ "description": "The contents of the message." }), Schema.Null]),
  "refusal": Schema.Union([
    Schema.String.annotate({ "description": "The refusal message generated by the model." }),
    Schema.Null
  ]),
  "tool_calls": Schema.optionalKey(ChatCompletionMessageToolCalls),
  "annotations": Schema.optionalKey(
    Schema.Array(
      Schema.Struct({
        "type": Schema.Literal("url_citation").annotate({
          "description": "The type of the URL citation. Always `url_citation`."
        }),
        "url_citation": Schema.Struct({
          "end_index": Schema.Number.annotate({
            "description": "The index of the last character of the URL citation in the message."
          }).check(Schema.isInt()),
          "start_index": Schema.Number.annotate({
            "description": "The index of the first character of the URL citation in the message."
          }).check(Schema.isInt()),
          "url": Schema.String.annotate({ "description": "The URL of the web resource." }),
          "title": Schema.String.annotate({ "description": "The title of the web resource." })
        }).annotate({ "description": "A URL citation when using web search." })
      }).annotate({ "description": "A URL citation when using web search.\n" })
    ).annotate({
      "description":
        "Annotations for the message, when applicable, as when using the\n[web search tool](/docs/guides/tools-web-search?api-mode=chat).\n"
    })
  ),
  "role": Schema.Literal("assistant").annotate({ "description": "The role of the author of this message." }),
  "function_call": Schema.optionalKey(
    Schema.Struct({
      "arguments": Schema.String.annotate({
        "description":
          "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."
      }),
      "name": Schema.String.annotate({ "description": "The name of the function to call." })
    }).annotate({
      "description":
        "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."
    })
  ),
  "audio": Schema.optionalKey(Schema.Union([
    Schema.Struct({
      "id": Schema.String.annotate({ "description": "Unique identifier for this audio response." }),
      "expires_at": Schema.Number.annotate({
        "description":
          "The Unix timestamp (in seconds) for when this audio response will\nno longer be accessible on the server for use in multi-turn\nconversations.\n"
      }).check(Schema.isInt()),
      "data": Schema.String.annotate({
        "description": "Base64 encoded audio bytes generated by the model, in the format\nspecified in the request.\n"
      }),
      "transcript": Schema.String.annotate({ "description": "Transcript of the audio generated by the model." })
    }).annotate({
      "description":
        "If the audio output modality is requested, this object contains data\nabout the audio response from the model. [Learn more](/docs/guides/audio).\n"
    }),
    Schema.Null
  ]))
}).annotate({ "description": "A chat completion message generated by the model." })
export type CreateChatCompletionStreamResponse = {
  readonly "id": string
  readonly "choices": ReadonlyArray<
    {
      readonly "delta": ChatCompletionStreamResponseDelta
      readonly "logprobs"?: {} | null
      readonly "finish_reason": "stop" | "length" | "tool_calls" | "content_filter" | "function_call" | null
      readonly "index": number
    }
  >
  readonly "created": number
  readonly "model": string
  readonly "service_tier"?: ServiceTier
  readonly "system_fingerprint"?: string
  readonly "object": "chat.completion.chunk"
  readonly "usage"?: {
    readonly "completion_tokens": number
    readonly "prompt_tokens": number
    readonly "total_tokens": number
    readonly "completion_tokens_details"?: {
      readonly "accepted_prediction_tokens"?: number
      readonly "audio_tokens"?: number
      readonly "reasoning_tokens"?: number
      readonly "rejected_prediction_tokens"?: number
    }
    readonly "prompt_tokens_details"?: { readonly "audio_tokens"?: number; readonly "cached_tokens"?: number }
  } | null
}
export const CreateChatCompletionStreamResponse = Schema.Struct({
  "id": Schema.String.annotate({
    "description": "A unique identifier for the chat completion. Each chunk has the same ID."
  }),
  "choices": Schema.Array(Schema.Struct({
    "delta": ChatCompletionStreamResponseDelta,
    "logprobs": Schema.optionalKey(
      Schema.Union([Schema.Struct({}), Schema.Null]).annotate({
        "description": "Log probability information for the choice."
      })
    ),
    "finish_reason": Schema.Union([
      Schema.Literal("stop"),
      Schema.Literal("length"),
      Schema.Literal("tool_calls"),
      Schema.Literal("content_filter"),
      Schema.Literal("function_call"),
      Schema.Null
    ]).annotate({
      "description":
        "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\n`content_filter` if content was omitted due to a flag from our content filters,\n`tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.\n"
    }),
    "index": Schema.Number.annotate({ "description": "The index of the choice in the list of choices." }).check(
      Schema.isInt()
    )
  })).annotate({
    "description":
      "A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the\nlast chunk if you set `stream_options: {\"include_usage\": true}`.\n"
  }),
  "created": Schema.Number.annotate({
    "description":
      "The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp."
  }).check(Schema.isInt()),
  "model": Schema.String.annotate({ "description": "The model to generate the completion." }),
  "service_tier": Schema.optionalKey(ServiceTier),
  "system_fingerprint": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "This fingerprint represents the backend configuration that the model runs with.\nCan be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.\n"
    })
  ),
  "object": Schema.Literal("chat.completion.chunk").annotate({
    "description": "The object type, which is always `chat.completion.chunk`."
  }),
  "usage": Schema.optionalKey(Schema.Union([
    Schema.Struct({
      "completion_tokens": Schema.Number.annotate({ "description": "Number of tokens in the generated completion." })
        .check(Schema.isInt()),
      "prompt_tokens": Schema.Number.annotate({ "description": "Number of tokens in the prompt." }).check(
        Schema.isInt()
      ),
      "total_tokens": Schema.Number.annotate({
        "description": "Total number of tokens used in the request (prompt + completion)."
      }).check(Schema.isInt()),
      "completion_tokens_details": Schema.optionalKey(
        Schema.Struct({
          "accepted_prediction_tokens": Schema.optionalKey(
            Schema.Number.annotate({
              "description":
                "When using Predicted Outputs, the number of tokens in the\nprediction that appeared in the completion.\n"
            }).check(Schema.isInt())
          ),
          "audio_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "Audio input tokens generated by the model." }).check(
              Schema.isInt()
            )
          ),
          "reasoning_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "Tokens generated by the model for reasoning." }).check(
              Schema.isInt()
            )
          ),
          "rejected_prediction_tokens": Schema.optionalKey(
            Schema.Number.annotate({
              "description":
                "When using Predicted Outputs, the number of tokens in the\nprediction that did not appear in the completion. However, like\nreasoning tokens, these tokens are still counted in the total\ncompletion tokens for purposes of billing, output, and context window\nlimits.\n"
            }).check(Schema.isInt())
          )
        }).annotate({ "description": "Breakdown of tokens used in a completion." })
      ),
      "prompt_tokens_details": Schema.optionalKey(
        Schema.Struct({
          "audio_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "Audio input tokens present in the prompt." }).check(Schema.isInt())
          ),
          "cached_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "Cached tokens present in the prompt." }).check(Schema.isInt())
          )
        }).annotate({ "description": "Breakdown of tokens used in the prompt." })
      )
    }).annotate({
      "description":
        "An optional field that will only be present when you set\n`stream_options: {\"include_usage\": true}` in your request. When present, it\ncontains a null value **except for the last chunk** which contains the\ntoken usage statistics for the entire request.\n\n**NOTE:** If the stream is interrupted or cancelled, you may not\nreceive the final usage chunk which contains the total token usage for\nthe request.\n"
    }),
    Schema.Null
  ]))
}).annotate({
  "description":
    "Represents a streamed chunk of a chat completion response returned\nby the model, based on the provided input. \n[Learn more](/docs/guides/streaming-responses).\n"
})
export type ChatCompletionRequestAssistantMessage = {
  readonly "content"?: string | ReadonlyArray<ChatCompletionRequestAssistantMessageContentPart> | null
  readonly "refusal"?: string | null
  readonly "role": "assistant"
  readonly "name"?: string
  readonly "audio"?: { readonly "id": string } | null
  readonly "tool_calls"?: ChatCompletionMessageToolCalls
  readonly "function_call"?: { readonly "arguments": string; readonly "name": string } | null
}
export const ChatCompletionRequestAssistantMessage = Schema.Struct({
  "content": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        Schema.String.annotate({ "title": "Text content", "description": "The contents of the assistant message." }),
        Schema.Array(ChatCompletionRequestAssistantMessageContentPart).annotate({
          "title": "Array of content parts",
          "description":
            "An array of content parts with a defined type. Can be one or more of type `text`, or exactly one of type `refusal`."
        }).check(Schema.isMinLength(1))
      ], { mode: "oneOf" }).annotate({
        "description":
          "The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.\n"
      }),
      Schema.Null
    ])
  ),
  "refusal": Schema.optionalKey(
    Schema.Union([Schema.String.annotate({ "description": "The refusal message by the assistant." }), Schema.Null])
  ),
  "role": Schema.Literal("assistant").annotate({
    "description": "The role of the messages author, in this case `assistant`."
  }),
  "name": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "An optional name for the participant. Provides the model information to differentiate between participants of the same role."
    })
  ),
  "audio": Schema.optionalKey(
    Schema.Union([
      Schema.Struct({
        "id": Schema.String.annotate({
          "description": "Unique identifier for a previous audio response from the model.\n"
        })
      }).annotate({
        "description": "Data about a previous audio response from the model.\n[Learn more](/docs/guides/audio).\n"
      }),
      Schema.Null
    ])
  ),
  "tool_calls": Schema.optionalKey(ChatCompletionMessageToolCalls),
  "function_call": Schema.optionalKey(Schema.Union([
    Schema.Struct({
      "arguments": Schema.String.annotate({
        "description":
          "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."
      }),
      "name": Schema.String.annotate({ "description": "The name of the function to call." })
    }).annotate({
      "description":
        "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."
    }),
    Schema.Null
  ]))
}).annotate({
  "title": "Assistant message",
  "description": "Messages sent by the model in response to user messages.\n"
})
export type ChatCompletionRequestSystemMessage = {
  readonly "content": string | ReadonlyArray<ChatCompletionRequestSystemMessageContentPart>
  readonly "role": "system"
  readonly "name"?: string
}
export const ChatCompletionRequestSystemMessage = Schema.Struct({
  "content": Schema.Union([
    Schema.String.annotate({ "title": "Text content", "description": "The contents of the system message." }),
    Schema.Array(ChatCompletionRequestSystemMessageContentPart).annotate({
      "title": "Array of content parts",
      "description":
        "An array of content parts with a defined type. For system messages, only type `text` is supported."
    }).check(Schema.isMinLength(1))
  ], { mode: "oneOf" }).annotate({ "description": "The contents of the system message." }),
  "role": Schema.Literal("system").annotate({
    "description": "The role of the messages author, in this case `system`."
  }),
  "name": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "An optional name for the participant. Provides the model information to differentiate between participants of the same role."
    })
  )
}).annotate({
  "title": "System message",
  "description":
    "Developer-provided instructions that the model should follow, regardless of\nmessages sent by the user. With o1 models and newer, use `developer` messages\nfor this purpose instead.\n"
})
export type ChatCompletionRequestToolMessage = {
  readonly "role": "tool"
  readonly "content": string | ReadonlyArray<ChatCompletionRequestToolMessageContentPart>
  readonly "tool_call_id": string
}
export const ChatCompletionRequestToolMessage = Schema.Struct({
  "role": Schema.Literal("tool").annotate({ "description": "The role of the messages author, in this case `tool`." }),
  "content": Schema.Union([
    Schema.String.annotate({ "title": "Text content", "description": "The contents of the tool message." }),
    Schema.Array(ChatCompletionRequestToolMessageContentPart).annotate({
      "title": "Array of content parts",
      "description": "An array of content parts with a defined type. For tool messages, only type `text` is supported."
    }).check(Schema.isMinLength(1))
  ], { mode: "oneOf" }).annotate({ "description": "The contents of the tool message." }),
  "tool_call_id": Schema.String.annotate({ "description": "Tool call that this message is responding to." })
}).annotate({ "title": "Tool message" })
export type ChatCompletionRequestUserMessage = {
  readonly "content": string | ReadonlyArray<ChatCompletionRequestUserMessageContentPart>
  readonly "role": "user"
  readonly "name"?: string
}
export const ChatCompletionRequestUserMessage = Schema.Struct({
  "content": Schema.Union([
    Schema.String.annotate({ "title": "Text content", "description": "The text contents of the message." }),
    Schema.Array(ChatCompletionRequestUserMessageContentPart).annotate({
      "title": "Array of content parts",
      "description":
        "An array of content parts with a defined type. Supported options differ based on the [model](/docs/models) being used to generate the response. Can contain text, image, or audio inputs."
    }).check(Schema.isMinLength(1))
  ], { mode: "oneOf" }).annotate({ "description": "The contents of the user message.\n" }),
  "role": Schema.Literal("user").annotate({ "description": "The role of the messages author, in this case `user`." }),
  "name": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "An optional name for the participant. Provides the model information to differentiate between participants of the same role."
    })
  )
}).annotate({
  "title": "User message",
  "description": "Messages sent by an end user, containing prompts or additional context\ninformation.\n"
})
export type VectorStoreSearchRequest = {
  readonly "query": string | ReadonlyArray<string>
  readonly "rewrite_query"?: boolean
  readonly "max_num_results"?: number
  readonly "filters"?: ComparisonFilter | CompoundFilter
  readonly "ranking_options"?: {
    readonly "ranker"?: "none" | "auto" | "default-2024-11-15"
    readonly "score_threshold"?: number
  }
}
export const VectorStoreSearchRequest = Schema.Struct({
  "query": Schema.Union([
    Schema.String,
    Schema.Array(Schema.String.annotate({ "description": "A list of queries to search for." }))
  ], { mode: "oneOf" }).annotate({ "description": "A query string for a search" }),
  "rewrite_query": Schema.optionalKey(
    Schema.Boolean.annotate({ "description": "Whether to rewrite the natural language query for vector search." })
  ),
  "max_num_results": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "The maximum number of results to return. This number should be between 1 and 50 inclusive."
    }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(Schema.isLessThanOrEqualTo(50))
  ),
  "filters": Schema.optionalKey(
    Schema.Union([ComparisonFilter, CompoundFilter], { mode: "oneOf" }).annotate({
      "description": "A filter to apply based on file attributes."
    })
  ),
  "ranking_options": Schema.optionalKey(
    Schema.Struct({
      "ranker": Schema.optionalKey(
        Schema.Literals(["none", "auto", "default-2024-11-15"]).annotate({
          "description": "Enable re-ranking; set to `none` to disable, which can help reduce latency."
        })
      ),
      "score_threshold": Schema.optionalKey(
        Schema.Number.check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(
          Schema.isLessThanOrEqualTo(1)
        )
      )
    }).annotate({ "description": "Ranking options for search." })
  )
})
export type FileSearchTool = {
  readonly "type": "file_search"
  readonly "vector_store_ids": ReadonlyArray<string>
  readonly "max_num_results"?: number
  readonly "ranking_options"?: {
    readonly "ranker"?: "auto" | "default-2024-11-15"
    readonly "score_threshold"?: number
    readonly "hybrid_search"?: { readonly "embedding_weight": number; readonly "text_weight": number }
  }
  readonly "filters"?: ComparisonFilter | CompoundFilter | null
}
export const FileSearchTool = Schema.Struct({
  "type": Schema.Literal("file_search").annotate({
    "description": "The type of the file search tool. Always `file_search`."
  }),
  "vector_store_ids": Schema.Array(Schema.String).annotate({
    "description": "The IDs of the vector stores to search."
  }),
  "max_num_results": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "The maximum number of results to return. This number should be between 1 and 50 inclusive."
    }).check(Schema.isInt())
  ),
  "ranking_options": Schema.optionalKey(
    Schema.Struct({
      "ranker": Schema.optionalKey(
        Schema.Literals(["auto", "default-2024-11-15"]).annotate({
          "description": "The ranker to use for the file search."
        })
      ),
      "score_threshold": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "The score threshold for the file search, a number between 0 and 1. Numbers closer to 1 will attempt to return only the most relevant results, but may return fewer results."
        }).check(Schema.isFinite())
      ),
      "hybrid_search": Schema.optionalKey(
        Schema.Struct({
          "embedding_weight": Schema.Number.annotate({
            "description": "The weight of the embedding in the reciprocal ranking fusion."
          }).check(Schema.isFinite()),
          "text_weight": Schema.Number.annotate({
            "description": "The weight of the text in the reciprocal ranking fusion."
          }).check(Schema.isFinite())
        }).annotate({
          "description":
            "Weights that control how reciprocal rank fusion balances semantic embedding matches versus sparse keyword matches when hybrid search is enabled."
        })
      )
    }).annotate({ "description": "Ranking options for search." })
  ),
  "filters": Schema.optionalKey(
    Schema.Union([
      Schema.Union([ComparisonFilter, CompoundFilter]).annotate({ "description": "A filter to apply." }),
      Schema.Null
    ])
  )
}).annotate({
  "title": "File search",
  "description":
    "A tool that searches for relevant content from uploaded files. Learn more about the [file search tool](https://platform.openai.com/docs/guides/tools-file-search)."
})
export type EvalRunOutputItemList = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<EvalRunOutputItem>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const EvalRunOutputItemList = Schema.Struct({
  "object": Schema.Literal("list").annotate({
    "description": "The type of this object. It is always set to \"list\".\n"
  }),
  "data": Schema.Array(EvalRunOutputItem).annotate({ "description": "An array of eval run output item objects.\n" }),
  "first_id": Schema.String.annotate({
    "description": "The identifier of the first eval run output item in the data array."
  }),
  "last_id": Schema.String.annotate({
    "description": "The identifier of the last eval run output item in the data array."
  }),
  "has_more": Schema.Boolean.annotate({
    "description": "Indicates whether there are more eval run output items available."
  })
}).annotate({
  "title": "EvalRunOutputItemList",
  "description": "An object representing a list of output items for an evaluation run.\n"
})
export type AssistantToolsFileSearch = {
  readonly "type": "file_search"
  readonly "file_search"?: {
    readonly "max_num_results"?: number
    readonly "ranking_options"?: FileSearchRankingOptions
  }
}
export const AssistantToolsFileSearch = Schema.Struct({
  "type": Schema.Literal("file_search").annotate({ "description": "The type of tool being defined: `file_search`" }),
  "file_search": Schema.optionalKey(
    Schema.Struct({
      "max_num_results": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "The maximum number of results the file search tool should output. The default is 20 for `gpt-4*` models and 5 for `gpt-3.5-turbo`. This number should be between 1 and 50 inclusive.\n\nNote that the file search tool may output fewer than `max_num_results` results. See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.\n"
        }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(Schema.isLessThanOrEqualTo(50))
      ),
      "ranking_options": Schema.optionalKey(FileSearchRankingOptions)
    }).annotate({ "description": "Overrides for the file search tool." })
  )
}).annotate({ "title": "FileSearch tool" })
export type RunStepDetailsToolCallsFileSearchObject = {
  readonly "id": string
  readonly "type": "file_search"
  readonly "file_search": {
    readonly "ranking_options"?: RunStepDetailsToolCallsFileSearchRankingOptionsObject
    readonly "results"?: ReadonlyArray<RunStepDetailsToolCallsFileSearchResultObject>
  }
}
export const RunStepDetailsToolCallsFileSearchObject = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The ID of the tool call object." }),
  "type": Schema.Literal("file_search").annotate({
    "description": "The type of tool call. This is always going to be `file_search` for this type of tool call."
  }),
  "file_search": Schema.Struct({
    "ranking_options": Schema.optionalKey(RunStepDetailsToolCallsFileSearchRankingOptionsObject),
    "results": Schema.optionalKey(
      Schema.Array(RunStepDetailsToolCallsFileSearchResultObject).annotate({
        "description": "The results of the file search."
      })
    )
  }).annotate({ "description": "For now, this is always going to be an empty object." })
}).annotate({ "title": "File search tool call" })
export type AssistantToolsFunction = { readonly "type": "function"; readonly "function": FunctionObject }
export const AssistantToolsFunction = Schema.Struct({
  "type": Schema.Literal("function").annotate({ "description": "The type of tool being defined: `function`" }),
  "function": FunctionObject
}).annotate({ "title": "Function tool" })
export type ChatCompletionTool = { readonly "type": "function"; readonly "function": FunctionObject }
export const ChatCompletionTool = Schema.Struct({
  "type": Schema.Literal("function").annotate({
    "description": "The type of the tool. Currently, only `function` is supported."
  }),
  "function": FunctionObject
}).annotate({ "title": "Function tool", "description": "A function tool that can be used to generate a response.\n" })
export type ImageEditStreamEvent = ImageEditPartialImageEvent | ImageEditCompletedEvent
export const ImageEditStreamEvent = Schema.Union([ImageEditPartialImageEvent, ImageEditCompletedEvent])
export type ImageGenStreamEvent = ImageGenPartialImageEvent | ImageGenCompletedEvent
export const ImageGenStreamEvent = Schema.Union([ImageGenPartialImageEvent, ImageGenCompletedEvent])
export type MessageObject = {
  readonly "id": string
  readonly "object": "thread.message"
  readonly "created_at": number
  readonly "thread_id": string
  readonly "status": "in_progress" | "incomplete" | "completed"
  readonly "incomplete_details": {
    readonly "reason": "content_filter" | "max_tokens" | "run_cancelled" | "run_expired" | "run_failed"
  } | null
  readonly "completed_at": number | null
  readonly "incomplete_at": number | null
  readonly "role": "user" | "assistant"
  readonly "content": ReadonlyArray<
    | MessageContentImageFileObject
    | MessageContentImageUrlObject
    | MessageContentTextObject
    | MessageContentRefusalObject
  >
  readonly "assistant_id": string | null
  readonly "run_id": string | null
  readonly "attachments":
    | ReadonlyArray<
      {
        readonly "file_id"?: string
        readonly "tools"?: ReadonlyArray<AssistantToolsCode | AssistantToolsFileSearchTypeOnly>
      }
    >
    | null
  readonly "metadata": Metadata
}
export const MessageObject = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints." }),
  "object": Schema.Literal("thread.message").annotate({
    "description": "The object type, which is always `thread.message`."
  }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the message was created."
  }).check(Schema.isInt()),
  "thread_id": Schema.String.annotate({
    "description": "The [thread](/docs/api-reference/threads) ID that this message belongs to."
  }),
  "status": Schema.Literals(["in_progress", "incomplete", "completed"]).annotate({
    "description": "The status of the message, which can be either `in_progress`, `incomplete`, or `completed`."
  }),
  "incomplete_details": Schema.Union([
    Schema.Struct({
      "reason": Schema.Literals(["content_filter", "max_tokens", "run_cancelled", "run_expired", "run_failed"])
        .annotate({ "description": "The reason the message is incomplete." })
    }).annotate({ "description": "On an incomplete message, details about why the message is incomplete." }),
    Schema.Null
  ]),
  "completed_at": Schema.Union([
    Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the message was completed." })
      .check(Schema.isInt()),
    Schema.Null
  ]),
  "incomplete_at": Schema.Union([
    Schema.Number.annotate({
      "description": "The Unix timestamp (in seconds) for when the message was marked as incomplete."
    }).check(Schema.isInt()),
    Schema.Null
  ]),
  "role": Schema.Literals(["user", "assistant"]).annotate({
    "description": "The entity that produced the message. One of `user` or `assistant`."
  }),
  "content": Schema.Array(
    Schema.Union([
      MessageContentImageFileObject,
      MessageContentImageUrlObject,
      MessageContentTextObject,
      MessageContentRefusalObject
    ], { mode: "oneOf" })
  ).annotate({ "description": "The content of the message in array of text and/or images." }),
  "assistant_id": Schema.Union([
    Schema.String.annotate({
      "description":
        "If applicable, the ID of the [assistant](/docs/api-reference/assistants) that authored this message."
    }),
    Schema.Null
  ]),
  "run_id": Schema.Union([
    Schema.String.annotate({
      "description":
        "The ID of the [run](/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints."
    }),
    Schema.Null
  ]),
  "attachments": Schema.Union([
    Schema.Array(Schema.Struct({
      "file_id": Schema.optionalKey(
        Schema.String.annotate({ "description": "The ID of the file to attach to the message." })
      ),
      "tools": Schema.optionalKey(
        Schema.Array(Schema.Union([AssistantToolsCode, AssistantToolsFileSearchTypeOnly], { mode: "oneOf" })).annotate({
          "description": "The tools to add this file to."
        })
      )
    })).annotate({ "description": "A list of files attached to the message, and the tools they were added to." }),
    Schema.Null
  ]),
  "metadata": Metadata
}).annotate({
  "title": "The message object",
  "description": "Represents a message within a [thread](/docs/api-reference/threads)."
})
export type MessageDeltaObject = {
  readonly "id": string
  readonly "object": "thread.message.delta"
  readonly "delta": {
    readonly "role"?: "user" | "assistant"
    readonly "content"?: ReadonlyArray<
      | MessageDeltaContentImageFileObject
      | MessageDeltaContentTextObject
      | MessageDeltaContentRefusalObject
      | MessageDeltaContentImageUrlObject
    >
  }
}
export const MessageDeltaObject = Schema.Struct({
  "id": Schema.String.annotate({
    "description": "The identifier of the message, which can be referenced in API endpoints."
  }),
  "object": Schema.Literal("thread.message.delta").annotate({
    "description": "The object type, which is always `thread.message.delta`."
  }),
  "delta": Schema.Struct({
    "role": Schema.optionalKey(
      Schema.Literals(["user", "assistant"]).annotate({
        "description": "The entity that produced the message. One of `user` or `assistant`."
      })
    ),
    "content": Schema.optionalKey(
      Schema.Array(
        Schema.Union([
          MessageDeltaContentImageFileObject,
          MessageDeltaContentTextObject,
          MessageDeltaContentRefusalObject,
          MessageDeltaContentImageUrlObject
        ], { mode: "oneOf" })
      ).annotate({ "description": "The content of the message in array of text and/or images." })
    )
  }).annotate({ "description": "The delta containing the fields that have changed on the Message." })
}).annotate({
  "title": "Message delta object",
  "description": "Represents a message delta i.e. any changed fields on a message during streaming.\n"
})
export type ListBatchesResponse = {
  readonly "data": ReadonlyArray<Batch>
  readonly "first_id"?: string
  readonly "last_id"?: string
  readonly "has_more": boolean
  readonly "object": "list"
}
export const ListBatchesResponse = Schema.Struct({
  "data": Schema.Array(Batch),
  "first_id": Schema.optionalKey(Schema.String),
  "last_id": Schema.optionalKey(Schema.String),
  "has_more": Schema.Boolean,
  "object": Schema.Literal("list")
})
export type CreateThreadRequest = {
  readonly "messages"?: ReadonlyArray<CreateMessageRequest>
  readonly "tool_resources"?: {
    readonly "code_interpreter"?: { readonly "file_ids"?: ReadonlyArray<string> }
    readonly "file_search"?: { readonly "vector_store_ids": unknown; readonly [x: string]: unknown } | {
      readonly "vector_stores": unknown
      readonly [x: string]: unknown
    }
  } | null
  readonly "metadata"?: Metadata
}
export const CreateThreadRequest = Schema.Struct({
  "messages": Schema.optionalKey(
    Schema.Array(CreateMessageRequest).annotate({
      "description": "A list of [messages](/docs/api-reference/messages) to start the thread with."
    })
  ),
  "tool_resources": Schema.optionalKey(Schema.Union([
    Schema.Struct({
      "code_interpreter": Schema.optionalKey(Schema.Struct({
        "file_ids": Schema.optionalKey(
          Schema.Array(Schema.String).annotate({
            "description":
              "A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"
          }).check(Schema.isMaxLength(20))
        )
      })),
      "file_search": Schema.optionalKey(
        Schema.Union([
          Schema.StructWithRest(Schema.Struct({ "vector_store_ids": Schema.Unknown }), [
            Schema.Record(Schema.String, Schema.Json)
          ]),
          Schema.StructWithRest(Schema.Struct({ "vector_stores": Schema.Unknown }), [
            Schema.Record(Schema.String, Schema.Json)
          ])
        ], { mode: "oneOf" })
      )
    }).annotate({
      "description":
        "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"
    }),
    Schema.Null
  ])),
  "metadata": Schema.optionalKey(Metadata)
}).annotate({
  "description":
    "Options to create a new thread. If no thread is provided when running a\nrequest, an empty thread will be created.\n"
})
export type ThreadStreamEvent = {
  readonly "enabled"?: boolean
  readonly "event": "thread.created"
  readonly "data": ThreadObject
}
export const ThreadStreamEvent = Schema.Union([
  Schema.Struct({
    "enabled": Schema.optionalKey(
      Schema.Boolean.annotate({ "description": "Whether to enable input audio transcription." })
    ),
    "event": Schema.Literal("thread.created"),
    "data": ThreadObject
  }).annotate({ "description": "Occurs when a new [thread](/docs/api-reference/threads/object) is created." })
], { mode: "oneOf" })
export type ModelIdsCompaction = ModelIdsResponses | string | null
export const ModelIdsCompaction = Schema.Union([ModelIdsResponses, Schema.String, Schema.Null]).annotate({
  "description":
    "Model ID used to generate the response, like `gpt-5` or `o3`. OpenAI offers a wide range of models with different capabilities, performance characteristics, and price points. Refer to the [model guide](/docs/models) to browse and compare available models."
})
export type ProjectApiKeyListResponse = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<ProjectApiKey>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const ProjectApiKeyListResponse = Schema.Struct({
  "object": Schema.Literal("list"),
  "data": Schema.Array(ProjectApiKey),
  "first_id": Schema.String,
  "last_id": Schema.String,
  "has_more": Schema.Boolean
})
export type RealtimeConversationItem =
  | RealtimeConversationItemMessageSystem
  | RealtimeConversationItemMessageUser
  | RealtimeConversationItemMessageAssistant
  | RealtimeConversationItemFunctionCall
  | RealtimeConversationItemFunctionCallOutput
  | RealtimeMCPApprovalResponse
  | RealtimeMCPListTools
  | RealtimeMCPToolCall
  | RealtimeMCPApprovalRequest
export const RealtimeConversationItem = Schema.Union([
  RealtimeConversationItemMessageSystem,
  RealtimeConversationItemMessageUser,
  RealtimeConversationItemMessageAssistant,
  RealtimeConversationItemFunctionCall,
  RealtimeConversationItemFunctionCallOutput,
  RealtimeMCPApprovalResponse,
  RealtimeMCPListTools,
  RealtimeMCPToolCall,
  RealtimeMCPApprovalRequest
]).annotate({ "description": "A single item within a Realtime conversation." })
export type AssistantsApiResponseFormatOption =
  | "auto"
  | ResponseFormatText
  | ResponseFormatJsonObject
  | ResponseFormatJsonSchema
export const AssistantsApiResponseFormatOption = Schema.Union([
  Schema.Literal("auto").annotate({ "description": "`auto` is the default value\n" }),
  ResponseFormatText,
  ResponseFormatJsonObject,
  ResponseFormatJsonSchema
], { mode: "oneOf" }).annotate({
  "description":
    "Specifies the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.\n\nSetting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).\n\nSetting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the message the model generates is valid JSON.\n\n**Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly \"stuck\" request. Also note that the message content may be partially cut off if `finish_reason=\"length\"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.\n"
})
export type TextResponseFormatConfiguration =
  | ResponseFormatText
  | TextResponseFormatJsonSchema
  | ResponseFormatJsonObject
export const TextResponseFormatConfiguration = Schema.Union([
  ResponseFormatText,
  TextResponseFormatJsonSchema,
  ResponseFormatJsonObject
], { mode: "oneOf" }).annotate({
  "description":
    "An object specifying the format that the model must output.\n\nConfiguring `{ \"type\": \"json_schema\" }` enables Structured Outputs, \nwhich ensures the model will match your supplied JSON schema. Learn more in the \n[Structured Outputs guide](/docs/guides/structured-outputs).\n\nThe default format is `{ \"type\": \"text\" }` with no additional options.\n\n**Not recommended for gpt-4o and newer models:**\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n"
})
export type RealtimeCallCreateRequest = {
  readonly "sdp": string
  readonly "session"?: {
    readonly "type": "realtime"
    readonly "output_modalities"?: ReadonlyArray<"text" | "audio">
    readonly "model"?:
      | string
      | "gpt-realtime"
      | "gpt-realtime-1.5"
      | "gpt-realtime-2025-08-28"
      | "gpt-4o-realtime-preview"
      | "gpt-4o-realtime-preview-2024-10-01"
      | "gpt-4o-realtime-preview-2024-12-17"
      | "gpt-4o-realtime-preview-2025-06-03"
      | "gpt-4o-mini-realtime-preview"
      | "gpt-4o-mini-realtime-preview-2024-12-17"
      | "gpt-realtime-mini"
      | "gpt-realtime-mini-2025-10-06"
      | "gpt-realtime-mini-2025-12-15"
      | "gpt-audio-1.5"
      | "gpt-audio-mini"
      | "gpt-audio-mini-2025-10-06"
      | "gpt-audio-mini-2025-12-15"
    readonly "instructions"?: string
    readonly "audio"?: {
      readonly "input"?: {
        readonly "format"?: { readonly "type"?: "audio/pcm"; readonly "rate"?: 24000 } | {
          readonly "type"?: "audio/pcmu"
        } | { readonly "type"?: "audio/pcma" }
        readonly "transcription"?: {
          readonly "model"?:
            | string
            | "whisper-1"
            | "gpt-4o-mini-transcribe"
            | "gpt-4o-mini-transcribe-2025-12-15"
            | "gpt-4o-transcribe"
            | "gpt-4o-transcribe-diarize"
          readonly "language"?: string
          readonly "prompt"?: string
        }
        readonly "noise_reduction"?: { readonly "type"?: NoiseReductionType }
        readonly "turn_detection"?: RealtimeTurnDetection
      }
      readonly "output"?: {
        readonly "format"?: { readonly "type"?: "audio/pcm"; readonly "rate"?: 24000 } | {
          readonly "type"?: "audio/pcmu"
        } | { readonly "type"?: "audio/pcma" }
        readonly "voice"?:
          | string
          | "alloy"
          | "ash"
          | "ballad"
          | "coral"
          | "echo"
          | "sage"
          | "shimmer"
          | "verse"
          | "marin"
          | "cedar"
          | { readonly "id": string }
        readonly "speed"?: number
      }
    }
    readonly "include"?: ReadonlyArray<"item.input_audio_transcription.logprobs">
    readonly "tracing"?: "auto" | {
      readonly "workflow_name"?: string
      readonly "group_id"?: string
      readonly "metadata"?: {}
    } | null
    readonly "tools"?: ReadonlyArray<RealtimeFunctionTool | MCPTool>
    readonly "tool_choice"?: ToolChoiceOptions | ToolChoiceFunction | ToolChoiceMCP
    readonly "max_output_tokens"?: number | "inf"
    readonly "truncation"?: RealtimeTruncation
    readonly "prompt"?: Prompt
  }
}
export const RealtimeCallCreateRequest = Schema.Struct({
  "sdp": Schema.String.annotate({
    "description": "WebRTC Session Description Protocol (SDP) offer generated by the caller."
  }),
  "session": Schema.optionalKey(
    Schema.Struct({
      "type": Schema.Literal("realtime").annotate({
        "description": "The type of session to create. Always `realtime` for the Realtime API.\n"
      }),
      "output_modalities": Schema.optionalKey(
        Schema.Array(Schema.Literals(["text", "audio"])).annotate({
          "description":
            "The set of modalities the model can respond with. It defaults to `[\"audio\"]`, indicating\nthat the model will respond with audio plus a transcript. `[\"text\"]` can be used to make\nthe model respond with text only. It is not possible to request both `text` and `audio` at the same time.\n"
        })
      ),
      "model": Schema.optionalKey(
        Schema.Union([
          Schema.String,
          Schema.Literals([
            "gpt-realtime",
            "gpt-realtime-1.5",
            "gpt-realtime-2025-08-28",
            "gpt-4o-realtime-preview",
            "gpt-4o-realtime-preview-2024-10-01",
            "gpt-4o-realtime-preview-2024-12-17",
            "gpt-4o-realtime-preview-2025-06-03",
            "gpt-4o-mini-realtime-preview",
            "gpt-4o-mini-realtime-preview-2024-12-17",
            "gpt-realtime-mini",
            "gpt-realtime-mini-2025-10-06",
            "gpt-realtime-mini-2025-12-15",
            "gpt-audio-1.5",
            "gpt-audio-mini",
            "gpt-audio-mini-2025-10-06",
            "gpt-audio-mini-2025-12-15"
          ])
        ]).annotate({ "description": "The Realtime model used for this session.\n" })
      ),
      "instructions": Schema.optionalKey(Schema.String.annotate({
        "description":
          "The default system instructions (i.e. system message) prepended to model calls. This field allows the client to guide the model on desired responses. The model can be instructed on response content and format, (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion into your voice\", \"laugh frequently\"). The instructions are not guaranteed to be followed by the model, but they provide guidance to the model on the desired behavior.\n\nNote that the server sets default instructions which will be used if this field is not set and are visible in the `session.created` event at the start of the session.\n"
      })),
      "audio": Schema.optionalKey(
        Schema.Struct({
          "input": Schema.optionalKey(Schema.Struct({
            "format": Schema.optionalKey(
              Schema.Union([
                Schema.Struct({
                  "type": Schema.optionalKey(
                    Schema.Literal("audio/pcm").annotate({ "description": "The audio format. Always `audio/pcm`." })
                  ),
                  "rate": Schema.optionalKey(
                    Schema.Literal(24000).annotate({ "description": "The sample rate of the audio. Always `24000`." })
                  )
                }).annotate({
                  "title": "PCM audio format",
                  "description": "The PCM audio format. Only a 24kHz sample rate is supported."
                }),
                Schema.Struct({
                  "type": Schema.optionalKey(
                    Schema.Literal("audio/pcmu").annotate({ "description": "The audio format. Always `audio/pcmu`." })
                  )
                }).annotate({ "title": "PCMU audio format", "description": "The G.711 -law format." }),
                Schema.Struct({
                  "type": Schema.optionalKey(
                    Schema.Literal("audio/pcma").annotate({ "description": "The audio format. Always `audio/pcma`." })
                  )
                }).annotate({ "title": "PCMA audio format", "description": "The G.711 A-law format." })
              ]).annotate({ "description": "The format of the input audio." })
            ),
            "transcription": Schema.optionalKey(
              Schema.Struct({
                "model": Schema.optionalKey(
                  Schema.Union([
                    Schema.String,
                    Schema.Literals([
                      "whisper-1",
                      "gpt-4o-mini-transcribe",
                      "gpt-4o-mini-transcribe-2025-12-15",
                      "gpt-4o-transcribe",
                      "gpt-4o-transcribe-diarize"
                    ])
                  ]).annotate({
                    "description":
                      "The model to use for transcription. Current options are `whisper-1`, `gpt-4o-mini-transcribe`, `gpt-4o-mini-transcribe-2025-12-15`, `gpt-4o-transcribe`, and `gpt-4o-transcribe-diarize`. Use `gpt-4o-transcribe-diarize` when you need diarization with speaker labels.\n"
                  })
                ),
                "language": Schema.optionalKey(
                  Schema.String.annotate({
                    "description":
                      "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"
                  })
                ),
                "prompt": Schema.optionalKey(Schema.String.annotate({
                  "description":
                    "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models (excluding `gpt-4o-transcribe-diarize`), the prompt is a free text string, for example \"expect words related to technology\".\n"
                }))
              }).annotate({
                "description":
                  "Configuration for input audio transcription, defaults to off and can be set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs asynchronously through [the /audio/transcriptions endpoint](/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"
              })
            ),
            "noise_reduction": Schema.optionalKey(
              Schema.Struct({ "type": Schema.optionalKey(NoiseReductionType) }).annotate({
                "description":
                  "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"
              })
            ),
            "turn_detection": Schema.optionalKey(RealtimeTurnDetection)
          })),
          "output": Schema.optionalKey(Schema.Struct({
            "format": Schema.optionalKey(
              Schema.Union([
                Schema.Struct({
                  "type": Schema.optionalKey(
                    Schema.Literal("audio/pcm").annotate({ "description": "The audio format. Always `audio/pcm`." })
                  ),
                  "rate": Schema.optionalKey(
                    Schema.Literal(24000).annotate({ "description": "The sample rate of the audio. Always `24000`." })
                  )
                }).annotate({
                  "title": "PCM audio format",
                  "description": "The PCM audio format. Only a 24kHz sample rate is supported."
                }),
                Schema.Struct({
                  "type": Schema.optionalKey(
                    Schema.Literal("audio/pcmu").annotate({ "description": "The audio format. Always `audio/pcmu`." })
                  )
                }).annotate({ "title": "PCMU audio format", "description": "The G.711 -law format." }),
                Schema.Struct({
                  "type": Schema.optionalKey(
                    Schema.Literal("audio/pcma").annotate({ "description": "The audio format. Always `audio/pcma`." })
                  )
                }).annotate({ "title": "PCMA audio format", "description": "The G.711 A-law format." })
              ]).annotate({ "description": "The format of the output audio." })
            ),
            "voice": Schema.optionalKey(
              Schema.Union([
                Schema.Union([
                  Schema.String,
                  Schema.Literals([
                    "alloy",
                    "ash",
                    "ballad",
                    "coral",
                    "echo",
                    "sage",
                    "shimmer",
                    "verse",
                    "marin",
                    "cedar"
                  ])
                ]),
                Schema.Struct({
                  "id": Schema.String.annotate({ "description": "The custom voice ID, e.g. `voice_1234`." })
                }).annotate({ "description": "Custom voice reference." })
              ]).annotate({
                "title": "Voice",
                "description":
                  "The voice the model uses to respond. Supported built-in voices are\n`alloy`, `ash`, `ballad`, `coral`, `echo`, `sage`, `shimmer`, `verse`,\n`marin`, and `cedar`. You may also provide a custom voice object with\nan `id`, for example `{ \"id\": \"voice_1234\" }`. Voice cannot be changed\nduring the session once the model has responded with audio at least once.\nWe recommend `marin` and `cedar` for best quality.\n"
              })
            ),
            "speed": Schema.optionalKey(
              Schema.Number.annotate({
                "description":
                  "The speed of the model's spoken response as a multiple of the original speed.\n1.0 is the default speed. 0.25 is the minimum speed. 1.5 is the maximum speed. This value can only be changed in between model turns, not while a response is in progress.\n\nThis parameter is a post-processing adjustment to the audio after it is generated, it's\nalso possible to prompt the model to speak faster or slower.\n"
              }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0.25)).check(
                Schema.isLessThanOrEqualTo(1.5)
              )
            )
          }))
        }).annotate({ "description": "Configuration for input and output audio.\n" })
      ),
      "include": Schema.optionalKey(
        Schema.Array(Schema.Literal("item.input_audio_transcription.logprobs")).annotate({
          "description":
            "Additional fields to include in server outputs.\n\n`item.input_audio_transcription.logprobs`: Include logprobs for input audio transcription.\n"
        })
      ),
      "tracing": Schema.optionalKey(
        Schema.Union([
          Schema.Union([
            Schema.Literal("auto").annotate({
              "title": "auto",
              "description":
                "Enables tracing and sets default values for tracing configuration options. Always `auto`.\n"
            }),
            Schema.Struct({
              "workflow_name": Schema.optionalKey(
                Schema.String.annotate({
                  "description":
                    "The name of the workflow to attach to this trace. This is used to\nname the trace in the Traces Dashboard.\n"
                })
              ),
              "group_id": Schema.optionalKey(
                Schema.String.annotate({
                  "description":
                    "The group id to attach to this trace to enable filtering and\ngrouping in the Traces Dashboard.\n"
                })
              ),
              "metadata": Schema.optionalKey(
                Schema.Struct({}).annotate({
                  "description":
                    "The arbitrary metadata to attach to this trace to enable\nfiltering in the Traces Dashboard.\n"
                })
              )
            }).annotate({ "title": "Tracing Configuration", "description": "Granular configuration for tracing.\n" })
          ], { mode: "oneOf" }).annotate({
            "title": "Tracing Configuration",
            "description":
              "Realtime API can write session traces to the [Traces Dashboard](/logs?api=traces). Set to null to disable tracing. Once\ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the\nworkflow name, group id, and metadata.\n"
          }),
          Schema.Null
        ])
      ),
      "tools": Schema.optionalKey(
        Schema.Array(Schema.Union([RealtimeFunctionTool, MCPTool], { mode: "oneOf" })).annotate({
          "description": "Tools available to the model."
        })
      ),
      "tool_choice": Schema.optionalKey(
        Schema.Union([ToolChoiceOptions, ToolChoiceFunction, ToolChoiceMCP], { mode: "oneOf" }).annotate({
          "description":
            "How the model chooses tools. Provide one of the string modes or force a specific\nfunction/MCP tool.\n"
        })
      ),
      "max_output_tokens": Schema.optionalKey(
        Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")], { mode: "oneOf" }).annotate({
          "description":
            "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"
        })
      ),
      "truncation": Schema.optionalKey(RealtimeTruncation),
      "prompt": Schema.optionalKey(Prompt)
    }).annotate({ "title": "Realtime session configuration", "description": "Realtime session object configuration." })
  )
}).annotate({
  "title": "Realtime call creation request",
  "description":
    "Parameters required to initiate a realtime call and receive the SDP answer\nneeded to complete a WebRTC peer connection. Provide an SDP offer generated\nby your client and optionally configure the session that will answer the call."
})
export type RealtimeSession = {
  readonly "id"?: string
  readonly "object"?: "realtime.session"
  readonly "modalities"?: ReadonlyArray<"text" | "audio">
  readonly "model"?:
    | string
    | "gpt-realtime"
    | "gpt-realtime-1.5"
    | "gpt-realtime-2025-08-28"
    | "gpt-4o-realtime-preview"
    | "gpt-4o-realtime-preview-2024-10-01"
    | "gpt-4o-realtime-preview-2024-12-17"
    | "gpt-4o-realtime-preview-2025-06-03"
    | "gpt-4o-mini-realtime-preview"
    | "gpt-4o-mini-realtime-preview-2024-12-17"
    | "gpt-realtime-mini"
    | "gpt-realtime-mini-2025-10-06"
    | "gpt-realtime-mini-2025-12-15"
    | "gpt-audio-1.5"
    | "gpt-audio-mini"
    | "gpt-audio-mini-2025-10-06"
    | "gpt-audio-mini-2025-12-15"
  readonly "instructions"?: string
  readonly "voice"?:
    | string
    | "alloy"
    | "ash"
    | "ballad"
    | "coral"
    | "echo"
    | "sage"
    | "shimmer"
    | "verse"
    | "marin"
    | "cedar"
  readonly "input_audio_format"?: "pcm16" | "g711_ulaw" | "g711_alaw"
  readonly "output_audio_format"?: "pcm16" | "g711_ulaw" | "g711_alaw"
  readonly "input_audio_transcription"?: {
    readonly "model"?:
      | string
      | "whisper-1"
      | "gpt-4o-mini-transcribe"
      | "gpt-4o-mini-transcribe-2025-12-15"
      | "gpt-4o-transcribe"
      | "gpt-4o-transcribe-diarize"
    readonly "language"?: string
    readonly "prompt"?: string
  } | null
  readonly "turn_detection"?: RealtimeTurnDetection
  readonly "input_audio_noise_reduction"?: { readonly "type"?: NoiseReductionType }
  readonly "speed"?: number
  readonly "tracing"?: "auto" | {
    readonly "workflow_name"?: string
    readonly "group_id"?: string
    readonly "metadata"?: {}
  } | null
  readonly "tools"?: ReadonlyArray<RealtimeFunctionTool>
  readonly "tool_choice"?: string
  readonly "temperature"?: number
  readonly "max_response_output_tokens"?: number | "inf"
  readonly "expires_at"?: number
  readonly "prompt"?: Prompt | null
  readonly "include"?: ReadonlyArray<"item.input_audio_transcription.logprobs"> | null
}
export const RealtimeSession = Schema.Struct({
  "id": Schema.optionalKey(
    Schema.String.annotate({
      "description": "Unique identifier for the session that looks like `sess_1234567890abcdef`.\n"
    })
  ),
  "object": Schema.optionalKey(
    Schema.Literal("realtime.session").annotate({ "description": "The object type. Always `realtime.session`." })
  ),
  "modalities": Schema.optionalKey(
    Schema.Array(Schema.Literals(["text", "audio"])).annotate({
      "description": "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"
    })
  ),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.String,
      Schema.Literals([
        "gpt-realtime",
        "gpt-realtime-1.5",
        "gpt-realtime-2025-08-28",
        "gpt-4o-realtime-preview",
        "gpt-4o-realtime-preview-2024-10-01",
        "gpt-4o-realtime-preview-2024-12-17",
        "gpt-4o-realtime-preview-2025-06-03",
        "gpt-4o-mini-realtime-preview",
        "gpt-4o-mini-realtime-preview-2024-12-17",
        "gpt-realtime-mini",
        "gpt-realtime-mini-2025-10-06",
        "gpt-realtime-mini-2025-12-15",
        "gpt-audio-1.5",
        "gpt-audio-mini",
        "gpt-audio-mini-2025-10-06",
        "gpt-audio-mini-2025-12-15"
      ])
    ]).annotate({ "description": "The Realtime model used for this session.\n" })
  ),
  "instructions": Schema.optionalKey(Schema.String.annotate({
    "description":
      "The default system instructions (i.e. system message) prepended to model\ncalls. This field allows the client to guide the model on desired\nresponses. The model can be instructed on response content and format,\n(e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good\nresponses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion\ninto your voice\", \"laugh frequently\"). The instructions are not\nguaranteed to be followed by the model, but they provide guidance to the\nmodel on the desired behavior.\n\n\nNote that the server sets default instructions which will be used if this\nfield is not set and are visible in the `session.created` event at the\nstart of the session.\n"
  })),
  "voice": Schema.optionalKey(
    Schema.Union([
      Schema.String,
      Schema.Literals(["alloy", "ash", "ballad", "coral", "echo", "sage", "shimmer", "verse", "marin", "cedar"])
    ]).annotate({
      "description":
        "The voice the model uses to respond. Voice cannot be changed during the\nsession once the model has responded with audio at least once. Current\nvoice options are `alloy`, `ash`, `ballad`, `coral`, `echo`, `sage`,\n`shimmer`, and `verse`.\n"
    })
  ),
  "input_audio_format": Schema.optionalKey(
    Schema.Literals(["pcm16", "g711_ulaw", "g711_alaw"]).annotate({
      "description":
        "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate,\nsingle channel (mono), and little-endian byte order.\n"
    })
  ),
  "output_audio_format": Schema.optionalKey(
    Schema.Literals(["pcm16", "g711_ulaw", "g711_alaw"]).annotate({
      "description":
        "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, output audio is sampled at a rate of 24kHz.\n"
    })
  ),
  "input_audio_transcription": Schema.optionalKey(Schema.Union([
    Schema.Struct({
      "model": Schema.optionalKey(
        Schema.Union([
          Schema.String,
          Schema.Literals([
            "whisper-1",
            "gpt-4o-mini-transcribe",
            "gpt-4o-mini-transcribe-2025-12-15",
            "gpt-4o-transcribe",
            "gpt-4o-transcribe-diarize"
          ])
        ]).annotate({
          "description":
            "The model to use for transcription. Current options are `whisper-1`, `gpt-4o-mini-transcribe`, `gpt-4o-mini-transcribe-2025-12-15`, `gpt-4o-transcribe`, and `gpt-4o-transcribe-diarize`. Use `gpt-4o-transcribe-diarize` when you need diarization with speaker labels.\n"
        })
      ),
      "language": Schema.optionalKey(
        Schema.String.annotate({
          "description":
            "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"
        })
      ),
      "prompt": Schema.optionalKey(Schema.String.annotate({
        "description":
          "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models (excluding `gpt-4o-transcribe-diarize`), the prompt is a free text string, for example \"expect words related to technology\".\n"
      }))
    }).annotate({
      "description":
        "Configuration for input audio transcription, defaults to off and can be set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"
    }),
    Schema.Null
  ])),
  "turn_detection": Schema.optionalKey(RealtimeTurnDetection),
  "input_audio_noise_reduction": Schema.optionalKey(
    Schema.Struct({ "type": Schema.optionalKey(NoiseReductionType) }).annotate({
      "description":
        "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"
    })
  ),
  "speed": Schema.optionalKey(
    Schema.Number.annotate({
      "description":
        "The speed of the model's spoken response. 1.0 is the default speed. 0.25 is\nthe minimum speed. 1.5 is the maximum speed. This value can only be changed\nin between model turns, not while a response is in progress.\n"
    }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0.25)).check(Schema.isLessThanOrEqualTo(1.5))
  ),
  "tracing": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        Schema.Literal("auto").annotate({ "description": "Default tracing mode for the session.\n" }),
        Schema.Struct({
          "workflow_name": Schema.optionalKey(
            Schema.String.annotate({
              "description":
                "The name of the workflow to attach to this trace. This is used to\nname the trace in the traces dashboard.\n"
            })
          ),
          "group_id": Schema.optionalKey(
            Schema.String.annotate({
              "description":
                "The group id to attach to this trace to enable filtering and\ngrouping in the traces dashboard.\n"
            })
          ),
          "metadata": Schema.optionalKey(
            Schema.Struct({}).annotate({
              "description":
                "The arbitrary metadata to attach to this trace to enable\nfiltering in the traces dashboard.\n"
            })
          )
        }).annotate({ "title": "Tracing Configuration", "description": "Granular configuration for tracing.\n" })
      ], { mode: "oneOf" }).annotate({
        "title": "Tracing Configuration",
        "description":
          "Configuration options for tracing. Set to null to disable tracing. Once\ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the\nworkflow name, group id, and metadata.\n"
      }),
      Schema.Null
    ])
  ),
  "tools": Schema.optionalKey(
    Schema.Array(RealtimeFunctionTool).annotate({ "description": "Tools (functions) available to the model." })
  ),
  "tool_choice": Schema.optionalKey(
    Schema.String.annotate({
      "description": "How the model chooses tools. Options are `auto`, `none`, `required`, or\nspecify a function.\n"
    })
  ),
  "temperature": Schema.optionalKey(
    Schema.Number.annotate({
      "description":
        "Sampling temperature for the model, limited to [0.6, 1.2]. For audio models a temperature of 0.8 is highly recommended for best performance.\n"
    }).check(Schema.isFinite())
  ),
  "max_response_output_tokens": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")], { mode: "oneOf" }).annotate({
      "description":
        "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"
    })
  ),
  "expires_at": Schema.optionalKey(
    Schema.Number.annotate({ "description": "Expiration timestamp for the session, in seconds since epoch." }).check(
      Schema.isInt()
    )
  ),
  "prompt": Schema.optionalKey(Schema.Union([Prompt, Schema.Null])),
  "include": Schema.optionalKey(
    Schema.Union([
      Schema.Array(Schema.Literal("item.input_audio_transcription.logprobs")).annotate({
        "description":
          "Additional fields to include in server outputs.\n- `item.input_audio_transcription.logprobs`: Include logprobs for input audio transcription.\n"
      }),
      Schema.Null
    ])
  )
}).annotate({ "description": "Realtime session object for the beta interface." })
export type RealtimeSessionCreateRequest = {
  readonly "client_secret": { readonly "value": string; readonly "expires_at": number }
  readonly "modalities"?: ReadonlyArray<"text" | "audio">
  readonly "instructions"?: string
  readonly "voice"?:
    | string
    | "alloy"
    | "ash"
    | "ballad"
    | "coral"
    | "echo"
    | "sage"
    | "shimmer"
    | "verse"
    | "marin"
    | "cedar"
    | { readonly "id": string }
  readonly "input_audio_format"?: string
  readonly "output_audio_format"?: string
  readonly "input_audio_transcription"?: { readonly "model"?: string }
  readonly "speed"?: number
  readonly "tracing"?: "auto" | {
    readonly "workflow_name"?: string
    readonly "group_id"?: string
    readonly "metadata"?: {}
  }
  readonly "turn_detection"?: {
    readonly "type"?: string
    readonly "threshold"?: number
    readonly "prefix_padding_ms"?: number
    readonly "silence_duration_ms"?: number
  }
  readonly "tools"?: ReadonlyArray<
    {
      readonly "type"?: "function"
      readonly "name"?: string
      readonly "description"?: string
      readonly "parameters"?: {}
    }
  >
  readonly "tool_choice"?: string
  readonly "temperature"?: number
  readonly "max_response_output_tokens"?: number | "inf"
  readonly "truncation"?: RealtimeTruncation
  readonly "prompt"?: Prompt
}
export const RealtimeSessionCreateRequest = Schema.Struct({
  "client_secret": Schema.Struct({
    "value": Schema.String.annotate({
      "description":
        "Ephemeral key usable in client environments to authenticate connections\nto the Realtime API. Use this in client-side environments rather than\na standard API token, which should only be used server-side.\n"
    }),
    "expires_at": Schema.Number.annotate({
      "description": "Timestamp for when the token expires. Currently, all tokens expire\nafter one minute.\n"
    }).check(Schema.isInt())
  }).annotate({ "description": "Ephemeral key returned by the API." }),
  "modalities": Schema.optionalKey(
    Schema.Array(Schema.Literals(["text", "audio"])).annotate({
      "description": "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"
    })
  ),
  "instructions": Schema.optionalKey(Schema.String.annotate({
    "description":
      "The default system instructions (i.e. system message) prepended to model calls. This field allows the client to guide the model on desired responses. The model can be instructed on response content and format, (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion into your voice\", \"laugh frequently\"). The instructions are not guaranteed to be followed by the model, but they provide guidance to the model on the desired behavior.\nNote that the server sets default instructions which will be used if this field is not set and are visible in the `session.created` event at the start of the session.\n"
  })),
  "voice": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        Schema.String,
        Schema.Literals(["alloy", "ash", "ballad", "coral", "echo", "sage", "shimmer", "verse", "marin", "cedar"])
      ]),
      Schema.Struct({ "id": Schema.String.annotate({ "description": "The custom voice ID, e.g. `voice_1234`." }) })
        .annotate({ "description": "Custom voice reference." })
    ]).annotate({
      "title": "Voice",
      "description":
        "The voice the model uses to respond. Supported built-in voices are\n`alloy`, `ash`, `ballad`, `coral`, `echo`, `sage`, `shimmer`, `verse`,\n`marin`, and `cedar`. You may also provide a custom voice object with an\n`id`, for example `{ \"id\": \"voice_1234\" }`. Voice cannot be changed during\nthe session once the model has responded with audio at least once.\n"
    })
  ),
  "input_audio_format": Schema.optionalKey(
    Schema.String.annotate({
      "description": "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"
    })
  ),
  "output_audio_format": Schema.optionalKey(
    Schema.String.annotate({
      "description": "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"
    })
  ),
  "input_audio_transcription": Schema.optionalKey(
    Schema.Struct({
      "model": Schema.optionalKey(Schema.String.annotate({ "description": "The model to use for transcription.\n" }))
    }).annotate({
      "description":
        "Configuration for input audio transcription, defaults to off and can be\nset to `null` to turn off once on. Input audio transcription is not native\nto the model, since the model consumes audio directly. Transcription runs\nasynchronously and should be treated as rough guidance\nrather than the representation understood by the model.\n"
    })
  ),
  "speed": Schema.optionalKey(
    Schema.Number.annotate({
      "description":
        "The speed of the model's spoken response. 1.0 is the default speed. 0.25 is\nthe minimum speed. 1.5 is the maximum speed. This value can only be changed\nin between model turns, not while a response is in progress.\n"
    }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0.25)).check(Schema.isLessThanOrEqualTo(1.5))
  ),
  "tracing": Schema.optionalKey(
    Schema.Union([
      Schema.Literal("auto").annotate({ "description": "Default tracing mode for the session.\n" }),
      Schema.Struct({
        "workflow_name": Schema.optionalKey(
          Schema.String.annotate({
            "description":
              "The name of the workflow to attach to this trace. This is used to\nname the trace in the traces dashboard.\n"
          })
        ),
        "group_id": Schema.optionalKey(
          Schema.String.annotate({
            "description":
              "The group id to attach to this trace to enable filtering and\ngrouping in the traces dashboard.\n"
          })
        ),
        "metadata": Schema.optionalKey(
          Schema.Struct({}).annotate({
            "description":
              "The arbitrary metadata to attach to this trace to enable\nfiltering in the traces dashboard.\n"
          })
        )
      }).annotate({ "title": "Tracing Configuration", "description": "Granular configuration for tracing.\n" })
    ], { mode: "oneOf" }).annotate({
      "title": "Tracing Configuration",
      "description":
        "Configuration options for tracing. Set to null to disable tracing. Once\ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the\nworkflow name, group id, and metadata.\n"
    })
  ),
  "turn_detection": Schema.optionalKey(
    Schema.Struct({
      "type": Schema.optionalKey(
        Schema.String.annotate({ "description": "Type of turn detection, only `server_vad` is currently supported.\n" })
      ),
      "threshold": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\nhigher threshold will require louder audio to activate the model, and\nthus might perform better in noisy environments.\n"
        }).check(Schema.isFinite())
      ),
      "prefix_padding_ms": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "Amount of audio to include before the VAD detected speech (in\nmilliseconds). Defaults to 300ms.\n"
        }).check(Schema.isInt())
      ),
      "silence_duration_ms": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "Duration of silence to detect speech stop (in milliseconds). Defaults\nto 500ms. With shorter values the model will respond more quickly,\nbut may jump in on short pauses from the user.\n"
        }).check(Schema.isInt())
      )
    }).annotate({
      "description":
        "Configuration for turn detection. Can be set to `null` to turn off. Server\nVAD means that the model will detect the start and end of speech based on\naudio volume and respond at the end of user speech.\n"
    })
  ),
  "tools": Schema.optionalKey(
    Schema.Array(Schema.Struct({
      "type": Schema.optionalKey(
        Schema.Literal("function").annotate({ "description": "The type of the tool, i.e. `function`." })
      ),
      "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the function." })),
      "description": Schema.optionalKey(
        Schema.String.annotate({
          "description":
            "The description of the function, including guidance on when and how\nto call it, and guidance about what to tell the user when calling\n(if anything).\n"
        })
      ),
      "parameters": Schema.optionalKey(
        Schema.Struct({}).annotate({ "description": "Parameters of the function in JSON Schema." })
      )
    })).annotate({ "description": "Tools (functions) available to the model." })
  ),
  "tool_choice": Schema.optionalKey(
    Schema.String.annotate({
      "description": "How the model chooses tools. Options are `auto`, `none`, `required`, or\nspecify a function.\n"
    })
  ),
  "temperature": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.\n"
    }).check(Schema.isFinite())
  ),
  "max_response_output_tokens": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")], { mode: "oneOf" }).annotate({
      "description":
        "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"
    })
  ),
  "truncation": Schema.optionalKey(RealtimeTruncation),
  "prompt": Schema.optionalKey(Prompt)
}).annotate({
  "description": "A new Realtime session configuration, with an ephemeral key. Default TTL\nfor keys is one minute.\n"
})
export type RealtimeSessionCreateRequestGA = {
  readonly "type": "realtime"
  readonly "output_modalities"?: ReadonlyArray<"text" | "audio">
  readonly "model"?:
    | string
    | "gpt-realtime"
    | "gpt-realtime-1.5"
    | "gpt-realtime-2025-08-28"
    | "gpt-4o-realtime-preview"
    | "gpt-4o-realtime-preview-2024-10-01"
    | "gpt-4o-realtime-preview-2024-12-17"
    | "gpt-4o-realtime-preview-2025-06-03"
    | "gpt-4o-mini-realtime-preview"
    | "gpt-4o-mini-realtime-preview-2024-12-17"
    | "gpt-realtime-mini"
    | "gpt-realtime-mini-2025-10-06"
    | "gpt-realtime-mini-2025-12-15"
    | "gpt-audio-1.5"
    | "gpt-audio-mini"
    | "gpt-audio-mini-2025-10-06"
    | "gpt-audio-mini-2025-12-15"
  readonly "instructions"?: string
  readonly "audio"?: {
    readonly "input"?: {
      readonly "format"?: { readonly "type"?: "audio/pcm"; readonly "rate"?: 24000 } | {
        readonly "type"?: "audio/pcmu"
      } | { readonly "type"?: "audio/pcma" }
      readonly "transcription"?: {
        readonly "model"?:
          | string
          | "whisper-1"
          | "gpt-4o-mini-transcribe"
          | "gpt-4o-mini-transcribe-2025-12-15"
          | "gpt-4o-transcribe"
          | "gpt-4o-transcribe-diarize"
        readonly "language"?: string
        readonly "prompt"?: string
      }
      readonly "noise_reduction"?: { readonly "type"?: NoiseReductionType }
      readonly "turn_detection"?: RealtimeTurnDetection
    }
    readonly "output"?: {
      readonly "format"?: { readonly "type"?: "audio/pcm"; readonly "rate"?: 24000 } | {
        readonly "type"?: "audio/pcmu"
      } | { readonly "type"?: "audio/pcma" }
      readonly "voice"?:
        | string
        | "alloy"
        | "ash"
        | "ballad"
        | "coral"
        | "echo"
        | "sage"
        | "shimmer"
        | "verse"
        | "marin"
        | "cedar"
        | { readonly "id": string }
      readonly "speed"?: number
    }
  }
  readonly "include"?: ReadonlyArray<"item.input_audio_transcription.logprobs">
  readonly "tracing"?: "auto" | {
    readonly "workflow_name"?: string
    readonly "group_id"?: string
    readonly "metadata"?: {}
  } | null
  readonly "tools"?: ReadonlyArray<RealtimeFunctionTool | MCPTool>
  readonly "tool_choice"?: ToolChoiceOptions | ToolChoiceFunction | ToolChoiceMCP
  readonly "max_output_tokens"?: number | "inf"
  readonly "truncation"?: RealtimeTruncation
  readonly "prompt"?: Prompt
}
export const RealtimeSessionCreateRequestGA = Schema.Struct({
  "type": Schema.Literal("realtime").annotate({
    "description": "The type of session to create. Always `realtime` for the Realtime API.\n"
  }),
  "output_modalities": Schema.optionalKey(
    Schema.Array(Schema.Literals(["text", "audio"])).annotate({
      "description":
        "The set of modalities the model can respond with. It defaults to `[\"audio\"]`, indicating\nthat the model will respond with audio plus a transcript. `[\"text\"]` can be used to make\nthe model respond with text only. It is not possible to request both `text` and `audio` at the same time.\n"
    })
  ),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.String,
      Schema.Literals([
        "gpt-realtime",
        "gpt-realtime-1.5",
        "gpt-realtime-2025-08-28",
        "gpt-4o-realtime-preview",
        "gpt-4o-realtime-preview-2024-10-01",
        "gpt-4o-realtime-preview-2024-12-17",
        "gpt-4o-realtime-preview-2025-06-03",
        "gpt-4o-mini-realtime-preview",
        "gpt-4o-mini-realtime-preview-2024-12-17",
        "gpt-realtime-mini",
        "gpt-realtime-mini-2025-10-06",
        "gpt-realtime-mini-2025-12-15",
        "gpt-audio-1.5",
        "gpt-audio-mini",
        "gpt-audio-mini-2025-10-06",
        "gpt-audio-mini-2025-12-15"
      ])
    ]).annotate({ "description": "The Realtime model used for this session.\n" })
  ),
  "instructions": Schema.optionalKey(Schema.String.annotate({
    "description":
      "The default system instructions (i.e. system message) prepended to model calls. This field allows the client to guide the model on desired responses. The model can be instructed on response content and format, (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion into your voice\", \"laugh frequently\"). The instructions are not guaranteed to be followed by the model, but they provide guidance to the model on the desired behavior.\n\nNote that the server sets default instructions which will be used if this field is not set and are visible in the `session.created` event at the start of the session.\n"
  })),
  "audio": Schema.optionalKey(
    Schema.Struct({
      "input": Schema.optionalKey(Schema.Struct({
        "format": Schema.optionalKey(
          Schema.Union([
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcm").annotate({ "description": "The audio format. Always `audio/pcm`." })
              ),
              "rate": Schema.optionalKey(
                Schema.Literal(24000).annotate({ "description": "The sample rate of the audio. Always `24000`." })
              )
            }).annotate({
              "title": "PCM audio format",
              "description": "The PCM audio format. Only a 24kHz sample rate is supported."
            }),
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcmu").annotate({ "description": "The audio format. Always `audio/pcmu`." })
              )
            }).annotate({ "title": "PCMU audio format", "description": "The G.711 -law format." }),
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcma").annotate({ "description": "The audio format. Always `audio/pcma`." })
              )
            }).annotate({ "title": "PCMA audio format", "description": "The G.711 A-law format." })
          ]).annotate({ "description": "The format of the input audio." })
        ),
        "transcription": Schema.optionalKey(
          Schema.Struct({
            "model": Schema.optionalKey(
              Schema.Union([
                Schema.String,
                Schema.Literals([
                  "whisper-1",
                  "gpt-4o-mini-transcribe",
                  "gpt-4o-mini-transcribe-2025-12-15",
                  "gpt-4o-transcribe",
                  "gpt-4o-transcribe-diarize"
                ])
              ]).annotate({
                "description":
                  "The model to use for transcription. Current options are `whisper-1`, `gpt-4o-mini-transcribe`, `gpt-4o-mini-transcribe-2025-12-15`, `gpt-4o-transcribe`, and `gpt-4o-transcribe-diarize`. Use `gpt-4o-transcribe-diarize` when you need diarization with speaker labels.\n"
              })
            ),
            "language": Schema.optionalKey(
              Schema.String.annotate({
                "description":
                  "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"
              })
            ),
            "prompt": Schema.optionalKey(Schema.String.annotate({
              "description":
                "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models (excluding `gpt-4o-transcribe-diarize`), the prompt is a free text string, for example \"expect words related to technology\".\n"
            }))
          }).annotate({
            "description":
              "Configuration for input audio transcription, defaults to off and can be set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs asynchronously through [the /audio/transcriptions endpoint](/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"
          })
        ),
        "noise_reduction": Schema.optionalKey(
          Schema.Struct({ "type": Schema.optionalKey(NoiseReductionType) }).annotate({
            "description":
              "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"
          })
        ),
        "turn_detection": Schema.optionalKey(RealtimeTurnDetection)
      })),
      "output": Schema.optionalKey(Schema.Struct({
        "format": Schema.optionalKey(
          Schema.Union([
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcm").annotate({ "description": "The audio format. Always `audio/pcm`." })
              ),
              "rate": Schema.optionalKey(
                Schema.Literal(24000).annotate({ "description": "The sample rate of the audio. Always `24000`." })
              )
            }).annotate({
              "title": "PCM audio format",
              "description": "The PCM audio format. Only a 24kHz sample rate is supported."
            }),
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcmu").annotate({ "description": "The audio format. Always `audio/pcmu`." })
              )
            }).annotate({ "title": "PCMU audio format", "description": "The G.711 -law format." }),
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcma").annotate({ "description": "The audio format. Always `audio/pcma`." })
              )
            }).annotate({ "title": "PCMA audio format", "description": "The G.711 A-law format." })
          ]).annotate({ "description": "The format of the output audio." })
        ),
        "voice": Schema.optionalKey(
          Schema.Union([
            Schema.Union([
              Schema.String,
              Schema.Literals(["alloy", "ash", "ballad", "coral", "echo", "sage", "shimmer", "verse", "marin", "cedar"])
            ]),
            Schema.Struct({
              "id": Schema.String.annotate({ "description": "The custom voice ID, e.g. `voice_1234`." })
            }).annotate({ "description": "Custom voice reference." })
          ]).annotate({
            "title": "Voice",
            "description":
              "The voice the model uses to respond. Supported built-in voices are\n`alloy`, `ash`, `ballad`, `coral`, `echo`, `sage`, `shimmer`, `verse`,\n`marin`, and `cedar`. You may also provide a custom voice object with\nan `id`, for example `{ \"id\": \"voice_1234\" }`. Voice cannot be changed\nduring the session once the model has responded with audio at least once.\nWe recommend `marin` and `cedar` for best quality.\n"
          })
        ),
        "speed": Schema.optionalKey(
          Schema.Number.annotate({
            "description":
              "The speed of the model's spoken response as a multiple of the original speed.\n1.0 is the default speed. 0.25 is the minimum speed. 1.5 is the maximum speed. This value can only be changed in between model turns, not while a response is in progress.\n\nThis parameter is a post-processing adjustment to the audio after it is generated, it's\nalso possible to prompt the model to speak faster or slower.\n"
          }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0.25)).check(Schema.isLessThanOrEqualTo(1.5))
        )
      }))
    }).annotate({ "description": "Configuration for input and output audio.\n" })
  ),
  "include": Schema.optionalKey(
    Schema.Array(Schema.Literal("item.input_audio_transcription.logprobs")).annotate({
      "description":
        "Additional fields to include in server outputs.\n\n`item.input_audio_transcription.logprobs`: Include logprobs for input audio transcription.\n"
    })
  ),
  "tracing": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        Schema.Literal("auto").annotate({
          "title": "auto",
          "description": "Enables tracing and sets default values for tracing configuration options. Always `auto`.\n"
        }),
        Schema.Struct({
          "workflow_name": Schema.optionalKey(
            Schema.String.annotate({
              "description":
                "The name of the workflow to attach to this trace. This is used to\nname the trace in the Traces Dashboard.\n"
            })
          ),
          "group_id": Schema.optionalKey(
            Schema.String.annotate({
              "description":
                "The group id to attach to this trace to enable filtering and\ngrouping in the Traces Dashboard.\n"
            })
          ),
          "metadata": Schema.optionalKey(
            Schema.Struct({}).annotate({
              "description":
                "The arbitrary metadata to attach to this trace to enable\nfiltering in the Traces Dashboard.\n"
            })
          )
        }).annotate({ "title": "Tracing Configuration", "description": "Granular configuration for tracing.\n" })
      ], { mode: "oneOf" }).annotate({
        "title": "Tracing Configuration",
        "description":
          "Realtime API can write session traces to the [Traces Dashboard](/logs?api=traces). Set to null to disable tracing. Once\ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the\nworkflow name, group id, and metadata.\n"
      }),
      Schema.Null
    ])
  ),
  "tools": Schema.optionalKey(
    Schema.Array(Schema.Union([RealtimeFunctionTool, MCPTool], { mode: "oneOf" })).annotate({
      "description": "Tools available to the model."
    })
  ),
  "tool_choice": Schema.optionalKey(
    Schema.Union([ToolChoiceOptions, ToolChoiceFunction, ToolChoiceMCP], { mode: "oneOf" }).annotate({
      "description":
        "How the model chooses tools. Provide one of the string modes or force a specific\nfunction/MCP tool.\n"
    })
  ),
  "max_output_tokens": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")], { mode: "oneOf" }).annotate({
      "description":
        "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"
    })
  ),
  "truncation": Schema.optionalKey(RealtimeTruncation),
  "prompt": Schema.optionalKey(Prompt)
}).annotate({ "title": "Realtime session configuration", "description": "Realtime session object configuration." })
export type RealtimeSessionCreateResponseGA = {
  readonly "client_secret": { readonly "value": string; readonly "expires_at": number }
  readonly "type": "realtime"
  readonly "output_modalities"?: ReadonlyArray<"text" | "audio">
  readonly "model"?:
    | string
    | "gpt-realtime"
    | "gpt-realtime-1.5"
    | "gpt-realtime-2025-08-28"
    | "gpt-4o-realtime-preview"
    | "gpt-4o-realtime-preview-2024-10-01"
    | "gpt-4o-realtime-preview-2024-12-17"
    | "gpt-4o-realtime-preview-2025-06-03"
    | "gpt-4o-mini-realtime-preview"
    | "gpt-4o-mini-realtime-preview-2024-12-17"
    | "gpt-realtime-mini"
    | "gpt-realtime-mini-2025-10-06"
    | "gpt-realtime-mini-2025-12-15"
    | "gpt-audio-1.5"
    | "gpt-audio-mini"
    | "gpt-audio-mini-2025-10-06"
    | "gpt-audio-mini-2025-12-15"
  readonly "instructions"?: string
  readonly "audio"?: {
    readonly "input"?: {
      readonly "format"?: { readonly "type"?: "audio/pcm"; readonly "rate"?: 24000 } | {
        readonly "type"?: "audio/pcmu"
      } | { readonly "type"?: "audio/pcma" }
      readonly "transcription"?: {
        readonly "model"?:
          | string
          | "whisper-1"
          | "gpt-4o-mini-transcribe"
          | "gpt-4o-mini-transcribe-2025-12-15"
          | "gpt-4o-transcribe"
          | "gpt-4o-transcribe-diarize"
        readonly "language"?: string
        readonly "prompt"?: string
      }
      readonly "noise_reduction"?: { readonly "type"?: NoiseReductionType }
      readonly "turn_detection"?: RealtimeTurnDetection
    }
    readonly "output"?: {
      readonly "format"?: { readonly "type"?: "audio/pcm"; readonly "rate"?: 24000 } | {
        readonly "type"?: "audio/pcmu"
      } | { readonly "type"?: "audio/pcma" }
      readonly "voice"?:
        | string
        | "alloy"
        | "ash"
        | "ballad"
        | "coral"
        | "echo"
        | "sage"
        | "shimmer"
        | "verse"
        | "marin"
        | "cedar"
      readonly "speed"?: number
    }
  }
  readonly "include"?: ReadonlyArray<"item.input_audio_transcription.logprobs">
  readonly "tracing"?: "auto" | {
    readonly "workflow_name"?: string
    readonly "group_id"?: string
    readonly "metadata"?: {}
  } | null
  readonly "tools"?: ReadonlyArray<RealtimeFunctionTool | MCPTool>
  readonly "tool_choice"?: ToolChoiceOptions | ToolChoiceFunction | ToolChoiceMCP
  readonly "max_output_tokens"?: number | "inf"
  readonly "truncation"?: RealtimeTruncation
  readonly "prompt"?: Prompt
}
export const RealtimeSessionCreateResponseGA = Schema.Struct({
  "client_secret": Schema.Struct({
    "value": Schema.String.annotate({
      "description":
        "Ephemeral key usable in client environments to authenticate connections to the Realtime API. Use this in client-side environments rather than a standard API token, which should only be used server-side.\n"
    }),
    "expires_at": Schema.Number.annotate({
      "description": "Timestamp for when the token expires. Currently, all tokens expire\nafter one minute.\n"
    }).check(Schema.isInt())
  }).annotate({ "description": "Ephemeral key returned by the API." }),
  "type": Schema.Literal("realtime").annotate({
    "description": "The type of session to create. Always `realtime` for the Realtime API.\n"
  }),
  "output_modalities": Schema.optionalKey(
    Schema.Array(Schema.Literals(["text", "audio"])).annotate({
      "description":
        "The set of modalities the model can respond with. It defaults to `[\"audio\"]`, indicating\nthat the model will respond with audio plus a transcript. `[\"text\"]` can be used to make\nthe model respond with text only. It is not possible to request both `text` and `audio` at the same time.\n"
    })
  ),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.String,
      Schema.Literals([
        "gpt-realtime",
        "gpt-realtime-1.5",
        "gpt-realtime-2025-08-28",
        "gpt-4o-realtime-preview",
        "gpt-4o-realtime-preview-2024-10-01",
        "gpt-4o-realtime-preview-2024-12-17",
        "gpt-4o-realtime-preview-2025-06-03",
        "gpt-4o-mini-realtime-preview",
        "gpt-4o-mini-realtime-preview-2024-12-17",
        "gpt-realtime-mini",
        "gpt-realtime-mini-2025-10-06",
        "gpt-realtime-mini-2025-12-15",
        "gpt-audio-1.5",
        "gpt-audio-mini",
        "gpt-audio-mini-2025-10-06",
        "gpt-audio-mini-2025-12-15"
      ])
    ]).annotate({ "description": "The Realtime model used for this session.\n" })
  ),
  "instructions": Schema.optionalKey(Schema.String.annotate({
    "description":
      "The default system instructions (i.e. system message) prepended to model calls. This field allows the client to guide the model on desired responses. The model can be instructed on response content and format, (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion into your voice\", \"laugh frequently\"). The instructions are not guaranteed to be followed by the model, but they provide guidance to the model on the desired behavior.\n\nNote that the server sets default instructions which will be used if this field is not set and are visible in the `session.created` event at the start of the session.\n"
  })),
  "audio": Schema.optionalKey(
    Schema.Struct({
      "input": Schema.optionalKey(Schema.Struct({
        "format": Schema.optionalKey(
          Schema.Union([
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcm").annotate({ "description": "The audio format. Always `audio/pcm`." })
              ),
              "rate": Schema.optionalKey(
                Schema.Literal(24000).annotate({ "description": "The sample rate of the audio. Always `24000`." })
              )
            }).annotate({
              "title": "PCM audio format",
              "description": "The PCM audio format. Only a 24kHz sample rate is supported."
            }),
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcmu").annotate({ "description": "The audio format. Always `audio/pcmu`." })
              )
            }).annotate({ "title": "PCMU audio format", "description": "The G.711 -law format." }),
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcma").annotate({ "description": "The audio format. Always `audio/pcma`." })
              )
            }).annotate({ "title": "PCMA audio format", "description": "The G.711 A-law format." })
          ]).annotate({ "description": "The format of the input audio." })
        ),
        "transcription": Schema.optionalKey(
          Schema.Struct({
            "model": Schema.optionalKey(
              Schema.Union([
                Schema.String,
                Schema.Literals([
                  "whisper-1",
                  "gpt-4o-mini-transcribe",
                  "gpt-4o-mini-transcribe-2025-12-15",
                  "gpt-4o-transcribe",
                  "gpt-4o-transcribe-diarize"
                ])
              ]).annotate({
                "description":
                  "The model to use for transcription. Current options are `whisper-1`, `gpt-4o-mini-transcribe`, `gpt-4o-mini-transcribe-2025-12-15`, `gpt-4o-transcribe`, and `gpt-4o-transcribe-diarize`. Use `gpt-4o-transcribe-diarize` when you need diarization with speaker labels.\n"
              })
            ),
            "language": Schema.optionalKey(
              Schema.String.annotate({
                "description":
                  "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"
              })
            ),
            "prompt": Schema.optionalKey(Schema.String.annotate({
              "description":
                "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models (excluding `gpt-4o-transcribe-diarize`), the prompt is a free text string, for example \"expect words related to technology\".\n"
            }))
          }).annotate({
            "description":
              "Configuration for input audio transcription, defaults to off and can be set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs asynchronously through [the /audio/transcriptions endpoint](/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"
          })
        ),
        "noise_reduction": Schema.optionalKey(
          Schema.Struct({ "type": Schema.optionalKey(NoiseReductionType) }).annotate({
            "description":
              "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"
          })
        ),
        "turn_detection": Schema.optionalKey(RealtimeTurnDetection)
      })),
      "output": Schema.optionalKey(Schema.Struct({
        "format": Schema.optionalKey(
          Schema.Union([
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcm").annotate({ "description": "The audio format. Always `audio/pcm`." })
              ),
              "rate": Schema.optionalKey(
                Schema.Literal(24000).annotate({ "description": "The sample rate of the audio. Always `24000`." })
              )
            }).annotate({
              "title": "PCM audio format",
              "description": "The PCM audio format. Only a 24kHz sample rate is supported."
            }),
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcmu").annotate({ "description": "The audio format. Always `audio/pcmu`." })
              )
            }).annotate({ "title": "PCMU audio format", "description": "The G.711 -law format." }),
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcma").annotate({ "description": "The audio format. Always `audio/pcma`." })
              )
            }).annotate({ "title": "PCMA audio format", "description": "The G.711 A-law format." })
          ]).annotate({ "description": "The format of the output audio." })
        ),
        "voice": Schema.optionalKey(
          Schema.Union([
            Schema.String,
            Schema.Literals(["alloy", "ash", "ballad", "coral", "echo", "sage", "shimmer", "verse", "marin", "cedar"])
          ]).annotate({
            "description":
              "The voice the model uses to respond. Voice cannot be changed during the\nsession once the model has responded with audio at least once. Current\nvoice options are `alloy`, `ash`, `ballad`, `coral`, `echo`, `sage`,\n`shimmer`, `verse`, `marin`, and `cedar`. We recommend `marin` and `cedar` for\nbest quality.\n"
          })
        ),
        "speed": Schema.optionalKey(
          Schema.Number.annotate({
            "description":
              "The speed of the model's spoken response as a multiple of the original speed.\n1.0 is the default speed. 0.25 is the minimum speed. 1.5 is the maximum speed. This value can only be changed in between model turns, not while a response is in progress.\n\nThis parameter is a post-processing adjustment to the audio after it is generated, it's\nalso possible to prompt the model to speak faster or slower.\n"
          }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0.25)).check(Schema.isLessThanOrEqualTo(1.5))
        )
      }))
    }).annotate({ "description": "Configuration for input and output audio.\n" })
  ),
  "include": Schema.optionalKey(
    Schema.Array(Schema.Literal("item.input_audio_transcription.logprobs")).annotate({
      "description":
        "Additional fields to include in server outputs.\n\n`item.input_audio_transcription.logprobs`: Include logprobs for input audio transcription.\n"
    })
  ),
  "tracing": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        Schema.Literal("auto").annotate({
          "title": "auto",
          "description": "Enables tracing and sets default values for tracing configuration options. Always `auto`.\n"
        }),
        Schema.Struct({
          "workflow_name": Schema.optionalKey(
            Schema.String.annotate({
              "description":
                "The name of the workflow to attach to this trace. This is used to\nname the trace in the Traces Dashboard.\n"
            })
          ),
          "group_id": Schema.optionalKey(
            Schema.String.annotate({
              "description":
                "The group id to attach to this trace to enable filtering and\ngrouping in the Traces Dashboard.\n"
            })
          ),
          "metadata": Schema.optionalKey(
            Schema.Struct({}).annotate({
              "description":
                "The arbitrary metadata to attach to this trace to enable\nfiltering in the Traces Dashboard.\n"
            })
          )
        }).annotate({ "title": "Tracing Configuration", "description": "Granular configuration for tracing.\n" })
      ], { mode: "oneOf" }).annotate({
        "title": "Tracing Configuration",
        "description":
          "Realtime API can write session traces to the [Traces Dashboard](/logs?api=traces). Set to null to disable tracing. Once\ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the\nworkflow name, group id, and metadata.\n"
      }),
      Schema.Null
    ])
  ),
  "tools": Schema.optionalKey(
    Schema.Array(Schema.Union([RealtimeFunctionTool, MCPTool], { mode: "oneOf" })).annotate({
      "description": "Tools available to the model."
    })
  ),
  "tool_choice": Schema.optionalKey(
    Schema.Union([ToolChoiceOptions, ToolChoiceFunction, ToolChoiceMCP], { mode: "oneOf" }).annotate({
      "description":
        "How the model chooses tools. Provide one of the string modes or force a specific\nfunction/MCP tool.\n"
    })
  ),
  "max_output_tokens": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")], { mode: "oneOf" }).annotate({
      "description":
        "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"
    })
  ),
  "truncation": Schema.optionalKey(RealtimeTruncation),
  "prompt": Schema.optionalKey(Prompt)
}).annotate({
  "description": "A new Realtime session configuration, with an ephemeral key. Default TTL\nfor keys is one minute.\n"
})
export type RunStepDeltaStepDetailsToolCallsObject = {
  readonly "type": "tool_calls"
  readonly "tool_calls"?: ReadonlyArray<
    | RunStepDeltaStepDetailsToolCallsCodeObject
    | RunStepDeltaStepDetailsToolCallsFileSearchObject
    | RunStepDeltaStepDetailsToolCallsFunctionObject
  >
}
export const RunStepDeltaStepDetailsToolCallsObject = Schema.Struct({
  "type": Schema.Literal("tool_calls").annotate({ "description": "Always `tool_calls`." }),
  "tool_calls": Schema.optionalKey(
    Schema.Array(
      Schema.Union([
        RunStepDeltaStepDetailsToolCallsCodeObject,
        RunStepDeltaStepDetailsToolCallsFileSearchObject,
        RunStepDeltaStepDetailsToolCallsFunctionObject
      ], { mode: "oneOf" })
    ).annotate({
      "description":
        "An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.\n"
    })
  )
}).annotate({ "title": "Tool calls", "description": "Details of the tool call." })
export type ChunkingStrategyRequestParam = AutoChunkingStrategyRequestParam | StaticChunkingStrategyRequestParam
export const ChunkingStrategyRequestParam = Schema.Union([
  AutoChunkingStrategyRequestParam,
  StaticChunkingStrategyRequestParam
], { mode: "oneOf" }).annotate({
  "description": "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."
})
export type CreateVectorStoreRequest = {
  readonly "file_ids"?: ReadonlyArray<string>
  readonly "name"?: string
  readonly "description"?: string
  readonly "expires_after"?: VectorStoreExpirationAfter
  readonly "chunking_strategy"?: AutoChunkingStrategyRequestParam | StaticChunkingStrategyRequestParam
  readonly "metadata"?: Metadata
}
export const CreateVectorStoreRequest = Schema.Struct({
  "file_ids": Schema.optionalKey(
    Schema.Array(Schema.String).annotate({
      "description":
        "A list of [File](/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files."
    }).check(Schema.isMaxLength(500))
  ),
  "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the vector store." })),
  "description": Schema.optionalKey(
    Schema.String.annotate({
      "description": "A description for the vector store. Can be used to describe the vector store's purpose."
    })
  ),
  "expires_after": Schema.optionalKey(VectorStoreExpirationAfter),
  "chunking_strategy": Schema.optionalKey(
    Schema.Union([AutoChunkingStrategyRequestParam, StaticChunkingStrategyRequestParam], { mode: "oneOf" }).annotate({
      "description":
        "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy. Only applicable if `file_ids` is non-empty."
    })
  ),
  "metadata": Schema.optionalKey(Metadata)
})
export type VectorStoreFileObject = {
  readonly "id": string
  readonly "object": "vector_store.file"
  readonly "usage_bytes": number
  readonly "created_at": number
  readonly "vector_store_id": string
  readonly "status": "in_progress" | "completed" | "cancelled" | "failed"
  readonly "last_error": {
    readonly "code": "server_error" | "unsupported_file" | "invalid_file"
    readonly "message": string
  } | null
  readonly "chunking_strategy"?: StaticChunkingStrategyResponseParam | OtherChunkingStrategyResponseParam
  readonly "attributes"?: VectorStoreFileAttributes
}
export const VectorStoreFileObject = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints." }),
  "object": Schema.Literal("vector_store.file").annotate({
    "description": "The object type, which is always `vector_store.file`."
  }),
  "usage_bytes": Schema.Number.annotate({
    "description": "The total vector store usage in bytes. Note that this may be different from the original file size."
  }).check(Schema.isInt()),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the vector store file was created."
  }).check(Schema.isInt()),
  "vector_store_id": Schema.String.annotate({
    "description":
      "The ID of the [vector store](/docs/api-reference/vector-stores/object) that the [File](/docs/api-reference/files) is attached to."
  }),
  "status": Schema.Literals(["in_progress", "completed", "cancelled", "failed"]).annotate({
    "description":
      "The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use."
  }),
  "last_error": Schema.Union([
    Schema.Struct({
      "code": Schema.Literals(["server_error", "unsupported_file", "invalid_file"]).annotate({
        "description": "One of `server_error`, `unsupported_file`, or `invalid_file`."
      }),
      "message": Schema.String.annotate({ "description": "A human-readable description of the error." })
    }).annotate({
      "description": "The last error associated with this vector store file. Will be `null` if there are no errors."
    }),
    Schema.Null
  ]),
  "chunking_strategy": Schema.optionalKey(
    Schema.Union([StaticChunkingStrategyResponseParam, OtherChunkingStrategyResponseParam], { mode: "oneOf" }).annotate(
      { "description": "The strategy used to chunk the file." }
    )
  ),
  "attributes": Schema.optionalKey(VectorStoreFileAttributes)
}).annotate({ "title": "Vector store files", "description": "A list of files attached to a vector store." })
export type CreateTranscriptionResponseStreamEvent =
  | TranscriptTextSegmentEvent
  | TranscriptTextDeltaEvent
  | TranscriptTextDoneEvent
export const CreateTranscriptionResponseStreamEvent = Schema.Union([
  TranscriptTextSegmentEvent,
  TranscriptTextDeltaEvent,
  TranscriptTextDoneEvent
])
export type UsageResponse = {
  readonly "object": "page"
  readonly "data": ReadonlyArray<UsageTimeBucket>
  readonly "has_more": boolean
  readonly "next_page": string
}
export const UsageResponse = Schema.Struct({
  "object": Schema.Literal("page"),
  "data": Schema.Array(UsageTimeBucket),
  "has_more": Schema.Boolean,
  "next_page": Schema.String
})
export type ListVectorStoresResponse = {
  readonly "object": string
  readonly "data": ReadonlyArray<VectorStoreObject>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
  readonly [x: string]: unknown
}
export const ListVectorStoresResponse = Schema.StructWithRest(
  Schema.Struct({
    "object": Schema.String,
    "data": Schema.Array(VectorStoreObject),
    "first_id": Schema.String,
    "last_id": Schema.String,
    "has_more": Schema.Boolean
  }),
  [Schema.Record(Schema.String, Schema.Json)]
)
export type VectorStoreSearchResultsPage = {
  readonly "object": "vector_store.search_results.page"
  readonly "search_query": ReadonlyArray<string>
  readonly "data": ReadonlyArray<VectorStoreSearchResultItem>
  readonly "has_more": boolean
  readonly "next_page": string | null
}
export const VectorStoreSearchResultsPage = Schema.Struct({
  "object": Schema.Literal("vector_store.search_results.page").annotate({
    "description": "The object type, which is always `vector_store.search_results.page`"
  }),
  "search_query": Schema.Array(Schema.String.annotate({ "description": "The query used for this search." })),
  "data": Schema.Array(VectorStoreSearchResultItem).annotate({ "description": "The list of search result items." }),
  "has_more": Schema.Boolean.annotate({ "description": "Indicates if there are more results to fetch." }),
  "next_page": Schema.Union([
    Schema.String.annotate({ "description": "The token for the next page, if any." }),
    Schema.Null
  ])
})
export type CreateContainerBody = {
  readonly "name": string
  readonly "file_ids"?: ReadonlyArray<string>
  readonly "expires_after"?: { readonly "anchor": "last_active_at"; readonly "minutes": number }
  readonly "skills"?: ReadonlyArray<SkillReferenceParam | InlineSkillParam>
  readonly "memory_limit"?: "1g" | "4g" | "16g" | "64g"
  readonly "network_policy"?: ContainerNetworkPolicyDisabledParam | ContainerNetworkPolicyAllowlistParam
}
export const CreateContainerBody = Schema.Struct({
  "name": Schema.String.annotate({ "description": "Name of the container to create." }),
  "file_ids": Schema.optionalKey(
    Schema.Array(Schema.String).annotate({ "description": "IDs of files to copy to the container." })
  ),
  "expires_after": Schema.optionalKey(
    Schema.Struct({
      "anchor": Schema.Literal("last_active_at").annotate({
        "description": "Time anchor for the expiration time. Currently only 'last_active_at' is supported."
      }),
      "minutes": Schema.Number.check(Schema.isInt())
    }).annotate({ "description": "Container expiration time in seconds relative to the 'anchor' time." })
  ),
  "skills": Schema.optionalKey(
    Schema.Array(Schema.Union([SkillReferenceParam, InlineSkillParam], { mode: "oneOf" })).annotate({
      "description": "An optional list of skills referenced by id or inline data."
    })
  ),
  "memory_limit": Schema.optionalKey(
    Schema.Literals(["1g", "4g", "16g", "64g"]).annotate({
      "description": "Optional memory limit for the container. Defaults to \"1g\"."
    })
  ),
  "network_policy": Schema.optionalKey(
    Schema.Union([ContainerNetworkPolicyDisabledParam, ContainerNetworkPolicyAllowlistParam], { mode: "oneOf" })
      .annotate({ "description": "Network access policy for the container." })
  )
})
export type AutoCodeInterpreterToolParam = {
  readonly "type": "auto"
  readonly "file_ids"?: ReadonlyArray<string>
  readonly "memory_limit"?: "1g" | "4g" | "16g" | "64g" | null
  readonly "network_policy"?: ContainerNetworkPolicyDisabledParam | ContainerNetworkPolicyAllowlistParam
}
export const AutoCodeInterpreterToolParam = Schema.Struct({
  "type": Schema.Literal("auto").annotate({ "description": "Always `auto`." }),
  "file_ids": Schema.optionalKey(
    Schema.Array(Schema.String).annotate({
      "description": "An optional list of uploaded files to make available to your code."
    }).check(Schema.isMaxLength(50))
  ),
  "memory_limit": Schema.optionalKey(
    Schema.Union([
      Schema.Literals(["1g", "4g", "16g", "64g"]).annotate({
        "description": "The memory limit for the code interpreter container."
      }),
      Schema.Null
    ])
  ),
  "network_policy": Schema.optionalKey(
    Schema.Union([ContainerNetworkPolicyDisabledParam, ContainerNetworkPolicyAllowlistParam], { mode: "oneOf" })
      .annotate({ "description": "Network access policy for the container." })
  )
}).annotate({
  "title": "CodeInterpreterToolAuto",
  "description":
    "Configuration for a code interpreter container. Optionally specify the IDs of the files to run the code on."
})
export type ContainerAutoParam = {
  readonly "type": "container_auto"
  readonly "file_ids"?: ReadonlyArray<string>
  readonly "memory_limit"?: "1g" | "4g" | "16g" | "64g" | null
  readonly "network_policy"?: ContainerNetworkPolicyDisabledParam | ContainerNetworkPolicyAllowlistParam
  readonly "skills"?: ReadonlyArray<SkillReferenceParam | InlineSkillParam>
}
export const ContainerAutoParam = Schema.Struct({
  "type": Schema.Literal("container_auto").annotate({
    "description": "Automatically creates a container for this request"
  }),
  "file_ids": Schema.optionalKey(
    Schema.Array(Schema.String).annotate({
      "description": "An optional list of uploaded files to make available to your code."
    }).check(Schema.isMaxLength(50))
  ),
  "memory_limit": Schema.optionalKey(
    Schema.Union([
      Schema.Literals(["1g", "4g", "16g", "64g"]).annotate({ "description": "The memory limit for the container." }),
      Schema.Null
    ])
  ),
  "network_policy": Schema.optionalKey(
    Schema.Union([ContainerNetworkPolicyDisabledParam, ContainerNetworkPolicyAllowlistParam], { mode: "oneOf" })
      .annotate({ "description": "Network access policy for the container." })
  ),
  "skills": Schema.optionalKey(
    Schema.Array(Schema.Union([SkillReferenceParam, InlineSkillParam], { mode: "oneOf" })).annotate({
      "description": "An optional list of skills referenced by id or inline data."
    }).check(Schema.isMaxLength(200))
  )
})
export type EvalItemContentArray = ReadonlyArray<EvalItemContentItem>
export const EvalItemContentArray = Schema.Array(EvalItemContentItem).annotate({
  "title": "An array of Input text, Output text, Input image, and Input audio",
  "description":
    "A list of inputs, each of which may be either an input text, output text, input\nimage, or input audio object.\n"
})
export type OutputTextContent = {
  readonly "type": "output_text"
  readonly "text": string
  readonly "annotations": ReadonlyArray<Annotation>
  readonly "logprobs": ReadonlyArray<LogProb>
}
export const OutputTextContent = Schema.Struct({
  "type": Schema.Literal("output_text").annotate({
    "description": "The type of the output text. Always `output_text`."
  }),
  "text": Schema.String.annotate({ "description": "The text output from the model." }),
  "annotations": Schema.Array(Annotation).annotate({ "description": "The annotations of the text output." }),
  "logprobs": Schema.Array(LogProb)
}).annotate({ "title": "Output text", "description": "A text output from the model." })
export type CustomToolCallOutput = {
  readonly "type": "custom_tool_call_output"
  readonly "id"?: string
  readonly "call_id": string
  readonly "output": string | ReadonlyArray<FunctionAndCustomToolCallOutput>
}
export const CustomToolCallOutput = Schema.Struct({
  "type": Schema.Literal("custom_tool_call_output").annotate({
    "description": "The type of the custom tool call output. Always `custom_tool_call_output`.\n"
  }),
  "id": Schema.optionalKey(
    Schema.String.annotate({ "description": "The unique ID of the custom tool call output in the OpenAI platform.\n" })
  ),
  "call_id": Schema.String.annotate({
    "description": "The call ID, used to map this custom tool call output to a custom tool call.\n"
  }),
  "output": Schema.Union([
    Schema.String.annotate({
      "title": "string output",
      "description": "A string of the output of the custom tool call.\n"
    }),
    Schema.Array(FunctionAndCustomToolCallOutput).annotate({
      "title": "output content list",
      "description": "Text, image, or file output of the custom tool call.\n"
    })
  ], { mode: "oneOf" }).annotate({
    "description":
      "The output from the custom tool call generated by your code.\nCan be a string or an list of output content.\n"
  })
}).annotate({
  "title": "Custom tool call output",
  "description": "The output of a custom tool call from your code, being sent back to the model.\n"
})
export type FunctionToolCallOutput = {
  readonly "id"?: string
  readonly "type": "function_call_output"
  readonly "call_id": string
  readonly "output": string | ReadonlyArray<FunctionAndCustomToolCallOutput>
  readonly "status"?: "in_progress" | "completed" | "incomplete"
}
export const FunctionToolCallOutput = Schema.Struct({
  "id": Schema.optionalKey(
    Schema.String.annotate({
      "description": "The unique ID of the function tool call output. Populated when this item\nis returned via API.\n"
    })
  ),
  "type": Schema.Literal("function_call_output").annotate({
    "description": "The type of the function tool call output. Always `function_call_output`.\n"
  }),
  "call_id": Schema.String.annotate({
    "description": "The unique ID of the function tool call generated by the model.\n"
  }),
  "output": Schema.Union([
    Schema.String.annotate({
      "title": "string output",
      "description": "A string of the output of the function call.\n"
    }),
    Schema.Array(FunctionAndCustomToolCallOutput).annotate({
      "title": "output content list",
      "description": "Text, image, or file output of the function call.\n"
    })
  ], { mode: "oneOf" }).annotate({
    "description":
      "The output from the function call generated by your code.\nCan be a string or an list of output content.\n"
  }),
  "status": Schema.optionalKey(
    Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
      "description":
        "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"
    })
  )
}).annotate({ "title": "Function tool call output", "description": "The output of a function tool call.\n" })
export type FunctionToolCallOutputResource = {
  readonly "id": string
  readonly "type": "function_call_output"
  readonly "call_id": string
  readonly "output": string | ReadonlyArray<FunctionAndCustomToolCallOutput>
  readonly "status"?: "in_progress" | "completed" | "incomplete"
}
export const FunctionToolCallOutputResource = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The unique ID of the function call tool output.\n" }),
  "type": Schema.Literal("function_call_output").annotate({
    "description": "The type of the function tool call output. Always `function_call_output`.\n"
  }),
  "call_id": Schema.String.annotate({
    "description": "The unique ID of the function tool call generated by the model.\n"
  }),
  "output": Schema.Union([
    Schema.String.annotate({
      "title": "string output",
      "description": "A string of the output of the function call.\n"
    }),
    Schema.Array(FunctionAndCustomToolCallOutput).annotate({
      "title": "output content list",
      "description": "Text, image, or file output of the function call.\n"
    })
  ], { mode: "oneOf" }).annotate({
    "description":
      "The output from the function call generated by your code.\nCan be a string or an list of output content.\n"
  }),
  "status": Schema.optionalKey(
    Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
      "description":
        "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"
    })
  )
}).annotate({ "title": "Function tool call output", "description": "The output of a function tool call.\n" })
export type InputMessageContentList = ReadonlyArray<InputContent>
export const InputMessageContentList = Schema.Array(InputContent).annotate({
  "title": "Input item content list",
  "description": "A list of one or many input items to the model, containing different content \ntypes.\n"
})
export type ComputerAction =
  | ClickParam
  | DoubleClickAction
  | DragParam
  | KeyPressAction
  | MoveParam
  | ScreenshotParam
  | ScrollParam
  | TypeParam
  | WaitParam
export const ComputerAction = Schema.Union([
  ClickParam,
  DoubleClickAction,
  DragParam,
  KeyPressAction,
  MoveParam,
  ScreenshotParam,
  ScrollParam,
  TypeParam,
  WaitParam
], { mode: "oneOf" })
export type FunctionShellCallOutput = {
  readonly "type": "shell_call_output"
  readonly "id": string
  readonly "call_id": string
  readonly "status": "in_progress" | "completed" | "incomplete"
  readonly "output": ReadonlyArray<FunctionShellCallOutputContent>
  readonly "max_output_length": number | null
  readonly "created_by"?: string
}
export const FunctionShellCallOutput = Schema.Struct({
  "type": Schema.Literal("shell_call_output").annotate({
    "description": "The type of the shell call output. Always `shell_call_output`."
  }),
  "id": Schema.String.annotate({
    "description": "The unique ID of the shell call output. Populated when this item is returned via API."
  }),
  "call_id": Schema.String.annotate({ "description": "The unique ID of the shell tool call generated by the model." }),
  "status": Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
    "description": "The status of the shell call output. One of `in_progress`, `completed`, or `incomplete`."
  }),
  "output": Schema.Array(FunctionShellCallOutputContent).annotate({
    "description": "An array of shell call output contents"
  }),
  "max_output_length": Schema.Union([
    Schema.Number.annotate({
      "description":
        "The maximum length of the shell command output. This is generated by the model and should be passed back with the raw output."
    }).check(Schema.isInt()),
    Schema.Null
  ]),
  "created_by": Schema.optionalKey(
    Schema.String.annotate({ "description": "The identifier of the actor that created the item." })
  )
}).annotate({ "title": "Shell call output", "description": "The output of a shell tool call that was emitted." })
export type FunctionShellCallItemParam = {
  readonly "id"?: string | null
  readonly "call_id": string
  readonly "type": "shell_call"
  readonly "action": {
    readonly "commands": ReadonlyArray<string>
    readonly "timeout_ms"?: number | null
    readonly "max_output_length"?: number | null
  }
  readonly "status"?: "in_progress" | "completed" | "incomplete" | null
  readonly "environment"?: LocalEnvironmentParam | ContainerReferenceParam | null
}
export const FunctionShellCallItemParam = Schema.Struct({
  "id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "The unique ID of the shell tool call. Populated when this item is returned via API."
      }),
      Schema.Null
    ])
  ),
  "call_id": Schema.String.annotate({ "description": "The unique ID of the shell tool call generated by the model." })
    .check(Schema.isMinLength(1)).check(Schema.isMaxLength(64)),
  "type": Schema.Literal("shell_call").annotate({ "description": "The type of the item. Always `shell_call`." }),
  "action": Schema.Struct({
    "commands": Schema.Array(Schema.String).annotate({
      "description": "Ordered shell commands for the execution environment to run."
    }),
    "timeout_ms": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description": "Maximum wall-clock time in milliseconds to allow the shell commands to run."
        }).check(Schema.isInt()),
        Schema.Null
      ])
    ),
    "max_output_length": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description": "Maximum number of UTF-8 characters to capture from combined stdout and stderr output."
        }).check(Schema.isInt()),
        Schema.Null
      ])
    )
  }).annotate({
    "title": "Shell action",
    "description": "The shell commands and limits that describe how to run the tool call."
  }),
  "status": Schema.optionalKey(
    Schema.Union([
      Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
        "title": "Shell call status",
        "description": "The status of the shell call. One of `in_progress`, `completed`, or `incomplete`."
      }),
      Schema.Null
    ])
  ),
  "environment": Schema.optionalKey(
    Schema.Union([
      Schema.Union([LocalEnvironmentParam, ContainerReferenceParam], { mode: "oneOf" }).annotate({
        "description": "The environment to execute the shell commands in."
      }),
      Schema.Null
    ])
  )
}).annotate({
  "title": "Shell tool call",
  "description": "A tool representing a request to execute one or more shell commands."
})
export type FunctionShellCallOutputItemParam = {
  readonly "id"?: string | null
  readonly "call_id": string
  readonly "type": "shell_call_output"
  readonly "output": ReadonlyArray<FunctionShellCallOutputContentParam>
  readonly "status"?: "in_progress" | "completed" | "incomplete" | null
  readonly "max_output_length"?: number | null
}
export const FunctionShellCallOutputItemParam = Schema.Struct({
  "id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "The unique ID of the shell tool call output. Populated when this item is returned via API."
      }),
      Schema.Null
    ])
  ),
  "call_id": Schema.String.annotate({ "description": "The unique ID of the shell tool call generated by the model." })
    .check(Schema.isMinLength(1)).check(Schema.isMaxLength(64)),
  "type": Schema.Literal("shell_call_output").annotate({
    "description": "The type of the item. Always `shell_call_output`."
  }),
  "output": Schema.Array(FunctionShellCallOutputContentParam).annotate({
    "description": "Captured chunks of stdout and stderr output, along with their associated outcomes."
  }),
  "status": Schema.optionalKey(
    Schema.Union([
      Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
        "title": "Shell call status",
        "description": "The status of the shell call output."
      }),
      Schema.Null
    ])
  ),
  "max_output_length": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description": "The maximum number of UTF-8 characters captured for this shell call's combined output."
      }).check(Schema.isInt()),
      Schema.Null
    ])
  )
}).annotate({
  "title": "Shell tool call output",
  "description": "The streamed output items emitted by a shell tool call."
})
export type ImagesResponse = {
  readonly "created": number
  readonly "data"?: ReadonlyArray<Image>
  readonly "background"?: "transparent" | "opaque"
  readonly "output_format"?: "png" | "webp" | "jpeg"
  readonly "size"?: "1024x1024" | "1024x1536" | "1536x1024"
  readonly "quality"?: "low" | "medium" | "high"
  readonly "usage"?: ImageGenUsage
}
export const ImagesResponse = Schema.Struct({
  "created": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the image was created." })
    .check(Schema.isInt()),
  "data": Schema.optionalKey(Schema.Array(Image).annotate({ "description": "The list of generated images." })),
  "background": Schema.optionalKey(
    Schema.Literals(["transparent", "opaque"]).annotate({
      "description": "The background parameter used for the image generation. Either `transparent` or `opaque`."
    })
  ),
  "output_format": Schema.optionalKey(
    Schema.Literals(["png", "webp", "jpeg"]).annotate({
      "description": "The output format of the image generation. Either `png`, `webp`, or `jpeg`."
    })
  ),
  "size": Schema.optionalKey(
    Schema.Literals(["1024x1024", "1024x1536", "1536x1024"]).annotate({
      "description": "The size of the image generated. Either `1024x1024`, `1024x1536`, or `1536x1024`."
    })
  ),
  "quality": Schema.optionalKey(
    Schema.Literals(["low", "medium", "high"]).annotate({
      "description": "The quality of the image generated. Either `low`, `medium`, or `high`."
    })
  ),
  "usage": Schema.optionalKey(ImageGenUsage)
}).annotate({ "title": "Image generation response", "description": "The response from the image generation endpoint." })
export type AssistantMessageItem = {
  readonly "id": string
  readonly "object": "chatkit.thread_item"
  readonly "created_at": number
  readonly "thread_id": string
  readonly "type": "chatkit.assistant_message"
  readonly "content": ReadonlyArray<ResponseOutputText>
}
export const AssistantMessageItem = Schema.Struct({
  "id": Schema.String.annotate({ "description": "Identifier of the thread item." }),
  "object": Schema.Literal("chatkit.thread_item").annotate({
    "description": "Type discriminator that is always `chatkit.thread_item`."
  }),
  "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) for when the item was created." })
    .check(Schema.isInt()),
  "thread_id": Schema.String.annotate({ "description": "Identifier of the parent thread." }),
  "type": Schema.Literal("chatkit.assistant_message").annotate({
    "description": "Type discriminator that is always `chatkit.assistant_message`."
  }),
  "content": Schema.Array(ResponseOutputText).annotate({ "description": "Ordered assistant response segments." })
}).annotate({ "title": "Assistant message", "description": "Assistant-authored message within a thread." })
export type ThreadListResource = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<ThreadResource>
  readonly "first_id": string | null
  readonly "last_id": string | null
  readonly "has_more": boolean
}
export const ThreadListResource = Schema.Struct({
  "object": Schema.Literal("list").annotate({ "description": "The type of object returned, must be `list`." }),
  "data": Schema.Array(ThreadResource).annotate({ "description": "A list of items" }),
  "first_id": Schema.Union([
    Schema.String.annotate({ "description": "The ID of the first item in the list." }),
    Schema.Null
  ]),
  "last_id": Schema.Union([
    Schema.String.annotate({ "description": "The ID of the last item in the list." }),
    Schema.Null
  ]),
  "has_more": Schema.Boolean.annotate({ "description": "Whether there are more items available." })
}).annotate({ "title": "Threads", "description": "A paginated list of ChatKit threads." })
export type AuditLog = {
  readonly "id": string
  readonly "type": AuditLogEventType
  readonly "effective_at": number
  readonly "project"?: { readonly "id"?: string; readonly "name"?: string }
  readonly "actor": AuditLogActor
  readonly "api_key.created"?: {
    readonly "id"?: string
    readonly "data"?: { readonly "scopes"?: ReadonlyArray<string> }
  }
  readonly "api_key.updated"?: {
    readonly "id"?: string
    readonly "changes_requested"?: { readonly "scopes"?: ReadonlyArray<string> }
  }
  readonly "api_key.deleted"?: { readonly "id"?: string }
  readonly "checkpoint.permission.created"?: {
    readonly "id"?: string
    readonly "data"?: { readonly "project_id"?: string; readonly "fine_tuned_model_checkpoint"?: string }
  }
  readonly "checkpoint.permission.deleted"?: { readonly "id"?: string }
  readonly "external_key.registered"?: { readonly "id"?: string; readonly "data"?: {} }
  readonly "external_key.removed"?: { readonly "id"?: string }
  readonly "group.created"?: { readonly "id"?: string; readonly "data"?: { readonly "group_name"?: string } }
  readonly "group.updated"?: {
    readonly "id"?: string
    readonly "changes_requested"?: { readonly "group_name"?: string }
  }
  readonly "group.deleted"?: { readonly "id"?: string }
  readonly "scim.enabled"?: { readonly "id"?: string }
  readonly "scim.disabled"?: { readonly "id"?: string }
  readonly "invite.sent"?: {
    readonly "id"?: string
    readonly "data"?: { readonly "email"?: string; readonly "role"?: string }
  }
  readonly "invite.accepted"?: { readonly "id"?: string }
  readonly "invite.deleted"?: { readonly "id"?: string }
  readonly "ip_allowlist.created"?: {
    readonly "id"?: string
    readonly "name"?: string
    readonly "allowed_ips"?: ReadonlyArray<string>
  }
  readonly "ip_allowlist.updated"?: { readonly "id"?: string; readonly "allowed_ips"?: ReadonlyArray<string> }
  readonly "ip_allowlist.deleted"?: {
    readonly "id"?: string
    readonly "name"?: string
    readonly "allowed_ips"?: ReadonlyArray<string>
  }
  readonly "ip_allowlist.config.activated"?: {
    readonly "configs"?: ReadonlyArray<{ readonly "id"?: string; readonly "name"?: string }>
  }
  readonly "ip_allowlist.config.deactivated"?: {
    readonly "configs"?: ReadonlyArray<{ readonly "id"?: string; readonly "name"?: string }>
  }
  readonly "login.succeeded"?: {}
  readonly "login.failed"?: { readonly "error_code"?: string; readonly "error_message"?: string }
  readonly "logout.succeeded"?: {}
  readonly "logout.failed"?: { readonly "error_code"?: string; readonly "error_message"?: string }
  readonly "organization.updated"?: {
    readonly "id"?: string
    readonly "changes_requested"?: {
      readonly "title"?: string
      readonly "description"?: string
      readonly "name"?: string
      readonly "threads_ui_visibility"?: string
      readonly "usage_dashboard_visibility"?: string
      readonly "api_call_logging"?: string
      readonly "api_call_logging_project_ids"?: string
    }
  }
  readonly "project.created"?: {
    readonly "id"?: string
    readonly "data"?: { readonly "name"?: string; readonly "title"?: string }
  }
  readonly "project.updated"?: { readonly "id"?: string; readonly "changes_requested"?: { readonly "title"?: string } }
  readonly "project.archived"?: { readonly "id"?: string }
  readonly "project.deleted"?: { readonly "id"?: string }
  readonly "rate_limit.updated"?: {
    readonly "id"?: string
    readonly "changes_requested"?: {
      readonly "max_requests_per_1_minute"?: number
      readonly "max_tokens_per_1_minute"?: number
      readonly "max_images_per_1_minute"?: number
      readonly "max_audio_megabytes_per_1_minute"?: number
      readonly "max_requests_per_1_day"?: number
      readonly "batch_1_day_max_input_tokens"?: number
    }
  }
  readonly "rate_limit.deleted"?: { readonly "id"?: string }
  readonly "role.created"?: {
    readonly "id"?: string
    readonly "role_name"?: string
    readonly "permissions"?: ReadonlyArray<string>
    readonly "resource_type"?: string
    readonly "resource_id"?: string
  }
  readonly "role.updated"?: {
    readonly "id"?: string
    readonly "changes_requested"?: {
      readonly "role_name"?: string
      readonly "resource_id"?: string
      readonly "resource_type"?: string
      readonly "permissions_added"?: ReadonlyArray<string>
      readonly "permissions_removed"?: ReadonlyArray<string>
      readonly "description"?: string
      readonly "metadata"?: {}
    }
  }
  readonly "role.deleted"?: { readonly "id"?: string }
  readonly "role.assignment.created"?: {
    readonly "id"?: string
    readonly "principal_id"?: string
    readonly "principal_type"?: string
    readonly "resource_id"?: string
    readonly "resource_type"?: string
  }
  readonly "role.assignment.deleted"?: {
    readonly "id"?: string
    readonly "principal_id"?: string
    readonly "principal_type"?: string
    readonly "resource_id"?: string
    readonly "resource_type"?: string
  }
  readonly "service_account.created"?: { readonly "id"?: string; readonly "data"?: { readonly "role"?: string } }
  readonly "service_account.updated"?: {
    readonly "id"?: string
    readonly "changes_requested"?: { readonly "role"?: string }
  }
  readonly "service_account.deleted"?: { readonly "id"?: string }
  readonly "user.added"?: { readonly "id"?: string; readonly "data"?: { readonly "role"?: string } }
  readonly "user.updated"?: { readonly "id"?: string; readonly "changes_requested"?: { readonly "role"?: string } }
  readonly "user.deleted"?: { readonly "id"?: string }
  readonly "certificate.created"?: { readonly "id"?: string; readonly "name"?: string }
  readonly "certificate.updated"?: { readonly "id"?: string; readonly "name"?: string }
  readonly "certificate.deleted"?: { readonly "id"?: string; readonly "name"?: string; readonly "certificate"?: string }
  readonly "certificates.activated"?: {
    readonly "certificates"?: ReadonlyArray<{ readonly "id"?: string; readonly "name"?: string }>
  }
  readonly "certificates.deactivated"?: {
    readonly "certificates"?: ReadonlyArray<{ readonly "id"?: string; readonly "name"?: string }>
  }
}
export const AuditLog = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The ID of this log." }),
  "type": AuditLogEventType,
  "effective_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of the event." }).check(
    Schema.isInt()
  ),
  "project": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The project ID." })),
      "name": Schema.optionalKey(Schema.String.annotate({ "description": "The project title." }))
    }).annotate({
      "description":
        "The project that the action was scoped to. Absent for actions not scoped to projects. Note that any admin actions taken via Admin API keys are associated with the default project."
    })
  ),
  "actor": AuditLogActor,
  "api_key.created": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The tracking ID of the API key." })),
      "data": Schema.optionalKey(
        Schema.Struct({
          "scopes": Schema.optionalKey(
            Schema.Array(Schema.String).annotate({
              "description": "A list of scopes allowed for the API key, e.g. `[\"api.model.request\"]`"
            })
          )
        }).annotate({ "description": "The payload used to create the API key." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "api_key.updated": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The tracking ID of the API key." })),
      "changes_requested": Schema.optionalKey(
        Schema.Struct({
          "scopes": Schema.optionalKey(
            Schema.Array(Schema.String).annotate({
              "description": "A list of scopes allowed for the API key, e.g. `[\"api.model.request\"]`"
            })
          )
        }).annotate({ "description": "The payload used to update the API key." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "api_key.deleted": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The tracking ID of the API key." }))
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "checkpoint.permission.created": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the checkpoint permission." })),
      "data": Schema.optionalKey(
        Schema.Struct({
          "project_id": Schema.optionalKey(
            Schema.String.annotate({
              "description": "The ID of the project that the checkpoint permission was created for."
            })
          ),
          "fine_tuned_model_checkpoint": Schema.optionalKey(
            Schema.String.annotate({ "description": "The ID of the fine-tuned model checkpoint." })
          )
        }).annotate({ "description": "The payload used to create the checkpoint permission." })
      )
    }).annotate({
      "description": "The project and fine-tuned model checkpoint that the checkpoint permission was created for."
    })
  ),
  "checkpoint.permission.deleted": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the checkpoint permission." }))
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "external_key.registered": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the external key configuration." })),
      "data": Schema.optionalKey(
        Schema.Struct({}).annotate({ "description": "The configuration for the external key." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "external_key.removed": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the external key configuration." }))
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "group.created": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the group." })),
      "data": Schema.optionalKey(
        Schema.Struct({
          "group_name": Schema.optionalKey(Schema.String.annotate({ "description": "The group name." }))
        }).annotate({ "description": "Information about the created group." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "group.updated": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the group." })),
      "changes_requested": Schema.optionalKey(
        Schema.Struct({
          "group_name": Schema.optionalKey(Schema.String.annotate({ "description": "The updated group name." }))
        }).annotate({ "description": "The payload used to update the group." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "group.deleted": Schema.optionalKey(
    Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the group." })) })
      .annotate({ "description": "The details for events with this `type`." })
  ),
  "scim.enabled": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the SCIM was enabled for." }))
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "scim.disabled": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the SCIM was disabled for." }))
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "invite.sent": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the invite." })),
      "data": Schema.optionalKey(
        Schema.Struct({
          "email": Schema.optionalKey(
            Schema.String.annotate({ "description": "The email invited to the organization." })
          ),
          "role": Schema.optionalKey(
            Schema.String.annotate({
              "description": "The role the email was invited to be. Is either `owner` or `member`."
            })
          )
        }).annotate({ "description": "The payload used to create the invite." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "invite.accepted": Schema.optionalKey(
    Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the invite." })) })
      .annotate({ "description": "The details for events with this `type`." })
  ),
  "invite.deleted": Schema.optionalKey(
    Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the invite." })) })
      .annotate({ "description": "The details for events with this `type`." })
  ),
  "ip_allowlist.created": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the IP allowlist configuration." })),
      "name": Schema.optionalKey(
        Schema.String.annotate({ "description": "The name of the IP allowlist configuration." })
      ),
      "allowed_ips": Schema.optionalKey(
        Schema.Array(Schema.String).annotate({
          "description": "The IP addresses or CIDR ranges included in the configuration."
        })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "ip_allowlist.updated": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the IP allowlist configuration." })),
      "allowed_ips": Schema.optionalKey(
        Schema.Array(Schema.String).annotate({
          "description": "The updated set of IP addresses or CIDR ranges in the configuration."
        })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "ip_allowlist.deleted": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the IP allowlist configuration." })),
      "name": Schema.optionalKey(
        Schema.String.annotate({ "description": "The name of the IP allowlist configuration." })
      ),
      "allowed_ips": Schema.optionalKey(
        Schema.Array(Schema.String).annotate({
          "description": "The IP addresses or CIDR ranges that were in the configuration."
        })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "ip_allowlist.config.activated": Schema.optionalKey(
    Schema.Struct({
      "configs": Schema.optionalKey(
        Schema.Array(
          Schema.Struct({
            "id": Schema.optionalKey(
              Schema.String.annotate({ "description": "The ID of the IP allowlist configuration." })
            ),
            "name": Schema.optionalKey(
              Schema.String.annotate({ "description": "The name of the IP allowlist configuration." })
            )
          })
        ).annotate({ "description": "The configurations that were activated." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "ip_allowlist.config.deactivated": Schema.optionalKey(
    Schema.Struct({
      "configs": Schema.optionalKey(
        Schema.Array(
          Schema.Struct({
            "id": Schema.optionalKey(
              Schema.String.annotate({ "description": "The ID of the IP allowlist configuration." })
            ),
            "name": Schema.optionalKey(
              Schema.String.annotate({ "description": "The name of the IP allowlist configuration." })
            )
          })
        ).annotate({ "description": "The configurations that were deactivated." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "login.succeeded": Schema.optionalKey(
    Schema.Struct({}).annotate({
      "description": "This event has no additional fields beyond the standard audit log attributes."
    })
  ),
  "login.failed": Schema.optionalKey(
    Schema.Struct({
      "error_code": Schema.optionalKey(Schema.String.annotate({ "description": "The error code of the failure." })),
      "error_message": Schema.optionalKey(
        Schema.String.annotate({ "description": "The error message of the failure." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "logout.succeeded": Schema.optionalKey(
    Schema.Struct({}).annotate({
      "description": "This event has no additional fields beyond the standard audit log attributes."
    })
  ),
  "logout.failed": Schema.optionalKey(
    Schema.Struct({
      "error_code": Schema.optionalKey(Schema.String.annotate({ "description": "The error code of the failure." })),
      "error_message": Schema.optionalKey(
        Schema.String.annotate({ "description": "The error message of the failure." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "organization.updated": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The organization ID." })),
      "changes_requested": Schema.optionalKey(
        Schema.Struct({
          "title": Schema.optionalKey(Schema.String.annotate({ "description": "The organization title." })),
          "description": Schema.optionalKey(Schema.String.annotate({ "description": "The organization description." })),
          "name": Schema.optionalKey(Schema.String.annotate({ "description": "The organization name." })),
          "threads_ui_visibility": Schema.optionalKey(
            Schema.String.annotate({
              "description":
                "Visibility of the threads page which shows messages created with the Assistants API and Playground. One of `ANY_ROLE`, `OWNERS`, or `NONE`."
            })
          ),
          "usage_dashboard_visibility": Schema.optionalKey(
            Schema.String.annotate({
              "description":
                "Visibility of the usage dashboard which shows activity and costs for your organization. One of `ANY_ROLE` or `OWNERS`."
            })
          ),
          "api_call_logging": Schema.optionalKey(
            Schema.String.annotate({
              "description":
                "How your organization logs data from supported API calls. One of `disabled`, `enabled_per_call`, `enabled_for_all_projects`, or `enabled_for_selected_projects`"
            })
          ),
          "api_call_logging_project_ids": Schema.optionalKey(
            Schema.String.annotate({
              "description": "The list of project ids if api_call_logging is set to `enabled_for_selected_projects`"
            })
          )
        }).annotate({ "description": "The payload used to update the organization settings." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "project.created": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The project ID." })),
      "data": Schema.optionalKey(
        Schema.Struct({
          "name": Schema.optionalKey(Schema.String.annotate({ "description": "The project name." })),
          "title": Schema.optionalKey(
            Schema.String.annotate({ "description": "The title of the project as seen on the dashboard." })
          )
        }).annotate({ "description": "The payload used to create the project." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "project.updated": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The project ID." })),
      "changes_requested": Schema.optionalKey(
        Schema.Struct({
          "title": Schema.optionalKey(
            Schema.String.annotate({ "description": "The title of the project as seen on the dashboard." })
          )
        }).annotate({ "description": "The payload used to update the project." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "project.archived": Schema.optionalKey(
    Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The project ID." })) }).annotate({
      "description": "The details for events with this `type`."
    })
  ),
  "project.deleted": Schema.optionalKey(
    Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The project ID." })) }).annotate({
      "description": "The details for events with this `type`."
    })
  ),
  "rate_limit.updated": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The rate limit ID" })),
      "changes_requested": Schema.optionalKey(
        Schema.Struct({
          "max_requests_per_1_minute": Schema.optionalKey(
            Schema.Number.annotate({ "description": "The maximum requests per minute." }).check(Schema.isInt())
          ),
          "max_tokens_per_1_minute": Schema.optionalKey(
            Schema.Number.annotate({ "description": "The maximum tokens per minute." }).check(Schema.isInt())
          ),
          "max_images_per_1_minute": Schema.optionalKey(
            Schema.Number.annotate({
              "description": "The maximum images per minute. Only relevant for certain models."
            }).check(Schema.isInt())
          ),
          "max_audio_megabytes_per_1_minute": Schema.optionalKey(
            Schema.Number.annotate({
              "description": "The maximum audio megabytes per minute. Only relevant for certain models."
            }).check(Schema.isInt())
          ),
          "max_requests_per_1_day": Schema.optionalKey(
            Schema.Number.annotate({ "description": "The maximum requests per day. Only relevant for certain models." })
              .check(Schema.isInt())
          ),
          "batch_1_day_max_input_tokens": Schema.optionalKey(
            Schema.Number.annotate({
              "description": "The maximum batch input tokens per day. Only relevant for certain models."
            }).check(Schema.isInt())
          )
        }).annotate({ "description": "The payload used to update the rate limits." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "rate_limit.deleted": Schema.optionalKey(
    Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The rate limit ID" })) })
      .annotate({ "description": "The details for events with this `type`." })
  ),
  "role.created": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The role ID." })),
      "role_name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the role." })),
      "permissions": Schema.optionalKey(
        Schema.Array(Schema.String).annotate({ "description": "The permissions granted by the role." })
      ),
      "resource_type": Schema.optionalKey(
        Schema.String.annotate({ "description": "The type of resource the role belongs to." })
      ),
      "resource_id": Schema.optionalKey(
        Schema.String.annotate({ "description": "The resource the role is scoped to." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "role.updated": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The role ID." })),
      "changes_requested": Schema.optionalKey(
        Schema.Struct({
          "role_name": Schema.optionalKey(
            Schema.String.annotate({ "description": "The updated role name, when provided." })
          ),
          "resource_id": Schema.optionalKey(
            Schema.String.annotate({ "description": "The resource the role is scoped to." })
          ),
          "resource_type": Schema.optionalKey(
            Schema.String.annotate({ "description": "The type of resource the role belongs to." })
          ),
          "permissions_added": Schema.optionalKey(
            Schema.Array(Schema.String).annotate({ "description": "The permissions added to the role." })
          ),
          "permissions_removed": Schema.optionalKey(
            Schema.Array(Schema.String).annotate({ "description": "The permissions removed from the role." })
          ),
          "description": Schema.optionalKey(
            Schema.String.annotate({ "description": "The updated role description, when provided." })
          ),
          "metadata": Schema.optionalKey(
            Schema.Struct({}).annotate({ "description": "Additional metadata stored on the role." })
          )
        }).annotate({ "description": "The payload used to update the role." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "role.deleted": Schema.optionalKey(
    Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The role ID." })) }).annotate({
      "description": "The details for events with this `type`."
    })
  ),
  "role.assignment.created": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The identifier of the role assignment." })),
      "principal_id": Schema.optionalKey(
        Schema.String.annotate({ "description": "The principal (user or group) that received the role." })
      ),
      "principal_type": Schema.optionalKey(
        Schema.String.annotate({ "description": "The type of principal (user or group) that received the role." })
      ),
      "resource_id": Schema.optionalKey(
        Schema.String.annotate({ "description": "The resource the role assignment is scoped to." })
      ),
      "resource_type": Schema.optionalKey(
        Schema.String.annotate({ "description": "The type of resource the role assignment is scoped to." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "role.assignment.deleted": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The identifier of the role assignment." })),
      "principal_id": Schema.optionalKey(
        Schema.String.annotate({ "description": "The principal (user or group) that had the role removed." })
      ),
      "principal_type": Schema.optionalKey(
        Schema.String.annotate({ "description": "The type of principal (user or group) that had the role removed." })
      ),
      "resource_id": Schema.optionalKey(
        Schema.String.annotate({ "description": "The resource the role assignment was scoped to." })
      ),
      "resource_type": Schema.optionalKey(
        Schema.String.annotate({ "description": "The type of resource the role assignment was scoped to." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "service_account.created": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The service account ID." })),
      "data": Schema.optionalKey(
        Schema.Struct({
          "role": Schema.optionalKey(
            Schema.String.annotate({ "description": "The role of the service account. Is either `owner` or `member`." })
          )
        }).annotate({ "description": "The payload used to create the service account." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "service_account.updated": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The service account ID." })),
      "changes_requested": Schema.optionalKey(
        Schema.Struct({
          "role": Schema.optionalKey(
            Schema.String.annotate({ "description": "The role of the service account. Is either `owner` or `member`." })
          )
        }).annotate({ "description": "The payload used to updated the service account." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "service_account.deleted": Schema.optionalKey(
    Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The service account ID." })) })
      .annotate({ "description": "The details for events with this `type`." })
  ),
  "user.added": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The user ID." })),
      "data": Schema.optionalKey(
        Schema.Struct({
          "role": Schema.optionalKey(
            Schema.String.annotate({ "description": "The role of the user. Is either `owner` or `member`." })
          )
        }).annotate({ "description": "The payload used to add the user to the project." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "user.updated": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The project ID." })),
      "changes_requested": Schema.optionalKey(
        Schema.Struct({
          "role": Schema.optionalKey(
            Schema.String.annotate({ "description": "The role of the user. Is either `owner` or `member`." })
          )
        }).annotate({ "description": "The payload used to update the user." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "user.deleted": Schema.optionalKey(
    Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The user ID." })) }).annotate({
      "description": "The details for events with this `type`."
    })
  ),
  "certificate.created": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The certificate ID." })),
      "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the certificate." }))
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "certificate.updated": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The certificate ID." })),
      "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the certificate." }))
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "certificate.deleted": Schema.optionalKey(
    Schema.Struct({
      "id": Schema.optionalKey(Schema.String.annotate({ "description": "The certificate ID." })),
      "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the certificate." })),
      "certificate": Schema.optionalKey(
        Schema.String.annotate({ "description": "The certificate content in PEM format." })
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "certificates.activated": Schema.optionalKey(
    Schema.Struct({
      "certificates": Schema.optionalKey(
        Schema.Array(
          Schema.Struct({
            "id": Schema.optionalKey(Schema.String.annotate({ "description": "The certificate ID." })),
            "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the certificate." }))
          })
        )
      )
    }).annotate({ "description": "The details for events with this `type`." })
  ),
  "certificates.deactivated": Schema.optionalKey(
    Schema.Struct({
      "certificates": Schema.optionalKey(
        Schema.Array(
          Schema.Struct({
            "id": Schema.optionalKey(Schema.String.annotate({ "description": "The certificate ID." })),
            "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the certificate." }))
          })
        )
      )
    }).annotate({ "description": "The details for events with this `type`." })
  )
}).annotate({ "description": "A log of a user action or configuration change within this organization." })
export type CreateChatCompletionResponse = {
  readonly "id": string
  readonly "choices": ReadonlyArray<
    {
      readonly "finish_reason": "stop" | "length" | "tool_calls" | "content_filter" | "function_call"
      readonly "index": number
      readonly "message": ChatCompletionResponseMessage
      readonly "logprobs": {
        readonly "content": ReadonlyArray<ChatCompletionTokenLogprob> | null
        readonly "refusal": ReadonlyArray<ChatCompletionTokenLogprob> | null
      } | null
    }
  >
  readonly "created": number
  readonly "model": string
  readonly "service_tier"?: ServiceTier
  readonly "system_fingerprint"?: string
  readonly "object": "chat.completion"
  readonly "usage"?: CompletionUsage
}
export const CreateChatCompletionResponse = Schema.Struct({
  "id": Schema.String.annotate({ "description": "A unique identifier for the chat completion." }),
  "choices": Schema.Array(Schema.Struct({
    "finish_reason": Schema.Literals(["stop", "length", "tool_calls", "content_filter", "function_call"]).annotate({
      "description":
        "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\n`content_filter` if content was omitted due to a flag from our content filters,\n`tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.\n"
    }),
    "index": Schema.Number.annotate({ "description": "The index of the choice in the list of choices." }).check(
      Schema.isInt()
    ),
    "message": ChatCompletionResponseMessage,
    "logprobs": Schema.Union([
      Schema.Struct({
        "content": Schema.Union([
          Schema.Array(ChatCompletionTokenLogprob).annotate({
            "description": "A list of message content tokens with log probability information."
          }),
          Schema.Null
        ]),
        "refusal": Schema.Union([
          Schema.Array(ChatCompletionTokenLogprob).annotate({
            "description": "A list of message refusal tokens with log probability information."
          }),
          Schema.Null
        ])
      }).annotate({ "description": "Log probability information for the choice." }),
      Schema.Null
    ])
  })).annotate({ "description": "A list of chat completion choices. Can be more than one if `n` is greater than 1." }),
  "created": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) of when the chat completion was created."
  }).check(Schema.isInt()),
  "model": Schema.String.annotate({ "description": "The model used for the chat completion." }),
  "service_tier": Schema.optionalKey(ServiceTier),
  "system_fingerprint": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "This fingerprint represents the backend configuration that the model runs with.\n\nCan be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.\n"
    })
  ),
  "object": Schema.Literal("chat.completion").annotate({
    "description": "The object type, which is always `chat.completion`."
  }),
  "usage": Schema.optionalKey(CompletionUsage)
}).annotate({ "description": "Represents a chat completion response returned by model, based on the provided input." })
export type ChatCompletionRequestMessage =
  | ChatCompletionRequestDeveloperMessage
  | ChatCompletionRequestSystemMessage
  | ChatCompletionRequestUserMessage
  | ChatCompletionRequestAssistantMessage
  | ChatCompletionRequestToolMessage
  | ChatCompletionRequestFunctionMessage
export const ChatCompletionRequestMessage = Schema.Union([
  ChatCompletionRequestDeveloperMessage,
  ChatCompletionRequestSystemMessage,
  ChatCompletionRequestUserMessage,
  ChatCompletionRequestAssistantMessage,
  ChatCompletionRequestToolMessage,
  ChatCompletionRequestFunctionMessage
], { mode: "oneOf" })
export type RunStepDetailsToolCallsObject = {
  readonly "type": "tool_calls"
  readonly "tool_calls": ReadonlyArray<
    RunStepDetailsToolCallsCodeObject | RunStepDetailsToolCallsFileSearchObject | RunStepDetailsToolCallsFunctionObject
  >
}
export const RunStepDetailsToolCallsObject = Schema.Struct({
  "type": Schema.Literal("tool_calls").annotate({ "description": "Always `tool_calls`." }),
  "tool_calls": Schema.Array(
    Schema.Union([
      RunStepDetailsToolCallsCodeObject,
      RunStepDetailsToolCallsFileSearchObject,
      RunStepDetailsToolCallsFunctionObject
    ], { mode: "oneOf" })
  ).annotate({
    "description":
      "An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.\n"
  })
}).annotate({ "title": "Tool calls", "description": "Details of the tool call." })
export type ListMessagesResponse = {
  readonly "object": string
  readonly "data": ReadonlyArray<MessageObject>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
  readonly [x: string]: unknown
}
export const ListMessagesResponse = Schema.StructWithRest(
  Schema.Struct({
    "object": Schema.String,
    "data": Schema.Array(MessageObject),
    "first_id": Schema.String,
    "last_id": Schema.String,
    "has_more": Schema.Boolean
  }),
  [Schema.Record(Schema.String, Schema.Json)]
)
export type MessageStreamEvent =
  | { readonly "event": "thread.message.created"; readonly "data": MessageObject }
  | { readonly "event": "thread.message.in_progress"; readonly "data": MessageObject }
  | { readonly "event": "thread.message.delta"; readonly "data": MessageDeltaObject }
  | { readonly "event": "thread.message.completed"; readonly "data": MessageObject }
  | { readonly "event": "thread.message.incomplete"; readonly "data": MessageObject }
export const MessageStreamEvent = Schema.Union([
  Schema.Struct({ "event": Schema.Literal("thread.message.created"), "data": MessageObject }).annotate({
    "description": "Occurs when a [message](/docs/api-reference/messages/object) is created."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.message.in_progress"), "data": MessageObject }).annotate({
    "description": "Occurs when a [message](/docs/api-reference/messages/object) moves to an `in_progress` state."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.message.delta"), "data": MessageDeltaObject }).annotate({
    "description": "Occurs when parts of a [Message](/docs/api-reference/messages/object) are being streamed."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.message.completed"), "data": MessageObject }).annotate({
    "description": "Occurs when a [message](/docs/api-reference/messages/object) is completed."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.message.incomplete"), "data": MessageObject }).annotate({
    "description": "Occurs when a [message](/docs/api-reference/messages/object) ends before it is completed."
  })
], { mode: "oneOf" })
export type RealtimeBetaResponse = {
  readonly "id"?: string
  readonly "object"?: "realtime.response"
  readonly "status"?: "completed" | "cancelled" | "failed" | "incomplete" | "in_progress"
  readonly "status_details"?: {
    readonly "type"?: "completed" | "cancelled" | "failed" | "incomplete"
    readonly "reason"?: "turn_detected" | "client_cancelled" | "max_output_tokens" | "content_filter"
    readonly "error"?: { readonly "type"?: string; readonly "code"?: string }
  }
  readonly "output"?: ReadonlyArray<RealtimeConversationItem>
  readonly "metadata"?: Metadata
  readonly "usage"?: {
    readonly "total_tokens"?: number
    readonly "input_tokens"?: number
    readonly "output_tokens"?: number
    readonly "input_token_details"?: {
      readonly "cached_tokens"?: number
      readonly "text_tokens"?: number
      readonly "image_tokens"?: number
      readonly "audio_tokens"?: number
      readonly "cached_tokens_details"?: {
        readonly "text_tokens"?: number
        readonly "image_tokens"?: number
        readonly "audio_tokens"?: number
      }
    }
    readonly "output_token_details"?: { readonly "text_tokens"?: number; readonly "audio_tokens"?: number }
  }
  readonly "conversation_id"?: string
  readonly "voice"?:
    | string
    | "alloy"
    | "ash"
    | "ballad"
    | "coral"
    | "echo"
    | "sage"
    | "shimmer"
    | "verse"
    | "marin"
    | "cedar"
  readonly "modalities"?: ReadonlyArray<"text" | "audio">
  readonly "output_audio_format"?: "pcm16" | "g711_ulaw" | "g711_alaw"
  readonly "temperature"?: number
  readonly "max_output_tokens"?: number | "inf"
}
export const RealtimeBetaResponse = Schema.Struct({
  "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the response." })),
  "object": Schema.optionalKey(
    Schema.Literal("realtime.response").annotate({ "description": "The object type, must be `realtime.response`." })
  ),
  "status": Schema.optionalKey(
    Schema.Literals(["completed", "cancelled", "failed", "incomplete", "in_progress"]).annotate({
      "description":
        "The final status of the response (`completed`, `cancelled`, `failed`, or \n`incomplete`, `in_progress`).\n"
    })
  ),
  "status_details": Schema.optionalKey(
    Schema.Struct({
      "type": Schema.optionalKey(
        Schema.Literals(["completed", "cancelled", "failed", "incomplete"]).annotate({
          "description":
            "The type of error that caused the response to fail, corresponding \nwith the `status` field (`completed`, `cancelled`, `incomplete`, \n`failed`).\n"
        })
      ),
      "reason": Schema.optionalKey(
        Schema.Literals(["turn_detected", "client_cancelled", "max_output_tokens", "content_filter"]).annotate({
          "description":
            "The reason the Response did not complete. For a `cancelled` Response, \none of `turn_detected` (the server VAD detected a new start of speech) \nor `client_cancelled` (the client sent a cancel event). For an \n`incomplete` Response, one of `max_output_tokens` or `content_filter` \n(the server-side safety filter activated and cut off the response).\n"
        })
      ),
      "error": Schema.optionalKey(
        Schema.Struct({
          "type": Schema.optionalKey(Schema.String.annotate({ "description": "The type of error." })),
          "code": Schema.optionalKey(Schema.String.annotate({ "description": "Error code, if any." }))
        }).annotate({
          "description":
            "A description of the error that caused the response to fail, \npopulated when the `status` is `failed`.\n"
        })
      )
    }).annotate({ "description": "Additional details about the status." })
  ),
  "output": Schema.optionalKey(
    Schema.Array(RealtimeConversationItem).annotate({
      "description": "The list of output items generated by the response."
    })
  ),
  "metadata": Schema.optionalKey(Metadata),
  "usage": Schema.optionalKey(
    Schema.Struct({
      "total_tokens": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "The total number of tokens in the Response including input and output \ntext and audio tokens.\n"
        }).check(Schema.isInt())
      ),
      "input_tokens": Schema.optionalKey(
        Schema.Number.annotate({
          "description": "The number of input tokens used in the Response, including text and \naudio tokens.\n"
        }).check(Schema.isInt())
      ),
      "output_tokens": Schema.optionalKey(
        Schema.Number.annotate({
          "description": "The number of output tokens sent in the Response, including text and \naudio tokens.\n"
        }).check(Schema.isInt())
      ),
      "input_token_details": Schema.optionalKey(
        Schema.Struct({
          "cached_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "The number of cached tokens used as input for the Response." })
              .check(Schema.isInt())
          ),
          "text_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "The number of text tokens used as input for the Response." })
              .check(Schema.isInt())
          ),
          "image_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "The number of image tokens used as input for the Response." })
              .check(Schema.isInt())
          ),
          "audio_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "The number of audio tokens used as input for the Response." })
              .check(Schema.isInt())
          ),
          "cached_tokens_details": Schema.optionalKey(
            Schema.Struct({
              "text_tokens": Schema.optionalKey(
                Schema.Number.annotate({
                  "description": "The number of cached text tokens used as input for the Response."
                }).check(Schema.isInt())
              ),
              "image_tokens": Schema.optionalKey(
                Schema.Number.annotate({
                  "description": "The number of cached image tokens used as input for the Response."
                }).check(Schema.isInt())
              ),
              "audio_tokens": Schema.optionalKey(
                Schema.Number.annotate({
                  "description": "The number of cached audio tokens used as input for the Response."
                }).check(Schema.isInt())
              )
            }).annotate({ "description": "Details about the cached tokens used as input for the Response." })
          )
        }).annotate({ "description": "Details about the input tokens used in the Response." })
      ),
      "output_token_details": Schema.optionalKey(
        Schema.Struct({
          "text_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "The number of text tokens used in the Response." }).check(
              Schema.isInt()
            )
          ),
          "audio_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "The number of audio tokens used in the Response." }).check(
              Schema.isInt()
            )
          )
        }).annotate({ "description": "Details about the output tokens used in the Response." })
      )
    }).annotate({
      "description":
        "Usage statistics for the Response, this will correspond to billing. A \nRealtime API session will maintain a conversation context and append new \nItems to the Conversation, thus output from previous turns (text and \naudio tokens) will become the input for later turns.\n"
    })
  ),
  "conversation_id": Schema.optionalKey(Schema.String.annotate({
    "description":
      "Which conversation the response is added to, determined by the `conversation`\nfield in the `response.create` event. If `auto`, the response will be added to\nthe default conversation and the value of `conversation_id` will be an id like\n`conv_1234`. If `none`, the response will not be added to any conversation and\nthe value of `conversation_id` will be `null`. If responses are being triggered\nby server VAD, the response will be added to the default conversation, thus\nthe `conversation_id` will be an id like `conv_1234`.\n"
  })),
  "voice": Schema.optionalKey(
    Schema.Union([
      Schema.String,
      Schema.Literals(["alloy", "ash", "ballad", "coral", "echo", "sage", "shimmer", "verse", "marin", "cedar"])
    ]).annotate({
      "description":
        "The voice the model used to respond.\nCurrent voice options are `alloy`, `ash`, `ballad`, `coral`, `echo`, `sage`,\n`shimmer`, and `verse`.\n"
    })
  ),
  "modalities": Schema.optionalKey(
    Schema.Array(Schema.Literals(["text", "audio"])).annotate({
      "description":
        "The set of modalities the model used to respond. If there are multiple modalities,\nthe model will pick one, for example if `modalities` is `[\"text\", \"audio\"]`, the model\ncould be responding in either text or audio.\n"
    })
  ),
  "output_audio_format": Schema.optionalKey(
    Schema.Literals(["pcm16", "g711_ulaw", "g711_alaw"]).annotate({
      "description": "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"
    })
  ),
  "temperature": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.\n"
    }).check(Schema.isFinite())
  ),
  "max_output_tokens": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")], { mode: "oneOf" }).annotate({
      "description":
        "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls, that was used in this response.\n"
    })
  )
}).annotate({ "description": "The response resource." })
export type RealtimeBetaResponseCreateParams = {
  readonly "modalities"?: ReadonlyArray<"text" | "audio">
  readonly "instructions"?: string
  readonly "voice"?:
    | string
    | "alloy"
    | "ash"
    | "ballad"
    | "coral"
    | "echo"
    | "sage"
    | "shimmer"
    | "verse"
    | "marin"
    | "cedar"
    | { readonly "id": string }
  readonly "output_audio_format"?: "pcm16" | "g711_ulaw" | "g711_alaw"
  readonly "tools"?: ReadonlyArray<
    {
      readonly "type"?: "function"
      readonly "name"?: string
      readonly "description"?: string
      readonly "parameters"?: {}
    }
  >
  readonly "tool_choice"?: ToolChoiceOptions | ToolChoiceFunction | ToolChoiceMCP
  readonly "temperature"?: number
  readonly "max_output_tokens"?: number | "inf"
  readonly "conversation"?: string | "auto" | "none"
  readonly "metadata"?: Metadata
  readonly "prompt"?: Prompt
  readonly "input"?: ReadonlyArray<RealtimeConversationItem>
}
export const RealtimeBetaResponseCreateParams = Schema.Struct({
  "modalities": Schema.optionalKey(
    Schema.Array(Schema.Literals(["text", "audio"])).annotate({
      "description": "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"
    })
  ),
  "instructions": Schema.optionalKey(Schema.String.annotate({
    "description":
      "The default system instructions (i.e. system message) prepended to model \ncalls. This field allows the client to guide the model on desired \nresponses. The model can be instructed on response content and format, \n(e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good \nresponses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion \ninto your voice\", \"laugh frequently\"). The instructions are not guaranteed \nto be followed by the model, but they provide guidance to the model on the \ndesired behavior.\n\nNote that the server sets default instructions which will be used if this \nfield is not set and are visible in the `session.created` event at the \nstart of the session.\n"
  })),
  "voice": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        Schema.String,
        Schema.Literals(["alloy", "ash", "ballad", "coral", "echo", "sage", "shimmer", "verse", "marin", "cedar"])
      ]),
      Schema.Struct({ "id": Schema.String.annotate({ "description": "The custom voice ID, e.g. `voice_1234`." }) })
        .annotate({ "description": "Custom voice reference." })
    ]).annotate({
      "title": "Voice",
      "description":
        "The voice the model uses to respond. Supported built-in voices are\n`alloy`, `ash`, `ballad`, `coral`, `echo`, `sage`, `shimmer`, `verse`,\n`marin`, and `cedar`. You may also provide a custom voice object with an\n`id`, for example `{ \"id\": \"voice_1234\" }`. Voice cannot be changed during\nthe session once the model has responded with audio at least once.\n"
    })
  ),
  "output_audio_format": Schema.optionalKey(
    Schema.Literals(["pcm16", "g711_ulaw", "g711_alaw"]).annotate({
      "description": "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"
    })
  ),
  "tools": Schema.optionalKey(
    Schema.Array(Schema.Struct({
      "type": Schema.optionalKey(
        Schema.Literal("function").annotate({ "description": "The type of the tool, i.e. `function`." })
      ),
      "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the function." })),
      "description": Schema.optionalKey(
        Schema.String.annotate({
          "description":
            "The description of the function, including guidance on when and how \nto call it, and guidance about what to tell the user when calling \n(if anything).\n"
        })
      ),
      "parameters": Schema.optionalKey(
        Schema.Struct({}).annotate({ "description": "Parameters of the function in JSON Schema." })
      )
    })).annotate({ "description": "Tools (functions) available to the model." })
  ),
  "tool_choice": Schema.optionalKey(
    Schema.Union([ToolChoiceOptions, ToolChoiceFunction, ToolChoiceMCP], { mode: "oneOf" }).annotate({
      "description":
        "How the model chooses tools. Provide one of the string modes or force a specific\nfunction/MCP tool.\n"
    })
  ),
  "temperature": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.\n"
    }).check(Schema.isFinite())
  ),
  "max_output_tokens": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")], { mode: "oneOf" }).annotate({
      "description":
        "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"
    })
  ),
  "conversation": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Literals(["auto", "none"])], { mode: "oneOf" }).annotate({
      "description":
        "Controls which conversation the response is added to. Currently supports\n`auto` and `none`, with `auto` as the default value. The `auto` value\nmeans that the contents of the response will be added to the default\nconversation. Set this to `none` to create an out-of-band response which \nwill not add items to default conversation.\n"
    })
  ),
  "metadata": Schema.optionalKey(Metadata),
  "prompt": Schema.optionalKey(Prompt),
  "input": Schema.optionalKey(
    Schema.Array(RealtimeConversationItem).annotate({
      "description":
        "Input items to include in the prompt for the model. Using this field\ncreates a new context for this Response instead of using the default\nconversation. An empty array `[]` will clear the context for this Response.\nNote that this can include references to items from the default conversation.\n"
    })
  )
}).annotate({ "description": "Create a new Realtime response with these parameters" })
export type RealtimeClientEventConversationItemCreate = {
  readonly "event_id"?: string
  readonly "type": "conversation.item.create"
  readonly "previous_item_id"?: string
  readonly "item": RealtimeConversationItem
}
export const RealtimeClientEventConversationItemCreate = Schema.Struct({
  "event_id": Schema.optionalKey(
    Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." }).check(
      Schema.isMaxLength(512)
    )
  ),
  "type": Schema.Literal("conversation.item.create").annotate({
    "description": "The event type, must be `conversation.item.create`."
  }),
  "previous_item_id": Schema.optionalKey(Schema.String.annotate({
    "description":
      "The ID of the preceding item after which the new item will be inserted. If not set, the new item will be appended to the end of the conversation.\n\nIf set to `root`, the new item will be added to the beginning of the conversation.\n\nIf set to an existing ID, it allows an item to be inserted mid-conversation. If the ID cannot be found, an error will be returned and the item will not be added.\n"
  })),
  "item": RealtimeConversationItem
}).annotate({
  "description":
    "Add a new Item to the Conversation's context, including messages, function \ncalls, and function call responses. This event can be used both to populate a \n\"history\" of the conversation and to add new items mid-stream, but has the \ncurrent limitation that it cannot populate assistant audio messages.\n\nIf successful, the server will respond with a `conversation.item.created` \nevent, otherwise an `error` event will be sent.\n"
})
export type RealtimeResponse = {
  readonly "id"?: string
  readonly "object"?: "realtime.response"
  readonly "status"?: "completed" | "cancelled" | "failed" | "incomplete" | "in_progress"
  readonly "status_details"?: {
    readonly "type"?: "completed" | "cancelled" | "failed" | "incomplete"
    readonly "reason"?: "turn_detected" | "client_cancelled" | "max_output_tokens" | "content_filter"
    readonly "error"?: { readonly "type"?: string; readonly "code"?: string }
  }
  readonly "output"?: ReadonlyArray<RealtimeConversationItem>
  readonly "metadata"?: Metadata
  readonly "audio"?: {
    readonly "output"?: {
      readonly "format"?: { readonly "type"?: "audio/pcm"; readonly "rate"?: 24000 } | {
        readonly "type"?: "audio/pcmu"
      } | { readonly "type"?: "audio/pcma" }
      readonly "voice"?:
        | string
        | "alloy"
        | "ash"
        | "ballad"
        | "coral"
        | "echo"
        | "sage"
        | "shimmer"
        | "verse"
        | "marin"
        | "cedar"
    }
  }
  readonly "usage"?: {
    readonly "total_tokens"?: number
    readonly "input_tokens"?: number
    readonly "output_tokens"?: number
    readonly "input_token_details"?: {
      readonly "cached_tokens"?: number
      readonly "text_tokens"?: number
      readonly "image_tokens"?: number
      readonly "audio_tokens"?: number
      readonly "cached_tokens_details"?: {
        readonly "text_tokens"?: number
        readonly "image_tokens"?: number
        readonly "audio_tokens"?: number
      }
    }
    readonly "output_token_details"?: { readonly "text_tokens"?: number; readonly "audio_tokens"?: number }
  }
  readonly "conversation_id"?: string
  readonly "output_modalities"?: ReadonlyArray<"text" | "audio">
  readonly "max_output_tokens"?: number | "inf"
}
export const RealtimeResponse = Schema.Struct({
  "id": Schema.optionalKey(
    Schema.String.annotate({ "description": "The unique ID of the response, will look like `resp_1234`." })
  ),
  "object": Schema.optionalKey(
    Schema.Literal("realtime.response").annotate({ "description": "The object type, must be `realtime.response`." })
  ),
  "status": Schema.optionalKey(
    Schema.Literals(["completed", "cancelled", "failed", "incomplete", "in_progress"]).annotate({
      "description":
        "The final status of the response (`completed`, `cancelled`, `failed`, or \n`incomplete`, `in_progress`).\n"
    })
  ),
  "status_details": Schema.optionalKey(
    Schema.Struct({
      "type": Schema.optionalKey(
        Schema.Literals(["completed", "cancelled", "failed", "incomplete"]).annotate({
          "description":
            "The type of error that caused the response to fail, corresponding \nwith the `status` field (`completed`, `cancelled`, `incomplete`, \n`failed`).\n"
        })
      ),
      "reason": Schema.optionalKey(
        Schema.Literals(["turn_detected", "client_cancelled", "max_output_tokens", "content_filter"]).annotate({
          "description":
            "The reason the Response did not complete. For a `cancelled` Response,  one of `turn_detected` (the server VAD detected a new start of speech)  or `client_cancelled` (the client sent a cancel event). For an  `incomplete` Response, one of `max_output_tokens` or `content_filter`  (the server-side safety filter activated and cut off the response).\n"
        })
      ),
      "error": Schema.optionalKey(
        Schema.Struct({
          "type": Schema.optionalKey(Schema.String.annotate({ "description": "The type of error." })),
          "code": Schema.optionalKey(Schema.String.annotate({ "description": "Error code, if any." }))
        }).annotate({
          "description":
            "A description of the error that caused the response to fail, \npopulated when the `status` is `failed`.\n"
        })
      )
    }).annotate({ "description": "Additional details about the status." })
  ),
  "output": Schema.optionalKey(
    Schema.Array(RealtimeConversationItem).annotate({
      "description": "The list of output items generated by the response."
    })
  ),
  "metadata": Schema.optionalKey(Metadata),
  "audio": Schema.optionalKey(
    Schema.Struct({
      "output": Schema.optionalKey(Schema.Struct({
        "format": Schema.optionalKey(
          Schema.Union([
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcm").annotate({ "description": "The audio format. Always `audio/pcm`." })
              ),
              "rate": Schema.optionalKey(
                Schema.Literal(24000).annotate({ "description": "The sample rate of the audio. Always `24000`." })
              )
            }).annotate({
              "title": "PCM audio format",
              "description": "The PCM audio format. Only a 24kHz sample rate is supported."
            }),
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcmu").annotate({ "description": "The audio format. Always `audio/pcmu`." })
              )
            }).annotate({ "title": "PCMU audio format", "description": "The G.711 -law format." }),
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcma").annotate({ "description": "The audio format. Always `audio/pcma`." })
              )
            }).annotate({ "title": "PCMA audio format", "description": "The G.711 A-law format." })
          ]).annotate({ "description": "The format of the output audio." })
        ),
        "voice": Schema.optionalKey(
          Schema.Union([
            Schema.String,
            Schema.Literals(["alloy", "ash", "ballad", "coral", "echo", "sage", "shimmer", "verse", "marin", "cedar"])
          ]).annotate({
            "description":
              "The voice the model uses to respond. Voice cannot be changed during the\nsession once the model has responded with audio at least once. Current\nvoice options are `alloy`, `ash`, `ballad`, `coral`, `echo`, `sage`,\n`shimmer`, `verse`, `marin`, and `cedar`. We recommend `marin` and `cedar` for\nbest quality.\n"
          })
        )
      }))
    }).annotate({ "description": "Configuration for audio output." })
  ),
  "usage": Schema.optionalKey(
    Schema.Struct({
      "total_tokens": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "The total number of tokens in the Response including input and output \ntext and audio tokens.\n"
        }).check(Schema.isInt())
      ),
      "input_tokens": Schema.optionalKey(
        Schema.Number.annotate({
          "description": "The number of input tokens used in the Response, including text and \naudio tokens.\n"
        }).check(Schema.isInt())
      ),
      "output_tokens": Schema.optionalKey(
        Schema.Number.annotate({
          "description": "The number of output tokens sent in the Response, including text and \naudio tokens.\n"
        }).check(Schema.isInt())
      ),
      "input_token_details": Schema.optionalKey(
        Schema.Struct({
          "cached_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "The number of cached tokens used as input for the Response." })
              .check(Schema.isInt())
          ),
          "text_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "The number of text tokens used as input for the Response." })
              .check(Schema.isInt())
          ),
          "image_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "The number of image tokens used as input for the Response." })
              .check(Schema.isInt())
          ),
          "audio_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "The number of audio tokens used as input for the Response." })
              .check(Schema.isInt())
          ),
          "cached_tokens_details": Schema.optionalKey(
            Schema.Struct({
              "text_tokens": Schema.optionalKey(
                Schema.Number.annotate({
                  "description": "The number of cached text tokens used as input for the Response."
                }).check(Schema.isInt())
              ),
              "image_tokens": Schema.optionalKey(
                Schema.Number.annotate({
                  "description": "The number of cached image tokens used as input for the Response."
                }).check(Schema.isInt())
              ),
              "audio_tokens": Schema.optionalKey(
                Schema.Number.annotate({
                  "description": "The number of cached audio tokens used as input for the Response."
                }).check(Schema.isInt())
              )
            }).annotate({ "description": "Details about the cached tokens used as input for the Response." })
          )
        }).annotate({
          "description":
            "Details about the input tokens used in the Response. Cached tokens are tokens from previous turns in the conversation that are included as context for the current response. Cached tokens here are counted as a subset of input tokens, meaning input tokens will include cached and uncached tokens."
        })
      ),
      "output_token_details": Schema.optionalKey(
        Schema.Struct({
          "text_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "The number of text tokens used in the Response." }).check(
              Schema.isInt()
            )
          ),
          "audio_tokens": Schema.optionalKey(
            Schema.Number.annotate({ "description": "The number of audio tokens used in the Response." }).check(
              Schema.isInt()
            )
          )
        }).annotate({ "description": "Details about the output tokens used in the Response." })
      )
    }).annotate({
      "description":
        "Usage statistics for the Response, this will correspond to billing. A \nRealtime API session will maintain a conversation context and append new \nItems to the Conversation, thus output from previous turns (text and \naudio tokens) will become the input for later turns.\n"
    })
  ),
  "conversation_id": Schema.optionalKey(Schema.String.annotate({
    "description":
      "Which conversation the response is added to, determined by the `conversation`\nfield in the `response.create` event. If `auto`, the response will be added to\nthe default conversation and the value of `conversation_id` will be an id like\n`conv_1234`. If `none`, the response will not be added to any conversation and\nthe value of `conversation_id` will be `null`. If responses are being triggered\nautomatically by VAD the response will be added to the default conversation\n"
  })),
  "output_modalities": Schema.optionalKey(
    Schema.Array(Schema.Literals(["text", "audio"])).annotate({
      "description":
        "The set of modalities the model used to respond, currently the only possible values are\n`[\\\"audio\\\"]`, `[\\\"text\\\"]`. Audio output always include a text transcript. Setting the\noutput to mode `text` will disable audio output from the model.\n"
    })
  ),
  "max_output_tokens": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")], { mode: "oneOf" }).annotate({
      "description":
        "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls, that was used in this response.\n"
    })
  )
}).annotate({ "description": "The response resource." })
export type RealtimeResponseCreateParams = {
  readonly "output_modalities"?: ReadonlyArray<"text" | "audio">
  readonly "instructions"?: string
  readonly "audio"?: {
    readonly "output"?: {
      readonly "format"?: { readonly "type"?: "audio/pcm"; readonly "rate"?: 24000 } | {
        readonly "type"?: "audio/pcmu"
      } | { readonly "type"?: "audio/pcma" }
      readonly "voice"?:
        | string
        | "alloy"
        | "ash"
        | "ballad"
        | "coral"
        | "echo"
        | "sage"
        | "shimmer"
        | "verse"
        | "marin"
        | "cedar"
        | { readonly "id": string }
    }
  }
  readonly "tools"?: ReadonlyArray<RealtimeFunctionTool | MCPTool>
  readonly "tool_choice"?: ToolChoiceOptions | ToolChoiceFunction | ToolChoiceMCP
  readonly "max_output_tokens"?: number | "inf"
  readonly "conversation"?: string | "auto" | "none"
  readonly "metadata"?: Metadata
  readonly "prompt"?: Prompt
  readonly "input"?: ReadonlyArray<RealtimeConversationItem>
}
export const RealtimeResponseCreateParams = Schema.Struct({
  "output_modalities": Schema.optionalKey(
    Schema.Array(Schema.Literals(["text", "audio"])).annotate({
      "description":
        "The set of modalities the model used to respond, currently the only possible values are\n`[\\\"audio\\\"]`, `[\\\"text\\\"]`. Audio output always include a text transcript. Setting the\noutput to mode `text` will disable audio output from the model.\n"
    })
  ),
  "instructions": Schema.optionalKey(Schema.String.annotate({
    "description":
      "The default system instructions (i.e. system message) prepended to model calls. This field allows the client to guide the model on desired responses. The model can be instructed on response content and format, (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion into your voice\", \"laugh frequently\"). The instructions are not guaranteed to be followed by the model, but they provide guidance to the model on the desired behavior.\nNote that the server sets default instructions which will be used if this field is not set and are visible in the `session.created` event at the start of the session.\n"
  })),
  "audio": Schema.optionalKey(
    Schema.Struct({
      "output": Schema.optionalKey(Schema.Struct({
        "format": Schema.optionalKey(
          Schema.Union([
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcm").annotate({ "description": "The audio format. Always `audio/pcm`." })
              ),
              "rate": Schema.optionalKey(
                Schema.Literal(24000).annotate({ "description": "The sample rate of the audio. Always `24000`." })
              )
            }).annotate({
              "title": "PCM audio format",
              "description": "The PCM audio format. Only a 24kHz sample rate is supported."
            }),
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcmu").annotate({ "description": "The audio format. Always `audio/pcmu`." })
              )
            }).annotate({ "title": "PCMU audio format", "description": "The G.711 -law format." }),
            Schema.Struct({
              "type": Schema.optionalKey(
                Schema.Literal("audio/pcma").annotate({ "description": "The audio format. Always `audio/pcma`." })
              )
            }).annotate({ "title": "PCMA audio format", "description": "The G.711 A-law format." })
          ]).annotate({ "description": "The format of the output audio." })
        ),
        "voice": Schema.optionalKey(
          Schema.Union([
            Schema.Union([
              Schema.String,
              Schema.Literals(["alloy", "ash", "ballad", "coral", "echo", "sage", "shimmer", "verse", "marin", "cedar"])
            ]),
            Schema.Struct({
              "id": Schema.String.annotate({ "description": "The custom voice ID, e.g. `voice_1234`." })
            }).annotate({ "description": "Custom voice reference." })
          ]).annotate({
            "title": "Voice",
            "description":
              "The voice the model uses to respond. Supported built-in voices are\n`alloy`, `ash`, `ballad`, `coral`, `echo`, `sage`, `shimmer`, `verse`,\n`marin`, and `cedar`. You may also provide a custom voice object with\nan `id`, for example `{ \"id\": \"voice_1234\" }`. Voice cannot be changed\nduring the session once the model has responded with audio at least once.\nWe recommend `marin` and `cedar` for best quality.\n"
          })
        )
      }))
    }).annotate({ "description": "Configuration for audio input and output." })
  ),
  "tools": Schema.optionalKey(
    Schema.Array(Schema.Union([RealtimeFunctionTool, MCPTool], { mode: "oneOf" })).annotate({
      "description": "Tools available to the model."
    })
  ),
  "tool_choice": Schema.optionalKey(
    Schema.Union([ToolChoiceOptions, ToolChoiceFunction, ToolChoiceMCP], { mode: "oneOf" }).annotate({
      "description":
        "How the model chooses tools. Provide one of the string modes or force a specific\nfunction/MCP tool.\n"
    })
  ),
  "max_output_tokens": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")], { mode: "oneOf" }).annotate({
      "description":
        "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"
    })
  ),
  "conversation": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Literals(["auto", "none"])], { mode: "oneOf" }).annotate({
      "description":
        "Controls which conversation the response is added to. Currently supports\n`auto` and `none`, with `auto` as the default value. The `auto` value\nmeans that the contents of the response will be added to the default\nconversation. Set this to `none` to create an out-of-band response which\nwill not add items to default conversation.\n"
    })
  ),
  "metadata": Schema.optionalKey(Metadata),
  "prompt": Schema.optionalKey(Prompt),
  "input": Schema.optionalKey(
    Schema.Array(RealtimeConversationItem).annotate({
      "description":
        "Input items to include in the prompt for the model. Using this field\ncreates a new context for this Response instead of using the default\nconversation. An empty array `[]` will clear the context for this Response.\nNote that this can include references to items that previously appeared in the session\nusing their id.\n"
    })
  )
}).annotate({ "description": "Create a new Realtime response with these parameters" })
export type RealtimeServerEventConversationItemAdded = {
  readonly "event_id": string
  readonly "type": "conversation.item.added"
  readonly "previous_item_id"?: string | null
  readonly "item": RealtimeConversationItem
}
export const RealtimeServerEventConversationItemAdded = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("conversation.item.added").annotate({
    "description": "The event type, must be `conversation.item.added`."
  }),
  "previous_item_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "The ID of the item that precedes this one, if any. This is used to\nmaintain ordering when items are inserted.\n"
      }),
      Schema.Null
    ])
  ),
  "item": RealtimeConversationItem
}).annotate({
  "description":
    "Sent by the server when an Item is added to the default Conversation. This can happen in several cases:\n- When the client sends a `conversation.item.create` event.\n- When the input audio buffer is committed. In this case the item will be a user message containing the audio from the buffer.\n- When the model is generating a Response. In this case the `conversation.item.added` event will be sent when the model starts generating a specific Item, and thus it will not yet have any content (and `status` will be `in_progress`).\n\nThe event will include the full content of the Item (except when model is generating a Response) except for audio data, which can be retrieved separately with a `conversation.item.retrieve` event if necessary.\n"
})
export type RealtimeServerEventConversationItemCreated = {
  readonly "event_id": string
  readonly "type": "conversation.item.created"
  readonly "previous_item_id"?: string | null
  readonly "item": RealtimeConversationItem
}
export const RealtimeServerEventConversationItemCreated = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("conversation.item.created").annotate({
    "description": "The event type, must be `conversation.item.created`."
  }),
  "previous_item_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "The ID of the preceding item in the Conversation context, allows the\nclient to understand the order of the conversation. Can be `null` if the\nitem has no predecessor.\n"
      }),
      Schema.Null
    ])
  ),
  "item": RealtimeConversationItem
}).annotate({
  "description":
    "Returned when a conversation item is created. There are several scenarios that produce this event:\n  - The server is generating a Response, which if successful will produce\n    either one or two Items, which will be of type `message`\n    (role `assistant`) or type `function_call`.\n  - The input audio buffer has been committed, either by the client or the\n    server (in `server_vad` mode). The server will take the content of the\n    input audio buffer and add it to a new user message Item.\n  - The client has sent a `conversation.item.create` event to add a new Item\n    to the Conversation.\n"
})
export type RealtimeServerEventConversationItemDone = {
  readonly "event_id": string
  readonly "type": "conversation.item.done"
  readonly "previous_item_id"?: string | null
  readonly "item": RealtimeConversationItem
}
export const RealtimeServerEventConversationItemDone = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("conversation.item.done").annotate({
    "description": "The event type, must be `conversation.item.done`."
  }),
  "previous_item_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "The ID of the item that precedes this one, if any. This is used to\nmaintain ordering when items are inserted.\n"
      }),
      Schema.Null
    ])
  ),
  "item": RealtimeConversationItem
}).annotate({
  "description":
    "Returned when a conversation item is finalized.\n\nThe event will include the full content of the Item except for audio data, which can be retrieved separately with a `conversation.item.retrieve` event if needed.\n"
})
export type RealtimeServerEventConversationItemRetrieved = {
  readonly "event_id": string
  readonly "type": "conversation.item.retrieved"
  readonly "item": RealtimeConversationItem
}
export const RealtimeServerEventConversationItemRetrieved = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("conversation.item.retrieved").annotate({
    "description": "The event type, must be `conversation.item.retrieved`."
  }),
  "item": RealtimeConversationItem
}).annotate({
  "description":
    "Returned when a conversation item is retrieved with `conversation.item.retrieve`. This is provided as a way to fetch the server's representation of an item, for example to get access to the post-processed audio data after noise cancellation and VAD. It includes the full content of the Item, including audio data.\n"
})
export type RealtimeServerEventResponseOutputItemAdded = {
  readonly "event_id": string
  readonly "type": "response.output_item.added"
  readonly "response_id": string
  readonly "output_index": number
  readonly "item": RealtimeConversationItem
}
export const RealtimeServerEventResponseOutputItemAdded = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.output_item.added").annotate({
    "description": "The event type, must be `response.output_item.added`."
  }),
  "response_id": Schema.String.annotate({ "description": "The ID of the Response to which the item belongs." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the Response." }).check(
    Schema.isInt()
  ),
  "item": RealtimeConversationItem
}).annotate({ "description": "Returned when a new Item is created during Response generation." })
export type RealtimeServerEventResponseOutputItemDone = {
  readonly "event_id": string
  readonly "type": "response.output_item.done"
  readonly "response_id": string
  readonly "output_index": number
  readonly "item": RealtimeConversationItem
}
export const RealtimeServerEventResponseOutputItemDone = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.output_item.done").annotate({
    "description": "The event type, must be `response.output_item.done`."
  }),
  "response_id": Schema.String.annotate({ "description": "The ID of the Response to which the item belongs." }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item in the Response." }).check(
    Schema.isInt()
  ),
  "item": RealtimeConversationItem
}).annotate({
  "description":
    "Returned when an Item is done streaming. Also emitted when a Response is \ninterrupted, incomplete, or cancelled.\n"
})
export type AssistantObject = {
  readonly "id": string
  readonly "object": "assistant"
  readonly "created_at": number
  readonly "name": string | null
  readonly "description": string | null
  readonly "model": string
  readonly "instructions": string | null
  readonly "tools": ReadonlyArray<AssistantToolsCode | AssistantToolsFileSearch | AssistantToolsFunction>
  readonly "tool_resources"?: {
    readonly "code_interpreter"?: { readonly "file_ids"?: ReadonlyArray<string> }
    readonly "file_search"?: { readonly "vector_store_ids"?: ReadonlyArray<string> }
  } | null
  readonly "metadata": Metadata
  readonly "temperature"?: number | null
  readonly "top_p"?: number | null
  readonly "response_format"?: AssistantsApiResponseFormatOption | null
}
export const AssistantObject = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints." }),
  "object": Schema.Literal("assistant").annotate({ "description": "The object type, which is always `assistant`." }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the assistant was created."
  }).check(Schema.isInt()),
  "name": Schema.Union([
    Schema.String.annotate({ "description": "The name of the assistant. The maximum length is 256 characters.\n" })
      .check(Schema.isMaxLength(256)),
    Schema.Null
  ]),
  "description": Schema.Union([
    Schema.String.annotate({
      "description": "The description of the assistant. The maximum length is 512 characters.\n"
    }).check(Schema.isMaxLength(512)),
    Schema.Null
  ]),
  "model": Schema.String.annotate({
    "description":
      "ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.\n"
  }),
  "instructions": Schema.Union([
    Schema.String.annotate({
      "description": "The system instructions that the assistant uses. The maximum length is 256,000 characters.\n"
    }).check(Schema.isMaxLength(256000)),
    Schema.Null
  ]),
  "tools": Schema.Array(
    Schema.Union([AssistantToolsCode, AssistantToolsFileSearch, AssistantToolsFunction], { mode: "oneOf" })
  ).annotate({
    "description":
      "A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.\n"
  }).check(Schema.isMaxLength(128)),
  "tool_resources": Schema.optionalKey(Schema.Union([
    Schema.Struct({
      "code_interpreter": Schema.optionalKey(Schema.Struct({
        "file_ids": Schema.optionalKey(
          Schema.Array(Schema.String).annotate({
            "description":
              "A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter`` tool. There can be a maximum of 20 files associated with the tool.\n"
          }).check(Schema.isMaxLength(20))
        )
      })),
      "file_search": Schema.optionalKey(Schema.Struct({
        "vector_store_ids": Schema.optionalKey(
          Schema.Array(Schema.String).annotate({
            "description":
              "The ID of the [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"
          }).check(Schema.isMaxLength(1))
        )
      }))
    }).annotate({
      "description":
        "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"
    }),
    Schema.Null
  ])),
  "metadata": Metadata,
  "temperature": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(2)),
      Schema.Null
    ])
  ),
  "top_p": Schema.optionalKey(Schema.Union([
    Schema.Number.annotate({
      "description":
        "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"
    }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1)),
    Schema.Null
  ])),
  "response_format": Schema.optionalKey(Schema.Union([AssistantsApiResponseFormatOption, Schema.Null]))
}).annotate({ "title": "Assistant", "description": "Represents an `assistant` that can call the model and use tools." })
export type CreateAssistantRequest = {
  readonly "model": string | AssistantSupportedModels
  readonly "name"?: string | null
  readonly "description"?: string | null
  readonly "instructions"?: string | null
  readonly "reasoning_effort"?: ReasoningEffort
  readonly "tools"?: ReadonlyArray<AssistantToolsCode | AssistantToolsFileSearch | AssistantToolsFunction>
  readonly "tool_resources"?: {
    readonly "code_interpreter"?: { readonly "file_ids"?: ReadonlyArray<string> }
    readonly "file_search"?: { readonly "vector_store_ids": unknown; readonly [x: string]: unknown } | {
      readonly "vector_stores": unknown
      readonly [x: string]: unknown
    }
  } | null
  readonly "metadata"?: Metadata
  readonly "temperature"?: number | null
  readonly "top_p"?: number | null
  readonly "response_format"?: AssistantsApiResponseFormatOption | null
}
export const CreateAssistantRequest = Schema.Struct({
  "model": Schema.Union([Schema.String, AssistantSupportedModels]).annotate({
    "description":
      "ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.\n"
  }),
  "name": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "The name of the assistant. The maximum length is 256 characters.\n" })
        .check(Schema.isMaxLength(256)),
      Schema.Null
    ])
  ),
  "description": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "The description of the assistant. The maximum length is 512 characters.\n"
      }).check(Schema.isMaxLength(512)),
      Schema.Null
    ])
  ),
  "instructions": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "The system instructions that the assistant uses. The maximum length is 256,000 characters.\n"
      }).check(Schema.isMaxLength(256000)),
      Schema.Null
    ])
  ),
  "reasoning_effort": Schema.optionalKey(ReasoningEffort),
  "tools": Schema.optionalKey(
    Schema.Array(
      Schema.Union([AssistantToolsCode, AssistantToolsFileSearch, AssistantToolsFunction], { mode: "oneOf" })
    ).annotate({
      "description":
        "A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.\n"
    }).check(Schema.isMaxLength(128))
  ),
  "tool_resources": Schema.optionalKey(Schema.Union([
    Schema.Struct({
      "code_interpreter": Schema.optionalKey(Schema.Struct({
        "file_ids": Schema.optionalKey(
          Schema.Array(Schema.String).annotate({
            "description":
              "A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"
          }).check(Schema.isMaxLength(20))
        )
      })),
      "file_search": Schema.optionalKey(
        Schema.Union([
          Schema.StructWithRest(Schema.Struct({ "vector_store_ids": Schema.Unknown }), [
            Schema.Record(Schema.String, Schema.Json)
          ]),
          Schema.StructWithRest(Schema.Struct({ "vector_stores": Schema.Unknown }), [
            Schema.Record(Schema.String, Schema.Json)
          ])
        ], { mode: "oneOf" })
      )
    }).annotate({
      "description":
        "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"
    }),
    Schema.Null
  ])),
  "metadata": Schema.optionalKey(Metadata),
  "temperature": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(2)),
      Schema.Null
    ])
  ),
  "top_p": Schema.optionalKey(Schema.Union([
    Schema.Number.annotate({
      "description":
        "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"
    }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1)),
    Schema.Null
  ])),
  "response_format": Schema.optionalKey(Schema.Union([AssistantsApiResponseFormatOption, Schema.Null]))
})
export type CreateRunRequest = {
  readonly "assistant_id": string
  readonly "model"?: string | AssistantSupportedModels | null
  readonly "reasoning_effort"?: ReasoningEffort
  readonly "instructions"?: string | null
  readonly "additional_instructions"?: string | null
  readonly "additional_messages"?: ReadonlyArray<unknown> | null
  readonly "tools"?: ReadonlyArray<unknown> | null
  readonly "metadata"?: Metadata
  readonly "temperature"?: number | null
  readonly "top_p"?: number | null
  readonly "stream"?: boolean | null
  readonly "max_prompt_tokens"?: number | null
  readonly "max_completion_tokens"?: number | null
  readonly "truncation_strategy"?: {
    readonly "type": "auto" | "last_messages"
    readonly "last_messages"?: number | null
  }
  readonly "tool_choice"?: "none" | "auto" | "required" | {
    readonly "type": "function" | "code_interpreter" | "file_search"
    readonly "function"?: { readonly "name": string }
  }
  readonly "parallel_tool_calls"?: ParallelToolCalls
  readonly "response_format"?: AssistantsApiResponseFormatOption | null
}
export const CreateRunRequest = Schema.Struct({
  "assistant_id": Schema.String.annotate({
    "description": "The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run."
  }),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.Union([Schema.String, AssistantSupportedModels]).annotate({
        "description":
          "The ID of the [Model](/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used."
      }),
      Schema.Null
    ])
  ),
  "reasoning_effort": Schema.optionalKey(ReasoningEffort),
  "instructions": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "Overrides the [instructions](/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis."
    })
  ),
  "additional_instructions": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions."
    })
  ),
  "additional_messages": Schema.optionalKey(
    Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]).annotate({
      "description": "Adds additional messages to the thread before creating the run."
    })
  ),
  "tools": Schema.optionalKey(
    Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]).annotate({
      "description":
        "Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis."
    })
  ),
  "metadata": Schema.optionalKey(Metadata),
  "temperature": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({
      "description":
        "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"
    })
  ),
  "top_p": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({
      "description":
        "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"
    })
  ),
  "stream": Schema.optionalKey(
    Schema.Union([Schema.Boolean, Schema.Null]).annotate({
      "description":
        "If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.\n"
    })
  ),
  "max_prompt_tokens": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"
    })
  ),
  "max_completion_tokens": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"
    })
  ),
  "truncation_strategy": Schema.optionalKey(Schema.Union([
    Schema.Struct({
      "type": Schema.Literals(["auto", "last_messages"]).annotate({
        "description":
          "The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`."
      }),
      "last_messages": Schema.optionalKey(
        Schema.Union([
          Schema.Number.annotate({
            "description":
              "The number of most recent messages from the thread when constructing the context for the run."
          }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)),
          Schema.Null
        ])
      )
    }).annotate({
      "title": "Thread Truncation Controls",
      "description":
        "Controls for how a thread will be truncated prior to the run. Use this to control the initial context window of the run."
    })
  ])),
  "tool_choice": Schema.optionalKey(
    Schema.Union([
      Schema.Union([Schema.Literal("none"), Schema.Literal("auto"), Schema.Literal("required")]).annotate({
        "description":
          "`none` means the model will not call any tools and instead generates a message. `auto` means the model can pick between generating a message or calling one or more tools. `required` means the model must call one or more tools before responding to the user.\n"
      }),
      Schema.Union([
        Schema.Struct({
          "type": Schema.Literals(["function", "code_interpreter", "file_search"]).annotate({
            "description": "The type of the tool. If type is `function`, the function name must be set"
          }),
          "function": Schema.optionalKey(
            Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the function to call." }) })
          )
        }).annotate({
          "description": "Specifies a tool the model should use. Use to force the model to call a specific tool."
        })
      ])
    ]).annotate({
      "description":
        "Controls which (if any) tool is called by the model.\n`none` means the model will not call any tools and instead generates a message.\n`auto` is the default value and means the model can pick between generating a message or calling one or more tools.\n`required` means the model must call one or more tools before responding to the user.\nSpecifying a particular tool like `{\"type\": \"file_search\"}` or `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool.\n"
    })
  ),
  "parallel_tool_calls": Schema.optionalKey(ParallelToolCalls),
  "response_format": Schema.optionalKey(Schema.Union([AssistantsApiResponseFormatOption, Schema.Null]))
})
export type CreateThreadAndRunRequest = {
  readonly "assistant_id": string
  readonly "thread"?: CreateThreadRequest
  readonly "model"?:
    | string
    | "gpt-5"
    | "gpt-5-mini"
    | "gpt-5-nano"
    | "gpt-5-2025-08-07"
    | "gpt-5-mini-2025-08-07"
    | "gpt-5-nano-2025-08-07"
    | "gpt-4.1"
    | "gpt-4.1-mini"
    | "gpt-4.1-nano"
    | "gpt-4.1-2025-04-14"
    | "gpt-4.1-mini-2025-04-14"
    | "gpt-4.1-nano-2025-04-14"
    | "gpt-4o"
    | "gpt-4o-2024-11-20"
    | "gpt-4o-2024-08-06"
    | "gpt-4o-2024-05-13"
    | "gpt-4o-mini"
    | "gpt-4o-mini-2024-07-18"
    | "gpt-4.5-preview"
    | "gpt-4.5-preview-2025-02-27"
    | "gpt-4-turbo"
    | "gpt-4-turbo-2024-04-09"
    | "gpt-4-0125-preview"
    | "gpt-4-turbo-preview"
    | "gpt-4-1106-preview"
    | "gpt-4-vision-preview"
    | "gpt-4"
    | "gpt-4-0314"
    | "gpt-4-0613"
    | "gpt-4-32k"
    | "gpt-4-32k-0314"
    | "gpt-4-32k-0613"
    | "gpt-3.5-turbo"
    | "gpt-3.5-turbo-16k"
    | "gpt-3.5-turbo-0613"
    | "gpt-3.5-turbo-1106"
    | "gpt-3.5-turbo-0125"
    | "gpt-3.5-turbo-16k-0613"
    | null
  readonly "instructions"?: string | null
  readonly "tools"?: ReadonlyArray<unknown> | null
  readonly "tool_resources"?: {} | null
  readonly "metadata"?: Metadata
  readonly "temperature"?: number | null
  readonly "top_p"?: number | null
  readonly "stream"?: boolean | null
  readonly "max_prompt_tokens"?: number | null
  readonly "max_completion_tokens"?: number | null
  readonly "truncation_strategy"?: {
    readonly "type": "auto" | "last_messages"
    readonly "last_messages"?: number | null
  }
  readonly "tool_choice"?: "none" | "auto" | "required" | {
    readonly "type": "function" | "code_interpreter" | "file_search"
    readonly "function"?: { readonly "name": string }
  }
  readonly "parallel_tool_calls"?: ParallelToolCalls
  readonly "response_format"?: AssistantsApiResponseFormatOption | null
}
export const CreateThreadAndRunRequest = Schema.Struct({
  "assistant_id": Schema.String.annotate({
    "description": "The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run."
  }),
  "thread": Schema.optionalKey(CreateThreadRequest),
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        Schema.String,
        Schema.Literals([
          "gpt-5",
          "gpt-5-mini",
          "gpt-5-nano",
          "gpt-5-2025-08-07",
          "gpt-5-mini-2025-08-07",
          "gpt-5-nano-2025-08-07",
          "gpt-4.1",
          "gpt-4.1-mini",
          "gpt-4.1-nano",
          "gpt-4.1-2025-04-14",
          "gpt-4.1-mini-2025-04-14",
          "gpt-4.1-nano-2025-04-14",
          "gpt-4o",
          "gpt-4o-2024-11-20",
          "gpt-4o-2024-08-06",
          "gpt-4o-2024-05-13",
          "gpt-4o-mini",
          "gpt-4o-mini-2024-07-18",
          "gpt-4.5-preview",
          "gpt-4.5-preview-2025-02-27",
          "gpt-4-turbo",
          "gpt-4-turbo-2024-04-09",
          "gpt-4-0125-preview",
          "gpt-4-turbo-preview",
          "gpt-4-1106-preview",
          "gpt-4-vision-preview",
          "gpt-4",
          "gpt-4-0314",
          "gpt-4-0613",
          "gpt-4-32k",
          "gpt-4-32k-0314",
          "gpt-4-32k-0613",
          "gpt-3.5-turbo",
          "gpt-3.5-turbo-16k",
          "gpt-3.5-turbo-0613",
          "gpt-3.5-turbo-1106",
          "gpt-3.5-turbo-0125",
          "gpt-3.5-turbo-16k-0613"
        ])
      ]).annotate({
        "description":
          "The ID of the [Model](/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used."
      }),
      Schema.Null
    ])
  ),
  "instructions": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis."
    })
  ),
  "tools": Schema.optionalKey(
    Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]).annotate({
      "description":
        "Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis."
    })
  ),
  "tool_resources": Schema.optionalKey(
    Schema.Union([Schema.Struct({}), Schema.Null]).annotate({
      "description":
        "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"
    })
  ),
  "metadata": Schema.optionalKey(Metadata),
  "temperature": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({
      "description":
        "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"
    })
  ),
  "top_p": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({
      "description":
        "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"
    })
  ),
  "stream": Schema.optionalKey(
    Schema.Union([Schema.Boolean, Schema.Null]).annotate({
      "description":
        "If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.\n"
    })
  ),
  "max_prompt_tokens": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"
    })
  ),
  "max_completion_tokens": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"
    })
  ),
  "truncation_strategy": Schema.optionalKey(Schema.Union([
    Schema.Struct({
      "type": Schema.Literals(["auto", "last_messages"]).annotate({
        "description":
          "The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`."
      }),
      "last_messages": Schema.optionalKey(
        Schema.Union([
          Schema.Number.annotate({
            "description":
              "The number of most recent messages from the thread when constructing the context for the run."
          }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)),
          Schema.Null
        ])
      )
    }).annotate({
      "title": "Thread Truncation Controls",
      "description":
        "Controls for how a thread will be truncated prior to the run. Use this to control the initial context window of the run."
    })
  ])),
  "tool_choice": Schema.optionalKey(
    Schema.Union([
      Schema.Union([Schema.Literal("none"), Schema.Literal("auto"), Schema.Literal("required")]).annotate({
        "description":
          "`none` means the model will not call any tools and instead generates a message. `auto` means the model can pick between generating a message or calling one or more tools. `required` means the model must call one or more tools before responding to the user.\n"
      }),
      Schema.Union([
        Schema.Struct({
          "type": Schema.Literals(["function", "code_interpreter", "file_search"]).annotate({
            "description": "The type of the tool. If type is `function`, the function name must be set"
          }),
          "function": Schema.optionalKey(
            Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the function to call." }) })
          )
        }).annotate({
          "description": "Specifies a tool the model should use. Use to force the model to call a specific tool."
        })
      ])
    ]).annotate({
      "description":
        "Controls which (if any) tool is called by the model.\n`none` means the model will not call any tools and instead generates a message.\n`auto` is the default value and means the model can pick between generating a message or calling one or more tools.\n`required` means the model must call one or more tools before responding to the user.\nSpecifying a particular tool like `{\"type\": \"file_search\"}` or `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool.\n"
    })
  ),
  "parallel_tool_calls": Schema.optionalKey(ParallelToolCalls),
  "response_format": Schema.optionalKey(Schema.Union([AssistantsApiResponseFormatOption, Schema.Null]))
})
export type ModifyAssistantRequest = {
  readonly "model"?: string | AssistantSupportedModels
  readonly "reasoning_effort"?: ReasoningEffort
  readonly "name"?: string | null
  readonly "description"?: string | null
  readonly "instructions"?: string | null
  readonly "tools"?: ReadonlyArray<AssistantToolsCode | AssistantToolsFileSearch | AssistantToolsFunction>
  readonly "tool_resources"?: {
    readonly "code_interpreter"?: { readonly "file_ids"?: ReadonlyArray<string> }
    readonly "file_search"?: { readonly "vector_store_ids"?: ReadonlyArray<string> }
  } | null
  readonly "metadata"?: Metadata
  readonly "temperature"?: number | null
  readonly "top_p"?: number | null
  readonly "response_format"?: AssistantsApiResponseFormatOption | null
}
export const ModifyAssistantRequest = Schema.Struct({
  "model": Schema.optionalKey(
    Schema.Union([Schema.String, AssistantSupportedModels]).annotate({
      "description":
        "ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.\n"
    })
  ),
  "reasoning_effort": Schema.optionalKey(ReasoningEffort),
  "name": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "The name of the assistant. The maximum length is 256 characters.\n" })
        .check(Schema.isMaxLength(256)),
      Schema.Null
    ])
  ),
  "description": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "The description of the assistant. The maximum length is 512 characters.\n"
      }).check(Schema.isMaxLength(512)),
      Schema.Null
    ])
  ),
  "instructions": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description": "The system instructions that the assistant uses. The maximum length is 256,000 characters.\n"
      }).check(Schema.isMaxLength(256000)),
      Schema.Null
    ])
  ),
  "tools": Schema.optionalKey(
    Schema.Array(
      Schema.Union([AssistantToolsCode, AssistantToolsFileSearch, AssistantToolsFunction], { mode: "oneOf" })
    ).annotate({
      "description":
        "A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.\n"
    }).check(Schema.isMaxLength(128))
  ),
  "tool_resources": Schema.optionalKey(Schema.Union([
    Schema.Struct({
      "code_interpreter": Schema.optionalKey(Schema.Struct({
        "file_ids": Schema.optionalKey(
          Schema.Array(Schema.String).annotate({
            "description":
              "Overrides the list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"
          }).check(Schema.isMaxLength(20))
        )
      })),
      "file_search": Schema.optionalKey(Schema.Struct({
        "vector_store_ids": Schema.optionalKey(
          Schema.Array(Schema.String).annotate({
            "description":
              "Overrides the [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"
          }).check(Schema.isMaxLength(1))
        )
      }))
    }).annotate({
      "description":
        "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"
    }),
    Schema.Null
  ])),
  "metadata": Schema.optionalKey(Metadata),
  "temperature": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(2)),
      Schema.Null
    ])
  ),
  "top_p": Schema.optionalKey(Schema.Union([
    Schema.Number.annotate({
      "description":
        "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"
    }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1)),
    Schema.Null
  ])),
  "response_format": Schema.optionalKey(Schema.Union([AssistantsApiResponseFormatOption, Schema.Null]))
})
export type RunObject = {
  readonly "id": string
  readonly "object": "thread.run"
  readonly "created_at": number
  readonly "thread_id": string
  readonly "assistant_id": string
  readonly "status":
    | "queued"
    | "in_progress"
    | "requires_action"
    | "cancelling"
    | "cancelled"
    | "failed"
    | "completed"
    | "incomplete"
    | "expired"
  readonly "required_action": {} | null
  readonly "last_error": {} | null
  readonly "expires_at": number | null
  readonly "started_at": number | null
  readonly "cancelled_at": number | null
  readonly "failed_at": number | null
  readonly "completed_at": number | null
  readonly "incomplete_details": {} | null
  readonly "model": string
  readonly "instructions": string
  readonly "tools": ReadonlyArray<AssistantToolsCode | AssistantToolsFileSearch | AssistantToolsFunction>
  readonly "metadata": Metadata
  readonly "usage": RunCompletionUsage
  readonly "temperature"?: number | null
  readonly "top_p"?: number | null
  readonly "max_prompt_tokens": number | null
  readonly "max_completion_tokens": number | null
  readonly "truncation_strategy": {
    readonly "type": "auto" | "last_messages"
    readonly "last_messages"?: number | null
  }
  readonly "tool_choice": "none" | "auto" | "required" | {
    readonly "type": "function" | "code_interpreter" | "file_search"
    readonly "function"?: { readonly "name": string }
  }
  readonly "parallel_tool_calls": ParallelToolCalls
  readonly "response_format": AssistantsApiResponseFormatOption | null
}
export const RunObject = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints." }),
  "object": Schema.Literal("thread.run").annotate({ "description": "The object type, which is always `thread.run`." }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the run was created."
  }).check(Schema.isInt()),
  "thread_id": Schema.String.annotate({
    "description": "The ID of the [thread](/docs/api-reference/threads) that was executed on as a part of this run."
  }),
  "assistant_id": Schema.String.annotate({
    "description": "The ID of the [assistant](/docs/api-reference/assistants) used for execution of this run."
  }),
  "status": Schema.Literals([
    "queued",
    "in_progress",
    "requires_action",
    "cancelling",
    "cancelled",
    "failed",
    "completed",
    "incomplete",
    "expired"
  ]).annotate({
    "description":
      "The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`."
  }),
  "required_action": Schema.Union([Schema.Struct({}), Schema.Null]).annotate({
    "description": "Details on the action required to continue the run. Will be `null` if no action is required."
  }),
  "last_error": Schema.Union([Schema.Struct({}), Schema.Null]).annotate({
    "description": "The last error associated with this run. Will be `null` if there are no errors."
  }),
  "expires_at": Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
    "description": "The Unix timestamp (in seconds) for when the run will expire."
  }),
  "started_at": Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
    "description": "The Unix timestamp (in seconds) for when the run was started."
  }),
  "cancelled_at": Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
    "description": "The Unix timestamp (in seconds) for when the run was cancelled."
  }),
  "failed_at": Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
    "description": "The Unix timestamp (in seconds) for when the run failed."
  }),
  "completed_at": Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
    "description": "The Unix timestamp (in seconds) for when the run was completed."
  }),
  "incomplete_details": Schema.Union([Schema.Struct({}), Schema.Null]).annotate({
    "description": "Details on why the run is incomplete. Will be `null` if the run is not incomplete."
  }),
  "model": Schema.String.annotate({
    "description": "The model that the [assistant](/docs/api-reference/assistants) used for this run."
  }),
  "instructions": Schema.String.annotate({
    "description": "The instructions that the [assistant](/docs/api-reference/assistants) used for this run."
  }),
  "tools": Schema.Array(
    Schema.Union([AssistantToolsCode, AssistantToolsFileSearch, AssistantToolsFunction], { mode: "oneOf" })
  ).annotate({
    "description": "The list of tools that the [assistant](/docs/api-reference/assistants) used for this run."
  }).check(Schema.isMaxLength(20)),
  "metadata": Metadata,
  "usage": RunCompletionUsage,
  "temperature": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({
      "description": "The sampling temperature used for this run. If not set, defaults to 1."
    })
  ),
  "top_p": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({
      "description": "The nucleus sampling value used for this run. If not set, defaults to 1."
    })
  ),
  "max_prompt_tokens": Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
    "description": "The maximum number of prompt tokens specified to have been used over the course of the run.\n"
  }),
  "max_completion_tokens": Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
    "description": "The maximum number of completion tokens specified to have been used over the course of the run.\n"
  }),
  "truncation_strategy": Schema.Union([
    Schema.Struct({
      "type": Schema.Literals(["auto", "last_messages"]).annotate({
        "description":
          "The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`."
      }),
      "last_messages": Schema.optionalKey(
        Schema.Union([
          Schema.Number.annotate({
            "description":
              "The number of most recent messages from the thread when constructing the context for the run."
          }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)),
          Schema.Null
        ])
      )
    }).annotate({
      "title": "Thread Truncation Controls",
      "description":
        "Controls for how a thread will be truncated prior to the run. Use this to control the initial context window of the run."
    })
  ]),
  "tool_choice": Schema.Union([
    Schema.Union([Schema.Literal("none"), Schema.Literal("auto"), Schema.Literal("required")]).annotate({
      "description":
        "`none` means the model will not call any tools and instead generates a message. `auto` means the model can pick between generating a message or calling one or more tools. `required` means the model must call one or more tools before responding to the user.\n"
    }),
    Schema.Union([
      Schema.Struct({
        "type": Schema.Literals(["function", "code_interpreter", "file_search"]).annotate({
          "description": "The type of the tool. If type is `function`, the function name must be set"
        }),
        "function": Schema.optionalKey(
          Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the function to call." }) })
        )
      }).annotate({
        "description": "Specifies a tool the model should use. Use to force the model to call a specific tool."
      })
    ])
  ]).annotate({
    "description":
      "Controls which (if any) tool is called by the model.\n`none` means the model will not call any tools and instead generates a message.\n`auto` is the default value and means the model can pick between generating a message or calling one or more tools.\n`required` means the model must call one or more tools before responding to the user.\nSpecifying a particular tool like `{\"type\": \"file_search\"}` or `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool.\n"
  }),
  "parallel_tool_calls": ParallelToolCalls,
  "response_format": Schema.Union([AssistantsApiResponseFormatOption, Schema.Null])
}).annotate({
  "title": "A run on a thread",
  "description": "Represents an execution run on a [thread](/docs/api-reference/threads)."
})
export type ResponseTextParam = {
  readonly "format"?: TextResponseFormatConfiguration
  readonly "verbosity"?: Verbosity
}
export const ResponseTextParam = Schema.Struct({
  "format": Schema.optionalKey(TextResponseFormatConfiguration),
  "verbosity": Schema.optionalKey(Verbosity)
}).annotate({
  "description":
    "Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](/docs/guides/text)\n- [Structured Outputs](/docs/guides/structured-outputs)\n"
})
export type RealtimeClientEventSessionUpdate = {
  readonly "event_id"?: string
  readonly "type": "session.update"
  readonly "session": RealtimeSessionCreateRequestGA | RealtimeTranscriptionSessionCreateRequestGA
}
export const RealtimeClientEventSessionUpdate = Schema.Struct({
  "event_id": Schema.optionalKey(
    Schema.String.annotate({
      "description":
        "Optional client-generated ID used to identify this event. This is an arbitrary string that a client may assign. It will be passed back if there is an error with the event, but the corresponding `session.updated` event will not include it."
    }).check(Schema.isMaxLength(512))
  ),
  "type": Schema.Literal("session.update").annotate({ "description": "The event type, must be `session.update`." }),
  "session": Schema.Union([RealtimeSessionCreateRequestGA, RealtimeTranscriptionSessionCreateRequestGA], {
    mode: "oneOf"
  }).annotate({
    "description": "Update the Realtime session. Choose either a realtime\nsession or a transcription session.\n"
  })
}).annotate({
  "description":
    "Send this event to update the sessions configuration.\nThe client may send this event at any time to update any field\nexcept for `voice` and `model`. `voice` can be updated only if there have been no other audio outputs yet.\n\nWhen the server receives a `session.update`, it will respond\nwith a `session.updated` event showing the full, effective configuration.\nOnly the fields that are present in the `session.update` are updated. To clear a field like\n`instructions`, pass an empty string. To clear a field like `tools`, pass an empty array.\nTo clear a field like `turn_detection`, pass `null`.\n"
})
export type RealtimeCreateClientSecretRequest = {
  readonly "expires_after"?: { readonly "anchor"?: "created_at"; readonly "seconds"?: number }
  readonly "session"?: RealtimeSessionCreateRequestGA | RealtimeTranscriptionSessionCreateRequestGA
}
export const RealtimeCreateClientSecretRequest = Schema.Struct({
  "expires_after": Schema.optionalKey(
    Schema.Struct({
      "anchor": Schema.optionalKey(
        Schema.Literal("created_at").annotate({
          "description":
            "The anchor point for the client secret expiration, meaning that `seconds` will be added to the `created_at` time of the client secret to produce an expiration timestamp. Only `created_at` is currently supported.\n"
        })
      ),
      "seconds": Schema.optionalKey(
        Schema.Number.annotate({
          "description":
            "The number of seconds from the anchor point to the expiration. Select a value between `10` and `7200` (2 hours). This default to 600 seconds (10 minutes) if not specified.\n"
        }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(10)).check(Schema.isLessThanOrEqualTo(7200))
      )
    }).annotate({
      "title": "Client secret expiration",
      "description":
        "Configuration for the client secret expiration. Expiration refers to the time after which\na client secret will no longer be valid for creating sessions. The session itself may\ncontinue after that time once started. A secret can be used to create multiple sessions\nuntil it expires.\n"
    })
  ),
  "session": Schema.optionalKey(
    Schema.Union([RealtimeSessionCreateRequestGA, RealtimeTranscriptionSessionCreateRequestGA], { mode: "oneOf" })
      .annotate({
        "title": "Session configuration",
        "description":
          "Session configuration to use for the client secret. Choose either a realtime\nsession or a transcription session.\n"
      })
  )
}).annotate({
  "title": "Realtime client secret creation request",
  "description":
    "Create a session and client secret for the Realtime API. The request can specify\neither a realtime or a transcription session configuration.\n[Learn more about the Realtime API](/docs/guides/realtime).\n"
})
export type RealtimeServerEventSessionCreated = {
  readonly "event_id": string
  readonly "type": "session.created"
  readonly "session": RealtimeSessionCreateRequestGA | RealtimeTranscriptionSessionCreateRequestGA
}
export const RealtimeServerEventSessionCreated = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("session.created").annotate({ "description": "The event type, must be `session.created`." }),
  "session": Schema.Union([RealtimeSessionCreateRequestGA, RealtimeTranscriptionSessionCreateRequestGA], {
    mode: "oneOf"
  }).annotate({ "description": "The session configuration." })
}).annotate({
  "description":
    "Returned when a Session is created. Emitted automatically when a new\nconnection is established as the first server event. This event will contain\nthe default Session configuration.\n"
})
export type RealtimeServerEventSessionUpdated = {
  readonly "event_id": string
  readonly "type": "session.updated"
  readonly "session": RealtimeSessionCreateRequestGA | RealtimeTranscriptionSessionCreateRequestGA
}
export const RealtimeServerEventSessionUpdated = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("session.updated").annotate({ "description": "The event type, must be `session.updated`." }),
  "session": Schema.Union([RealtimeSessionCreateRequestGA, RealtimeTranscriptionSessionCreateRequestGA], {
    mode: "oneOf"
  }).annotate({ "description": "The session configuration." })
}).annotate({
  "description": "Returned when a session is updated with a `session.update` event, unless\nthere is an error.\n"
})
export type RealtimeCreateClientSecretResponse = {
  readonly "value": string
  readonly "expires_at": number
  readonly "session": RealtimeSessionCreateResponseGA | RealtimeTranscriptionSessionCreateResponseGA
}
export const RealtimeCreateClientSecretResponse = Schema.Struct({
  "value": Schema.String.annotate({ "description": "The generated client secret value." }),
  "expires_at": Schema.Number.annotate({
    "description": "Expiration timestamp for the client secret, in seconds since epoch."
  }).check(Schema.isInt()),
  "session": Schema.Union([RealtimeSessionCreateResponseGA, RealtimeTranscriptionSessionCreateResponseGA], {
    mode: "oneOf"
  }).annotate({
    "title": "Session configuration",
    "description": "The session configuration for either a realtime or transcription session.\n"
  })
}).annotate({
  "title": "Realtime session and client secret",
  "description": "Response from creating a session and client secret for the Realtime API.\n"
})
export type RunStepDeltaObject = {
  readonly "id": string
  readonly "object": "thread.run.step.delta"
  readonly "delta": {
    readonly "step_details"?: RunStepDeltaStepDetailsMessageCreationObject | RunStepDeltaStepDetailsToolCallsObject
  }
}
export const RunStepDeltaObject = Schema.Struct({
  "id": Schema.String.annotate({
    "description": "The identifier of the run step, which can be referenced in API endpoints."
  }),
  "object": Schema.Literal("thread.run.step.delta").annotate({
    "description": "The object type, which is always `thread.run.step.delta`."
  }),
  "delta": Schema.Struct({
    "step_details": Schema.optionalKey(
      Schema.Union([RunStepDeltaStepDetailsMessageCreationObject, RunStepDeltaStepDetailsToolCallsObject], {
        mode: "oneOf"
      }).annotate({ "description": "The details of the run step." })
    )
  }).annotate({ "description": "The delta containing the fields that have changed on the run step." })
}).annotate({
  "title": "Run step delta object",
  "description": "Represents a run step delta i.e. any changed fields on a run step during streaming.\n"
})
export type CreateVectorStoreFileRequest = {
  readonly "file_id": string
  readonly "chunking_strategy"?: ChunkingStrategyRequestParam
  readonly "attributes"?: VectorStoreFileAttributes
}
export const CreateVectorStoreFileRequest = Schema.Struct({
  "file_id": Schema.String.annotate({
    "description":
      "A [File](/docs/api-reference/files) ID that the vector store should use. Useful for tools like `file_search` that can access files."
  }),
  "chunking_strategy": Schema.optionalKey(ChunkingStrategyRequestParam),
  "attributes": Schema.optionalKey(VectorStoreFileAttributes)
})
export type ListVectorStoreFilesResponse = {
  readonly "object": string
  readonly "data": ReadonlyArray<VectorStoreFileObject>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
  readonly [x: string]: unknown
}
export const ListVectorStoreFilesResponse = Schema.StructWithRest(
  Schema.Struct({
    "object": Schema.String,
    "data": Schema.Array(VectorStoreFileObject),
    "first_id": Schema.String,
    "last_id": Schema.String,
    "has_more": Schema.Boolean
  }),
  [Schema.Record(Schema.String, Schema.Json)]
)
export type CodeInterpreterTool = {
  readonly "type": "code_interpreter"
  readonly "container": string | AutoCodeInterpreterToolParam
}
export const CodeInterpreterTool = Schema.Struct({
  "type": Schema.Literal("code_interpreter").annotate({
    "description": "The type of the code interpreter tool. Always `code_interpreter`.\n"
  }),
  "container": Schema.Union([
    Schema.String.annotate({ "description": "The container ID." }),
    AutoCodeInterpreterToolParam
  ], { mode: "oneOf" }).annotate({
    "description":
      "The code interpreter container. Can be a container ID or an object that\nspecifies uploaded file IDs to make available to your code, along with an\noptional `memory_limit` setting.\n"
  })
}).annotate({
  "title": "Code interpreter",
  "description": "A tool that runs Python code to help generate a response to a prompt.\n"
})
export type FunctionShellToolParam = {
  readonly "type": "shell"
  readonly "environment"?: ContainerAutoParam | LocalEnvironmentParam | ContainerReferenceParam | null
}
export const FunctionShellToolParam = Schema.Struct({
  "type": Schema.Literal("shell").annotate({ "description": "The type of the shell tool. Always `shell`." }),
  "environment": Schema.optionalKey(
    Schema.Union([
      Schema.Union([ContainerAutoParam, LocalEnvironmentParam, ContainerReferenceParam], { mode: "oneOf" }),
      Schema.Null
    ])
  )
}).annotate({ "title": "Shell tool", "description": "A tool that allows the model to execute shell commands." })
export type EvalItemContent = EvalItemContentItem | EvalItemContentArray
export const EvalItemContent = Schema.Union([EvalItemContentItem, EvalItemContentArray], { mode: "oneOf" }).annotate({
  "title": "Eval content",
  "description":
    "Inputs to the model - can contain template strings. Supports text, output text, input images, and input audio, either as a single item or an array of items.\n"
})
export type OutputMessageContent = OutputTextContent | RefusalContent
export const OutputMessageContent = Schema.Union([OutputTextContent, RefusalContent], { mode: "oneOf" })
export type ResponseContentPartAddedEvent = {
  readonly "type": "response.content_part.added"
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
  readonly "part": OutputTextContent | RefusalContent | ReasoningTextContent
  readonly "sequence_number": number
}
export const ResponseContentPartAddedEvent = Schema.Struct({
  "type": Schema.Literal("response.content_part.added").annotate({
    "description": "The type of the event. Always `response.content_part.added`.\n"
  }),
  "item_id": Schema.String.annotate({
    "description": "The ID of the output item that the content part was added to.\n"
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item that the content part was added to.\n"
  }).check(Schema.isInt()),
  "content_index": Schema.Number.annotate({ "description": "The index of the content part that was added.\n" }).check(
    Schema.isInt()
  ),
  "part": Schema.Union([OutputTextContent, RefusalContent, ReasoningTextContent], { mode: "oneOf" }).annotate({
    "description": "The content part that was added.\n"
  }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  )
}).annotate({ "description": "Emitted when a new content part is added." })
export type ResponseContentPartDoneEvent = {
  readonly "type": "response.content_part.done"
  readonly "item_id": string
  readonly "output_index": number
  readonly "content_index": number
  readonly "sequence_number": number
  readonly "part": OutputTextContent | RefusalContent | ReasoningTextContent
}
export const ResponseContentPartDoneEvent = Schema.Struct({
  "type": Schema.Literal("response.content_part.done").annotate({
    "description": "The type of the event. Always `response.content_part.done`.\n"
  }),
  "item_id": Schema.String.annotate({
    "description": "The ID of the output item that the content part was added to.\n"
  }),
  "output_index": Schema.Number.annotate({
    "description": "The index of the output item that the content part was added to.\n"
  }).check(Schema.isInt()),
  "content_index": Schema.Number.annotate({ "description": "The index of the content part that is done.\n" }).check(
    Schema.isInt()
  ),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  ),
  "part": Schema.Union([OutputTextContent, RefusalContent, ReasoningTextContent], { mode: "oneOf" }).annotate({
    "description": "The content part that is done.\n"
  })
}).annotate({ "description": "Emitted when a content part is done." })
export type Message = {
  readonly "type": "message"
  readonly "id": string
  readonly "status": "in_progress" | "completed" | "incomplete"
  readonly "role": "unknown" | "user" | "assistant" | "system" | "critic" | "discriminator" | "developer" | "tool"
  readonly "content": ReadonlyArray<
    | InputTextContent
    | OutputTextContent
    | TextContent
    | SummaryTextContent
    | ReasoningTextContent
    | RefusalContent
    | InputImageContent
    | ComputerScreenshotContent
    | InputFileContent
  >
}
export const Message = Schema.Struct({
  "type": Schema.Literal("message").annotate({ "description": "The type of the message. Always set to `message`." }),
  "id": Schema.String.annotate({ "description": "The unique ID of the message." }),
  "status": Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
    "description":
      "The status of item. One of `in_progress`, `completed`, or `incomplete`. Populated when items are returned via API."
  }),
  "role": Schema.Literals(["unknown", "user", "assistant", "system", "critic", "discriminator", "developer", "tool"])
    .annotate({
      "description":
        "The role of the message. One of `unknown`, `user`, `assistant`, `system`, `critic`, `discriminator`, `developer`, or `tool`."
    }),
  "content": Schema.Array(
    Schema.Union([
      InputTextContent,
      OutputTextContent,
      TextContent,
      SummaryTextContent,
      ReasoningTextContent,
      RefusalContent,
      InputImageContent,
      ComputerScreenshotContent,
      InputFileContent
    ], { mode: "oneOf" }).annotate({ "description": "A content part that makes up an input or output item." })
  ).annotate({ "description": "The content of the message" })
}).annotate({ "title": "Message", "description": "A message to or from the model." })
export type EasyInputMessage = {
  readonly "role": "user" | "assistant" | "system" | "developer"
  readonly "content": string | InputMessageContentList
  readonly "phase"?: MessagePhase | null
  readonly "type"?: "message"
}
export const EasyInputMessage = Schema.Struct({
  "role": Schema.Literals(["user", "assistant", "system", "developer"]).annotate({
    "description": "The role of the message input. One of `user`, `assistant`, `system`, or\n`developer`.\n"
  }),
  "content": Schema.Union([
    Schema.String.annotate({ "title": "Text input", "description": "A text input to the model.\n" }),
    InputMessageContentList
  ], { mode: "oneOf" }).annotate({
    "description":
      "Text, image, or audio input to the model, used to generate a response.\nCan also contain previous assistant responses.\n"
  }),
  "phase": Schema.optionalKey(Schema.Union([MessagePhase, Schema.Null])),
  "type": Schema.optionalKey(
    Schema.Literal("message").annotate({ "description": "The type of the message input. Always `message`.\n" })
  )
}).annotate({
  "title": "Input message",
  "description":
    "A message input to the model with a role indicating instruction following\nhierarchy. Instructions given with the `developer` or `system` role take\nprecedence over instructions given with the `user` role. Messages with the\n`assistant` role are presumed to have been generated by the model in previous\ninteractions.\n"
})
export type InputMessage = {
  readonly "type"?: "message"
  readonly "role": "user" | "system" | "developer"
  readonly "status"?: "in_progress" | "completed" | "incomplete"
  readonly "content": InputMessageContentList
}
export const InputMessage = Schema.Struct({
  "type": Schema.optionalKey(
    Schema.Literal("message").annotate({ "description": "The type of the message input. Always set to `message`.\n" })
  ),
  "role": Schema.Literals(["user", "system", "developer"]).annotate({
    "description": "The role of the message input. One of `user`, `system`, or `developer`.\n"
  }),
  "status": Schema.optionalKey(
    Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
      "description":
        "The status of item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"
    })
  ),
  "content": InputMessageContentList
}).annotate({
  "title": "Input message",
  "description":
    "A message input to the model with a role indicating instruction following\nhierarchy. Instructions given with the `developer` or `system` role take\nprecedence over instructions given with the `user` role.\n"
})
export type InputMessageResource = {
  readonly "type"?: "message"
  readonly "role": "user" | "system" | "developer"
  readonly "status"?: "in_progress" | "completed" | "incomplete"
  readonly "content": InputMessageContentList
  readonly "id": string
}
export const InputMessageResource = Schema.Struct({
  "type": Schema.optionalKey(
    Schema.Literal("message").annotate({ "description": "The type of the message input. Always set to `message`.\n" })
  ),
  "role": Schema.Literals(["user", "system", "developer"]).annotate({
    "description": "The role of the message input. One of `user`, `system`, or `developer`.\n"
  }),
  "status": Schema.optionalKey(
    Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
      "description":
        "The status of item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"
    })
  ),
  "content": InputMessageContentList,
  "id": Schema.String.annotate({ "description": "The unique ID of the message input.\n" })
}).annotate({
  "title": "Input message",
  "description":
    "A message input to the model with a role indicating instruction following\nhierarchy. Instructions given with the `developer` or `system` role take\nprecedence over instructions given with the `user` role.\n"
})
export type ComputerToolCall = {
  readonly "type": "computer_call"
  readonly "id": string
  readonly "call_id": string
  readonly "action": ComputerAction
  readonly "pending_safety_checks": ReadonlyArray<ComputerCallSafetyCheckParam>
  readonly "status": "in_progress" | "completed" | "incomplete"
}
export const ComputerToolCall = Schema.Struct({
  "type": Schema.Literal("computer_call").annotate({
    "description": "The type of the computer call. Always `computer_call`."
  }),
  "id": Schema.String.annotate({ "description": "The unique ID of the computer call." }),
  "call_id": Schema.String.annotate({
    "description": "An identifier used when responding to the tool call with output.\n"
  }),
  "action": ComputerAction,
  "pending_safety_checks": Schema.Array(ComputerCallSafetyCheckParam).annotate({
    "description": "The pending safety checks for the computer call.\n"
  }),
  "status": Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
    "description":
      "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"
  })
}).annotate({
  "title": "Computer tool call",
  "description":
    "A tool call to a computer use tool. See the\n[computer use guide](/docs/guides/tools-computer-use) for more information.\n"
})
export type ThreadItem =
  | UserMessageItem
  | AssistantMessageItem
  | WidgetMessageItem
  | ClientToolCallItem
  | TaskItem
  | TaskGroupItem
export const ThreadItem = Schema.Union([
  UserMessageItem,
  AssistantMessageItem,
  WidgetMessageItem,
  ClientToolCallItem,
  TaskItem,
  TaskGroupItem
], { mode: "oneOf" }).annotate({ "title": "The thread item" })
export type ListAuditLogsResponse = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<AuditLog>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const ListAuditLogsResponse = Schema.Struct({
  "object": Schema.Literal("list"),
  "data": Schema.Array(AuditLog),
  "first_id": Schema.String,
  "last_id": Schema.String,
  "has_more": Schema.Boolean
})
export type ChatCompletionList = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<CreateChatCompletionResponse>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const ChatCompletionList = Schema.Struct({
  "object": Schema.Literal("list").annotate({
    "description": "The type of this object. It is always set to \"list\".\n"
  }),
  "data": Schema.Array(CreateChatCompletionResponse).annotate({
    "description": "An array of chat completion objects.\n"
  }),
  "first_id": Schema.String.annotate({
    "description": "The identifier of the first chat completion in the data array."
  }),
  "last_id": Schema.String.annotate({ "description": "The identifier of the last chat completion in the data array." }),
  "has_more": Schema.Boolean.annotate({ "description": "Indicates whether there are more Chat Completions available." })
}).annotate({ "title": "ChatCompletionList", "description": "An object representing a list of Chat Completions.\n" })
export type CreateChatCompletionRequest = {
  readonly "metadata"?: Metadata
  readonly "top_logprobs"?: number
  readonly "temperature"?: number | null
  readonly "top_p"?: number | null
  readonly "user"?: string | null
  readonly "safety_identifier"?: string | null
  readonly "prompt_cache_key"?: string | null
  readonly "service_tier"?: ServiceTier
  readonly "prompt_cache_retention"?: "in-memory" | "24h" | null
  readonly "messages": ReadonlyArray<ChatCompletionRequestMessage>
  readonly "model":
    | string
    | "gpt-5.2"
    | "gpt-5.2-2025-12-11"
    | "gpt-5.2-chat-latest"
    | "gpt-5.2-pro"
    | "gpt-5.2-pro-2025-12-11"
    | "gpt-5.1"
    | "gpt-5.1-2025-11-13"
    | "gpt-5.1-codex"
    | "gpt-5.1-mini"
    | "gpt-5.1-chat-latest"
    | "gpt-5"
    | "gpt-5-mini"
    | "gpt-5-nano"
    | "gpt-5-2025-08-07"
    | "gpt-5-mini-2025-08-07"
    | "gpt-5-nano-2025-08-07"
    | "gpt-5-chat-latest"
    | "gpt-4.1"
    | "gpt-4.1-mini"
    | "gpt-4.1-nano"
    | "gpt-4.1-2025-04-14"
    | "gpt-4.1-mini-2025-04-14"
    | "gpt-4.1-nano-2025-04-14"
    | "o4-mini"
    | "o4-mini-2025-04-16"
    | "o3"
    | "o3-2025-04-16"
    | "o3-mini"
    | "o3-mini-2025-01-31"
    | "o1"
    | "o1-2024-12-17"
    | "o1-preview"
    | "o1-preview-2024-09-12"
    | "o1-mini"
    | "o1-mini-2024-09-12"
    | "gpt-4o"
    | "gpt-4o-2024-11-20"
    | "gpt-4o-2024-08-06"
    | "gpt-4o-2024-05-13"
    | "gpt-4o-audio-preview"
    | "gpt-4o-audio-preview-2024-10-01"
    | "gpt-4o-audio-preview-2024-12-17"
    | "gpt-4o-audio-preview-2025-06-03"
    | "gpt-4o-mini-audio-preview"
    | "gpt-4o-mini-audio-preview-2024-12-17"
    | "gpt-4o-search-preview"
    | "gpt-4o-mini-search-preview"
    | "gpt-4o-search-preview-2025-03-11"
    | "gpt-4o-mini-search-preview-2025-03-11"
    | "chatgpt-4o-latest"
    | "codex-mini-latest"
    | "gpt-4o-mini"
    | "gpt-4o-mini-2024-07-18"
    | "gpt-4-turbo"
    | "gpt-4-turbo-2024-04-09"
    | "gpt-4-0125-preview"
    | "gpt-4-turbo-preview"
    | "gpt-4-1106-preview"
    | "gpt-4-vision-preview"
    | "gpt-4"
    | "gpt-4-0314"
    | "gpt-4-0613"
    | "gpt-4-32k"
    | "gpt-4-32k-0314"
    | "gpt-4-32k-0613"
    | "gpt-3.5-turbo"
    | "gpt-3.5-turbo-16k"
    | "gpt-3.5-turbo-0301"
    | "gpt-3.5-turbo-0613"
    | "gpt-3.5-turbo-1106"
    | "gpt-3.5-turbo-0125"
    | "gpt-3.5-turbo-16k-0613"
  readonly "modalities"?: ResponseModalities
  readonly "verbosity"?: Verbosity
  readonly "reasoning_effort"?: ReasoningEffort
  readonly "max_completion_tokens"?: number | null
  readonly "frequency_penalty"?: number | null
  readonly "presence_penalty"?: number | null
  readonly "web_search_options"?: {
    readonly "user_location"?: {} | null
    readonly "search_context_size"?: WebSearchContextSize
  }
  readonly "response_format"?: ResponseFormatText | ResponseFormatJsonSchema | ResponseFormatJsonObject
  readonly "audio"?: {} | null
  readonly "store"?: boolean | null
  readonly "stream"?: boolean | null
  readonly "stop"?: StopConfiguration
  readonly "logit_bias"?: {} | null
  readonly "logprobs"?: boolean | null
  readonly "max_tokens"?: number | null
  readonly "n"?: number | null
  readonly "prediction"?: PredictionContent | null
  readonly "seed"?: number | null
  readonly "stream_options"?: ChatCompletionStreamOptions
  readonly "tools"?: ReadonlyArray<ChatCompletionTool | CustomToolChatCompletions>
  readonly "tool_choice"?: ChatCompletionToolChoiceOption
  readonly "parallel_tool_calls"?: ParallelToolCalls
  readonly "function_call"?: "none" | "auto" | ChatCompletionFunctionCallOption
  readonly "functions"?: ReadonlyArray<ChatCompletionFunctions>
}
export const CreateChatCompletionRequest = Schema.Struct({
  "metadata": Schema.optionalKey(Metadata),
  "top_logprobs": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        Schema.Number.check(Schema.isInt()).check(
          Schema.makeFilterGroup([
            Schema.isGreaterThanOrEqualTo(0),
            Schema.isLessThanOrEqualTo(20),
            Schema.makeFilterGroup([Schema.isGreaterThanOrEqualTo(0), Schema.isLessThanOrEqualTo(20)], {
              "description":
                "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"
            })
          ], {
            "description":
              "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"
          })
        )
      ]).annotate({
        "description":
          "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n`logprobs` must be set to `true` if this parameter is used.\n"
      })
    ])
  ),
  "temperature": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(2)),
      Schema.Null
    ])
  ),
  "top_p": Schema.optionalKey(Schema.Union([
    Schema.Number.annotate({
      "description":
        "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"
    }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1)),
    Schema.Null
  ])),
  "user": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "This field is being replaced by `safety_identifier` and `prompt_cache_key`. Use `prompt_cache_key` instead to maintain caching optimizations.\nA stable identifier for your end-users.\nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
    })
  ),
  "safety_identifier": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies.\nThe IDs should be a string that uniquely identifies each user, with a maximum length of 64 characters. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
    })
  ),
  "prompt_cache_key": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the `user` field. [Learn more](/docs/guides/prompt-caching).\n"
    })
  ),
  "service_tier": Schema.optionalKey(ServiceTier),
  "prompt_cache_retention": Schema.optionalKey(
    Schema.Union([
      Schema.Literals(["in-memory", "24h"]).annotate({
        "description":
          "The retention policy for the prompt cache. Set to `24h` to enable extended prompt caching, which keeps cached prefixes active for longer, up to a maximum of 24 hours. [Learn more](/docs/guides/prompt-caching#prompt-cache-retention).\n"
      }),
      Schema.Null
    ])
  ),
  "messages": Schema.Array(ChatCompletionRequestMessage).annotate({
    "description":
      "A list of messages comprising the conversation so far. Depending on the\n[model](/docs/models) you use, different message types (modalities) are\nsupported, like [text](/docs/guides/text-generation),\n[images](/docs/guides/vision), and [audio](/docs/guides/audio).\n"
  }).check(Schema.isMinLength(1)),
  "model": Schema.Union([
    Schema.String,
    Schema.Literals([
      "gpt-5.2",
      "gpt-5.2-2025-12-11",
      "gpt-5.2-chat-latest",
      "gpt-5.2-pro",
      "gpt-5.2-pro-2025-12-11",
      "gpt-5.1",
      "gpt-5.1-2025-11-13",
      "gpt-5.1-codex",
      "gpt-5.1-mini",
      "gpt-5.1-chat-latest",
      "gpt-5",
      "gpt-5-mini",
      "gpt-5-nano",
      "gpt-5-2025-08-07",
      "gpt-5-mini-2025-08-07",
      "gpt-5-nano-2025-08-07",
      "gpt-5-chat-latest",
      "gpt-4.1",
      "gpt-4.1-mini",
      "gpt-4.1-nano",
      "gpt-4.1-2025-04-14",
      "gpt-4.1-mini-2025-04-14",
      "gpt-4.1-nano-2025-04-14",
      "o4-mini",
      "o4-mini-2025-04-16",
      "o3",
      "o3-2025-04-16",
      "o3-mini",
      "o3-mini-2025-01-31",
      "o1",
      "o1-2024-12-17",
      "o1-preview",
      "o1-preview-2024-09-12",
      "o1-mini",
      "o1-mini-2024-09-12",
      "gpt-4o",
      "gpt-4o-2024-11-20",
      "gpt-4o-2024-08-06",
      "gpt-4o-2024-05-13",
      "gpt-4o-audio-preview",
      "gpt-4o-audio-preview-2024-10-01",
      "gpt-4o-audio-preview-2024-12-17",
      "gpt-4o-audio-preview-2025-06-03",
      "gpt-4o-mini-audio-preview",
      "gpt-4o-mini-audio-preview-2024-12-17",
      "gpt-4o-search-preview",
      "gpt-4o-mini-search-preview",
      "gpt-4o-search-preview-2025-03-11",
      "gpt-4o-mini-search-preview-2025-03-11",
      "chatgpt-4o-latest",
      "codex-mini-latest",
      "gpt-4o-mini",
      "gpt-4o-mini-2024-07-18",
      "gpt-4-turbo",
      "gpt-4-turbo-2024-04-09",
      "gpt-4-0125-preview",
      "gpt-4-turbo-preview",
      "gpt-4-1106-preview",
      "gpt-4-vision-preview",
      "gpt-4",
      "gpt-4-0314",
      "gpt-4-0613",
      "gpt-4-32k",
      "gpt-4-32k-0314",
      "gpt-4-32k-0613",
      "gpt-3.5-turbo",
      "gpt-3.5-turbo-16k",
      "gpt-3.5-turbo-0301",
      "gpt-3.5-turbo-0613",
      "gpt-3.5-turbo-1106",
      "gpt-3.5-turbo-0125",
      "gpt-3.5-turbo-16k-0613"
    ])
  ]).annotate({
    "description":
      "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](/docs/models)\nto browse and compare available models.\n"
  }),
  "modalities": Schema.optionalKey(ResponseModalities),
  "verbosity": Schema.optionalKey(Verbosity),
  "reasoning_effort": Schema.optionalKey(ReasoningEffort),
  "max_completion_tokens": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and [reasoning tokens](/docs/guides/reasoning).\n"
    })
  ),
  "frequency_penalty": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({
      "description":
        "Number between -2.0 and 2.0. Positive values penalize new tokens based on\ntheir existing frequency in the text so far, decreasing the model's\nlikelihood to repeat the same line verbatim.\n"
    })
  ),
  "presence_penalty": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({
      "description":
        "Number between -2.0 and 2.0. Positive values penalize new tokens based on\nwhether they appear in the text so far, increasing the model's likelihood\nto talk about new topics.\n"
    })
  ),
  "web_search_options": Schema.optionalKey(
    Schema.Struct({
      "user_location": Schema.optionalKey(
        Schema.Union([Schema.Struct({}), Schema.Null]).annotate({
          "description": "Approximate location parameters for the search.\n"
        })
      ),
      "search_context_size": Schema.optionalKey(WebSearchContextSize)
    }).annotate({
      "title": "Web search",
      "description":
        "This tool searches the web for relevant results to use in a response.\nLearn more about the [web search tool](/docs/guides/tools-web-search?api-mode=chat).\n"
    })
  ),
  "response_format": Schema.optionalKey(
    Schema.Union([ResponseFormatText, ResponseFormatJsonSchema, ResponseFormatJsonObject], { mode: "oneOf" }).annotate({
      "description":
        "An object specifying the format that the model must output.\n\nSetting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables\nStructured Outputs which ensures the model will match your supplied JSON\nschema. Learn more in the [Structured Outputs\nguide](/docs/guides/structured-outputs).\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n"
    })
  ),
  "audio": Schema.optionalKey(
    Schema.Union([Schema.Struct({}), Schema.Null]).annotate({
      "description":
        "Parameters for audio output. Required when audio output is requested with\n`modalities: [\"audio\"]`. [Learn more](/docs/guides/audio).\n"
    })
  ),
  "store": Schema.optionalKey(
    Schema.Union([Schema.Boolean, Schema.Null]).annotate({
      "description":
        "Whether or not to store the output of this chat completion request for\nuse in our [model distillation](/docs/guides/distillation) or\n[evals](/docs/guides/evals) products.\n\nSupports text and image inputs. Note: image inputs over 8MB will be dropped.\n"
    })
  ),
  "stream": Schema.optionalKey(
    Schema.Union([Schema.Boolean, Schema.Null]).annotate({
      "description":
        "If set to true, the model response data will be streamed to the client\nas it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).\nSee the [Streaming section below](/docs/api-reference/chat/streaming)\nfor more information, along with the [streaming responses](/docs/guides/streaming-responses)\nguide for more information on how to handle the streaming events.\n"
    })
  ),
  "stop": Schema.optionalKey(StopConfiguration),
  "logit_bias": Schema.optionalKey(
    Schema.Union([Schema.Struct({}), Schema.Null]).annotate({
      "description":
        "Modify the likelihood of specified tokens appearing in the completion.\n\nAccepts a JSON object that maps tokens (specified by their token ID in the\ntokenizer) to an associated bias value from -100 to 100. Mathematically,\nthe bias is added to the logits generated by the model prior to sampling.\nThe exact effect will vary per model, but values between -1 and 1 should\ndecrease or increase likelihood of selection; values like -100 or 100\nshould result in a ban or exclusive selection of the relevant token.\n"
    })
  ),
  "logprobs": Schema.optionalKey(
    Schema.Union([Schema.Boolean, Schema.Null]).annotate({
      "description":
        "Whether to return log probabilities of the output tokens or not. If true,\nreturns the log probabilities of each output token returned in the\n`content` of `message`.\n"
    })
  ),
  "max_tokens": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "The maximum number of [tokens](/tokenizer) that can be generated in the\nchat completion. This value can be used to control\n[costs](https://openai.com/api/pricing/) for text generated via API.\n\nThis value is now deprecated in favor of `max_completion_tokens`, and is\nnot compatible with [o-series models](/docs/guides/reasoning).\n"
    })
  ),
  "n": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs."
    })
  ),
  "prediction": Schema.optionalKey(Schema.Union([
    Schema.Union([PredictionContent], { mode: "oneOf" }).annotate({
      "description":
        "Configuration for a [Predicted Output](/docs/guides/predicted-outputs),\nwhich can greatly improve response times when large parts of the model\nresponse are known ahead of time. This is most common when you are\nregenerating a file with only minor changes to most of the content.\n"
    }),
    Schema.Null
  ])),
  "seed": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "This feature is in Beta.\nIf specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.\nDeterminism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.\n"
    })
  ),
  "stream_options": Schema.optionalKey(ChatCompletionStreamOptions),
  "tools": Schema.optionalKey(
    Schema.Array(Schema.Union([ChatCompletionTool, CustomToolChatCompletions], { mode: "oneOf" })).annotate({
      "description":
        "A list of tools the model may call. You can provide either\n[custom tools](/docs/guides/function-calling#custom-tools) or\n[function tools](/docs/guides/function-calling).\n"
    })
  ),
  "tool_choice": Schema.optionalKey(ChatCompletionToolChoiceOption),
  "parallel_tool_calls": Schema.optionalKey(ParallelToolCalls),
  "function_call": Schema.optionalKey(
    Schema.Union([
      Schema.Literals(["none", "auto"]).annotate({
        "description":
          "`none` means the model will not call a function and instead generates a message. `auto` means the model can pick between generating a message or calling a function.\n"
      }),
      ChatCompletionFunctionCallOption
    ], { mode: "oneOf" }).annotate({
      "description":
        "Deprecated in favor of `tool_choice`.\n\nControls which (if any) function is called by the model.\n\n`none` means the model will not call a function and instead generates a\nmessage.\n\n`auto` means the model can pick between generating a message or calling a\nfunction.\n\nSpecifying a particular function via `{\"name\": \"my_function\"}` forces the\nmodel to call that function.\n\n`none` is the default when no functions are present. `auto` is the default\nif functions are present.\n"
    })
  ),
  "functions": Schema.optionalKey(
    Schema.Array(ChatCompletionFunctions).annotate({
      "description": "Deprecated in favor of `tools`.\n\nA list of functions the model may generate JSON inputs for.\n"
    }).check(Schema.isMinLength(1)).check(Schema.isMaxLength(128))
  )
})
export type RunStepObject = {
  readonly "id": string
  readonly "object": "thread.run.step"
  readonly "created_at": number
  readonly "assistant_id": string
  readonly "thread_id": string
  readonly "run_id": string
  readonly "type": "message_creation" | "tool_calls"
  readonly "status": "in_progress" | "cancelled" | "failed" | "completed" | "expired"
  readonly "step_details": RunStepDetailsMessageCreationObject | RunStepDetailsToolCallsObject
  readonly "last_error": { readonly "code": "server_error" | "rate_limit_exceeded"; readonly "message": string } | null
  readonly "expired_at": number | null
  readonly "cancelled_at": number | null
  readonly "failed_at": number | null
  readonly "completed_at": number | null
  readonly "metadata": Metadata
  readonly "usage": RunStepCompletionUsage
}
export const RunStepObject = Schema.Struct({
  "id": Schema.String.annotate({
    "description": "The identifier of the run step, which can be referenced in API endpoints."
  }),
  "object": Schema.Literal("thread.run.step").annotate({
    "description": "The object type, which is always `thread.run.step`."
  }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the run step was created."
  }).check(Schema.isInt()),
  "assistant_id": Schema.String.annotate({
    "description": "The ID of the [assistant](/docs/api-reference/assistants) associated with the run step."
  }),
  "thread_id": Schema.String.annotate({
    "description": "The ID of the [thread](/docs/api-reference/threads) that was run."
  }),
  "run_id": Schema.String.annotate({
    "description": "The ID of the [run](/docs/api-reference/runs) that this run step is a part of."
  }),
  "type": Schema.Literals(["message_creation", "tool_calls"]).annotate({
    "description": "The type of run step, which can be either `message_creation` or `tool_calls`."
  }),
  "status": Schema.Literals(["in_progress", "cancelled", "failed", "completed", "expired"]).annotate({
    "description":
      "The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`."
  }),
  "step_details": Schema.Union([RunStepDetailsMessageCreationObject, RunStepDetailsToolCallsObject], { mode: "oneOf" })
    .annotate({ "description": "The details of the run step." }),
  "last_error": Schema.Union([
    Schema.Struct({
      "code": Schema.Literals(["server_error", "rate_limit_exceeded"]).annotate({
        "description": "One of `server_error` or `rate_limit_exceeded`."
      }),
      "message": Schema.String.annotate({ "description": "A human-readable description of the error." })
    }).annotate({
      "description": "The last error associated with this run step. Will be `null` if there are no errors."
    }),
    Schema.Null
  ]),
  "expired_at": Schema.Union([
    Schema.Number.annotate({
      "description":
        "The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired."
    }).check(Schema.isInt()),
    Schema.Null
  ]),
  "cancelled_at": Schema.Union([
    Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the run step was cancelled." })
      .check(Schema.isInt()),
    Schema.Null
  ]),
  "failed_at": Schema.Union([
    Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the run step failed." }).check(
      Schema.isInt()
    ),
    Schema.Null
  ]),
  "completed_at": Schema.Union([
    Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the run step completed." }).check(
      Schema.isInt()
    ),
    Schema.Null
  ]),
  "metadata": Metadata,
  "usage": RunStepCompletionUsage
}).annotate({ "title": "Run steps", "description": "Represents a step in execution of a run.\n" })
export type RealtimeServerEventResponseCreated = {
  readonly "event_id": string
  readonly "type": "response.created"
  readonly "response": RealtimeResponse
}
export const RealtimeServerEventResponseCreated = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.created").annotate({ "description": "The event type, must be `response.created`." }),
  "response": RealtimeResponse
}).annotate({
  "description":
    "Returned when a new Response is created. The first event of response creation,\nwhere the response is in an initial state of `in_progress`.\n"
})
export type RealtimeServerEventResponseDone = {
  readonly "event_id": string
  readonly "type": "response.done"
  readonly "response": RealtimeResponse
}
export const RealtimeServerEventResponseDone = Schema.Struct({
  "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }),
  "type": Schema.Literal("response.done").annotate({ "description": "The event type, must be `response.done`." }),
  "response": RealtimeResponse
}).annotate({
  "description":
    "Returned when a Response is done streaming. Always emitted, no matter the \nfinal state. The Response object included in the `response.done` event will \ninclude all output Items in the Response but will omit the raw audio data.\n\nClients should check the `status` field of the Response to determine if it was successful\n(`completed`) or if there was another outcome: `cancelled`, `failed`, or `incomplete`.\n\nA response will contain all output items that were generated during the response, excluding\nany audio content.\n"
})
export type RealtimeClientEventResponseCreate = {
  readonly "event_id"?: string
  readonly "type": "response.create"
  readonly "response"?: RealtimeResponseCreateParams
}
export const RealtimeClientEventResponseCreate = Schema.Struct({
  "event_id": Schema.optionalKey(
    Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." }).check(
      Schema.isMaxLength(512)
    )
  ),
  "type": Schema.Literal("response.create").annotate({ "description": "The event type, must be `response.create`." }),
  "response": Schema.optionalKey(RealtimeResponseCreateParams)
}).annotate({
  "description":
    "This event instructs the server to create a Response, which means triggering \nmodel inference. When in Server VAD mode, the server will create Responses \nautomatically.\n\nA Response will include at least one Item, and may have two, in which case \nthe second will be a function call. These Items will be appended to the \nconversation history by default.\n\nThe server will respond with a `response.created` event, events for Items \nand content created, and finally a `response.done` event to indicate the \nResponse is complete.\n\nThe `response.create` event includes inference configuration like \n`instructions` and `tools`. If these are set, they will override the Session's \nconfiguration for this Response only.\n\nResponses can be created out-of-band of the default Conversation, meaning that they can\nhave arbitrary input, and it's possible to disable writing the output to the Conversation.\nOnly one Response can write to the default Conversation at a time, but otherwise multiple\nResponses can be created in parallel. The `metadata` field is a good way to disambiguate\nmultiple simultaneous Responses.\n\nClients can set `conversation` to `none` to create a Response that does not write to the default\nConversation. Arbitrary input can be provided with the `input` field, which is an array accepting\nraw Items and references to existing Items.\n"
})
export type ListAssistantsResponse = {
  readonly "object": string
  readonly "data": ReadonlyArray<AssistantObject>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const ListAssistantsResponse = Schema.Struct({
  "object": Schema.String,
  "data": Schema.Array(AssistantObject),
  "first_id": Schema.String,
  "last_id": Schema.String,
  "has_more": Schema.Boolean
})
export type ListRunsResponse = {
  readonly "object": string
  readonly "data": ReadonlyArray<RunObject>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const ListRunsResponse = Schema.Struct({
  "object": Schema.String,
  "data": Schema.Array(RunObject),
  "first_id": Schema.String,
  "last_id": Schema.String,
  "has_more": Schema.Boolean
})
export type RunStreamEvent =
  | { readonly "event": "thread.run.created"; readonly "data": RunObject }
  | { readonly "event": "thread.run.queued"; readonly "data": RunObject }
  | { readonly "event": "thread.run.in_progress"; readonly "data": RunObject }
  | { readonly "event": "thread.run.requires_action"; readonly "data": RunObject }
  | { readonly "event": "thread.run.completed"; readonly "data": RunObject }
  | { readonly "event": "thread.run.incomplete"; readonly "data": RunObject }
  | { readonly "event": "thread.run.failed"; readonly "data": RunObject }
  | { readonly "event": "thread.run.cancelling"; readonly "data": RunObject }
  | { readonly "event": "thread.run.cancelled"; readonly "data": RunObject }
  | { readonly "event": "thread.run.expired"; readonly "data": RunObject }
export const RunStreamEvent = Schema.Union([
  Schema.Struct({ "event": Schema.Literal("thread.run.created"), "data": RunObject }).annotate({
    "description": "Occurs when a new [run](/docs/api-reference/runs/object) is created."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.run.queued"), "data": RunObject }).annotate({
    "description": "Occurs when a [run](/docs/api-reference/runs/object) moves to a `queued` status."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.run.in_progress"), "data": RunObject }).annotate({
    "description": "Occurs when a [run](/docs/api-reference/runs/object) moves to an `in_progress` status."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.run.requires_action"), "data": RunObject }).annotate({
    "description": "Occurs when a [run](/docs/api-reference/runs/object) moves to a `requires_action` status."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.run.completed"), "data": RunObject }).annotate({
    "description": "Occurs when a [run](/docs/api-reference/runs/object) is completed."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.run.incomplete"), "data": RunObject }).annotate({
    "description": "Occurs when a [run](/docs/api-reference/runs/object) ends with status `incomplete`."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.run.failed"), "data": RunObject }).annotate({
    "description": "Occurs when a [run](/docs/api-reference/runs/object) fails."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.run.cancelling"), "data": RunObject }).annotate({
    "description": "Occurs when a [run](/docs/api-reference/runs/object) moves to a `cancelling` status."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.run.cancelled"), "data": RunObject }).annotate({
    "description": "Occurs when a [run](/docs/api-reference/runs/object) is cancelled."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.run.expired"), "data": RunObject }).annotate({
    "description": "Occurs when a [run](/docs/api-reference/runs/object) expires."
  })
], { mode: "oneOf" })
export type Tool =
  | FunctionTool
  | FileSearchTool
  | ComputerUsePreviewTool
  | WebSearchTool
  | MCPTool
  | CodeInterpreterTool
  | ImageGenTool
  | LocalShellToolParam
  | FunctionShellToolParam
  | CustomToolParam
  | WebSearchPreviewTool
  | ApplyPatchToolParam
export const Tool = Schema.Union([
  FunctionTool,
  FileSearchTool,
  ComputerUsePreviewTool,
  WebSearchTool,
  MCPTool,
  CodeInterpreterTool,
  ImageGenTool,
  LocalShellToolParam,
  FunctionShellToolParam,
  CustomToolParam,
  WebSearchPreviewTool,
  ApplyPatchToolParam
], { mode: "oneOf" }).annotate({ "description": "A tool that can be used to generate a response.\n" })
export type EvalItem = {
  readonly "role": "user" | "assistant" | "system" | "developer"
  readonly "content": EvalItemContent
  readonly "type"?: "message"
}
export const EvalItem = Schema.Struct({
  "role": Schema.Literals(["user", "assistant", "system", "developer"]).annotate({
    "description": "The role of the message input. One of `user`, `assistant`, `system`, or\n`developer`.\n"
  }),
  "content": EvalItemContent,
  "type": Schema.optionalKey(
    Schema.Literal("message").annotate({ "description": "The type of the message input. Always `message`.\n" })
  )
}).annotate({
  "title": "Eval message object",
  "description":
    "A message input to the model with a role indicating instruction following\nhierarchy. Instructions given with the `developer` or `system` role take\nprecedence over instructions given with the `user` role. Messages with the\n`assistant` role are presumed to have been generated by the model in previous\ninteractions.\n"
})
export type OutputMessage = {
  readonly "id": string
  readonly "type": "message"
  readonly "role": "assistant"
  readonly "content": ReadonlyArray<OutputMessageContent>
  readonly "phase"?: MessagePhase | null
  readonly "status": "in_progress" | "completed" | "incomplete"
}
export const OutputMessage = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The unique ID of the output message.\n" }),
  "type": Schema.Literal("message").annotate({ "description": "The type of the output message. Always `message`.\n" }),
  "role": Schema.Literal("assistant").annotate({
    "description": "The role of the output message. Always `assistant`.\n"
  }),
  "content": Schema.Array(OutputMessageContent).annotate({ "description": "The content of the output message.\n" }),
  "phase": Schema.optionalKey(Schema.Union([MessagePhase, Schema.Null])),
  "status": Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({
    "description":
      "The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n"
  })
}).annotate({ "title": "Output message", "description": "An output message from the model.\n" })
export type ConversationItem =
  | Message
  | FunctionToolCallResource
  | FunctionToolCallOutputResource
  | FileSearchToolCall
  | WebSearchToolCall
  | ImageGenToolCall
  | ComputerToolCall
  | ComputerToolCallOutputResource
  | ReasoningItem
  | CodeInterpreterToolCall
  | LocalShellToolCall
  | LocalShellToolCallOutput
  | FunctionShellCall
  | FunctionShellCallOutput
  | ApplyPatchToolCall
  | ApplyPatchToolCallOutput
  | MCPListTools
  | MCPApprovalRequest
  | MCPApprovalResponseResource
  | MCPToolCall
  | CustomToolCall
  | CustomToolCallOutput
export const ConversationItem = Schema.Union([
  Message,
  FunctionToolCallResource,
  FunctionToolCallOutputResource,
  FileSearchToolCall,
  WebSearchToolCall,
  ImageGenToolCall,
  ComputerToolCall,
  ComputerToolCallOutputResource,
  ReasoningItem,
  CodeInterpreterToolCall,
  LocalShellToolCall,
  LocalShellToolCallOutput,
  FunctionShellCall,
  FunctionShellCallOutput,
  ApplyPatchToolCall,
  ApplyPatchToolCallOutput,
  MCPListTools,
  MCPApprovalRequest,
  MCPApprovalResponseResource,
  MCPToolCall,
  CustomToolCall,
  CustomToolCallOutput
], { mode: "oneOf" }).annotate({
  "title": "Conversation item",
  "description":
    "A single item within a conversation. The set of possible types are the same as the `output` type of a [Response object](/docs/api-reference/responses/object#responses/object-output)."
})
export type ItemField =
  | Message
  | FunctionToolCall
  | FunctionToolCallOutput
  | FileSearchToolCall
  | WebSearchToolCall
  | ImageGenToolCall
  | ComputerToolCall
  | ComputerToolCallOutputResource
  | ReasoningItem
  | CompactionBody
  | CodeInterpreterToolCall
  | LocalShellToolCall
  | LocalShellToolCallOutput
  | FunctionShellCall
  | FunctionShellCallOutput
  | ApplyPatchToolCall
  | ApplyPatchToolCallOutput
  | MCPListTools
  | MCPApprovalRequest
  | MCPApprovalResponseResource
  | MCPToolCall
  | CustomToolCall
  | CustomToolCallOutput
export const ItemField = Schema.Union([
  Message,
  FunctionToolCall,
  FunctionToolCallOutput,
  FileSearchToolCall,
  WebSearchToolCall,
  ImageGenToolCall,
  ComputerToolCall,
  ComputerToolCallOutputResource,
  ReasoningItem,
  CompactionBody,
  CodeInterpreterToolCall,
  LocalShellToolCall,
  LocalShellToolCallOutput,
  FunctionShellCall,
  FunctionShellCallOutput,
  ApplyPatchToolCall,
  ApplyPatchToolCallOutput,
  MCPListTools,
  MCPApprovalRequest,
  MCPApprovalResponseResource,
  MCPToolCall,
  CustomToolCall,
  CustomToolCallOutput
], { mode: "oneOf" }).annotate({
  "description": "An item representing a message, tool call, tool output, reasoning, or other response element."
})
export type ThreadItemListResource = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<ThreadItem>
  readonly "first_id": string | null
  readonly "last_id": string | null
  readonly "has_more": boolean
}
export const ThreadItemListResource = Schema.Struct({
  "object": Schema.Literal("list").annotate({ "description": "The type of object returned, must be `list`." }),
  "data": Schema.Array(ThreadItem).annotate({ "description": "A list of items" }),
  "first_id": Schema.Union([
    Schema.String.annotate({ "description": "The ID of the first item in the list." }),
    Schema.Null
  ]),
  "last_id": Schema.Union([
    Schema.String.annotate({ "description": "The ID of the last item in the list." }),
    Schema.Null
  ]),
  "has_more": Schema.Boolean.annotate({ "description": "Whether there are more items available." })
}).annotate({
  "title": "Thread Items",
  "description": "A paginated list of thread items rendered for the ChatKit API."
})
export type ListRunStepsResponse = {
  readonly "object": string
  readonly "data": ReadonlyArray<RunStepObject>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
  readonly [x: string]: unknown
}
export const ListRunStepsResponse = Schema.StructWithRest(
  Schema.Struct({
    "object": Schema.String,
    "data": Schema.Array(RunStepObject),
    "first_id": Schema.String,
    "last_id": Schema.String,
    "has_more": Schema.Boolean
  }),
  [Schema.Record(Schema.String, Schema.Json)]
)
export type RunStepStreamEvent =
  | { readonly "event": "thread.run.step.created"; readonly "data": RunStepObject }
  | { readonly "event": "thread.run.step.in_progress"; readonly "data": RunStepObject }
  | { readonly "event": "thread.run.step.delta"; readonly "data": RunStepDeltaObject }
  | { readonly "event": "thread.run.step.completed"; readonly "data": RunStepObject }
  | { readonly "event": "thread.run.step.failed"; readonly "data": RunStepObject }
  | { readonly "event": "thread.run.step.cancelled"; readonly "data": RunStepObject }
  | { readonly "event": "thread.run.step.expired"; readonly "data": RunStepObject }
export const RunStepStreamEvent = Schema.Union([
  Schema.Struct({ "event": Schema.Literal("thread.run.step.created"), "data": RunStepObject }).annotate({
    "description": "Occurs when a [run step](/docs/api-reference/run-steps/step-object) is created."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.run.step.in_progress"), "data": RunStepObject }).annotate({
    "description":
      "Occurs when a [run step](/docs/api-reference/run-steps/step-object) moves to an `in_progress` state."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.run.step.delta"), "data": RunStepDeltaObject }).annotate({
    "description": "Occurs when parts of a [run step](/docs/api-reference/run-steps/step-object) are being streamed."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.run.step.completed"), "data": RunStepObject }).annotate({
    "description": "Occurs when a [run step](/docs/api-reference/run-steps/step-object) is completed."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.run.step.failed"), "data": RunStepObject }).annotate({
    "description": "Occurs when a [run step](/docs/api-reference/run-steps/step-object) fails."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.run.step.cancelled"), "data": RunStepObject }).annotate({
    "description": "Occurs when a [run step](/docs/api-reference/run-steps/step-object) is cancelled."
  }),
  Schema.Struct({ "event": Schema.Literal("thread.run.step.expired"), "data": RunStepObject }).annotate({
    "description": "Occurs when a [run step](/docs/api-reference/run-steps/step-object) expires."
  })
], { mode: "oneOf" })
export type ToolsArray = ReadonlyArray<Tool>
export const ToolsArray = Schema.Array(Tool).annotate({
  "description":
    "An array of tools the model may call while generating a response. You\ncan specify which tool to use by setting the `tool_choice` parameter.\n\nWe support the following categories of tools:\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](/docs/guides/tools-web-search)\n  or [file search](/docs/guides/tools-file-search). Learn more about\n  [built-in tools](/docs/guides/tools).\n- **MCP Tools**: Integrations with third-party systems via custom MCP servers\n  or predefined connectors such as Google Drive and SharePoint. Learn more about\n  [MCP Tools](/docs/guides/tools-connectors-mcp).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code with strongly typed arguments\n  and outputs. Learn more about\n  [function calling](/docs/guides/function-calling). You can also use\n  custom tools to call your own code.\n"
})
export type CreateEvalCompletionsRunDataSource = {
  readonly "type": "completions"
  readonly "input_messages"?: {
    readonly "type": "template"
    readonly "template": ReadonlyArray<EasyInputMessage | EvalItem>
  } | { readonly "type": "item_reference"; readonly "item_reference": string }
  readonly "sampling_params"?: {
    readonly "reasoning_effort"?: ReasoningEffort
    readonly "temperature"?: number
    readonly "max_completion_tokens"?: number
    readonly "top_p"?: number
    readonly "seed"?: number
    readonly "response_format"?: ResponseFormatText | ResponseFormatJsonSchema | ResponseFormatJsonObject
    readonly "tools"?: ReadonlyArray<ChatCompletionTool>
  }
  readonly "model"?: string
  readonly "source": EvalJsonlFileContentSource | EvalJsonlFileIdSource | EvalStoredCompletionsSource
}
export const CreateEvalCompletionsRunDataSource = Schema.Struct({
  "type": Schema.Literal("completions").annotate({
    "description": "The type of run data source. Always `completions`."
  }),
  "input_messages": Schema.optionalKey(
    Schema.Union([
      Schema.Struct({
        "type": Schema.Literal("template").annotate({
          "description": "The type of input messages. Always `template`."
        }),
        "template": Schema.Array(Schema.Union([EasyInputMessage, EvalItem], { mode: "oneOf" })).annotate({
          "description":
            "A list of chat messages forming the prompt or context. May include variable references to the `item` namespace, ie {{item.name}}."
        })
      }).annotate({ "title": "TemplateInputMessages" }),
      Schema.Struct({
        "type": Schema.Literal("item_reference").annotate({
          "description": "The type of input messages. Always `item_reference`."
        }),
        "item_reference": Schema.String.annotate({
          "description": "A reference to a variable in the `item` namespace. Ie, \"item.input_trajectory\""
        })
      }).annotate({ "title": "ItemReferenceInputMessages" })
    ], { mode: "oneOf" }).annotate({
      "description":
        "Used when sampling from a model. Dictates the structure of the messages passed into the model. Can either be a reference to a prebuilt trajectory (ie, `item.input_trajectory`), or a template with variable references to the `item` namespace."
    })
  ),
  "sampling_params": Schema.optionalKey(Schema.Struct({
    "reasoning_effort": Schema.optionalKey(ReasoningEffort),
    "temperature": Schema.optionalKey(
      Schema.Number.annotate({ "description": "A higher temperature increases randomness in the outputs." }).check(
        Schema.isFinite()
      )
    ),
    "max_completion_tokens": Schema.optionalKey(
      Schema.Number.annotate({ "description": "The maximum number of tokens in the generated output." }).check(
        Schema.isInt()
      )
    ),
    "top_p": Schema.optionalKey(
      Schema.Number.annotate({
        "description": "An alternative to temperature for nucleus sampling; 1.0 includes all tokens."
      }).check(Schema.isFinite())
    ),
    "seed": Schema.optionalKey(
      Schema.Number.annotate({ "description": "A seed value to initialize the randomness, during sampling." }).check(
        Schema.isInt()
      )
    ),
    "response_format": Schema.optionalKey(
      Schema.Union([ResponseFormatText, ResponseFormatJsonSchema, ResponseFormatJsonObject], { mode: "oneOf" })
        .annotate({
          "description":
            "An object specifying the format that the model must output.\n\nSetting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables\nStructured Outputs which ensures the model will match your supplied JSON\nschema. Learn more in the [Structured Outputs\nguide](/docs/guides/structured-outputs).\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n"
        })
    ),
    "tools": Schema.optionalKey(
      Schema.Array(ChatCompletionTool).annotate({
        "description":
          "A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.\n"
      })
    )
  })),
  "model": Schema.optionalKey(
    Schema.String.annotate({
      "description": "The name of the model to use for generating completions (e.g. \"o3-mini\")."
    })
  ),
  "source": Schema.Union([EvalJsonlFileContentSource, EvalJsonlFileIdSource, EvalStoredCompletionsSource], {
    mode: "oneOf"
  }).annotate({ "description": "Determines what populates the `item` namespace in this run's data source." })
}).annotate({
  "title": "CompletionsRunDataSource",
  "description": "A CompletionsRunDataSource object describing a model sampling configuration.\n"
})
export type CreateEvalItem = { readonly "role": string; readonly "content": string } | EvalItem
export const CreateEvalItem = Schema.Union([
  Schema.Struct({
    "role": Schema.String.annotate({
      "description": "The role of the message (e.g. \"system\", \"assistant\", \"user\")."
    }),
    "content": Schema.String.annotate({ "description": "The content of the message." })
  }).annotate({ "title": "SimpleInputMessage" }),
  EvalItem
], { mode: "oneOf" }).annotate({
  "title": "CreateEvalItem",
  "description":
    "A chat message that makes up the prompt or context. May include variable references to the `item` namespace, ie {{item.name}}."
})
export type CreateEvalResponsesRunDataSource = {
  readonly "type": "responses"
  readonly "input_messages"?: {
    readonly "type": "template"
    readonly "template": ReadonlyArray<{ readonly "role": string; readonly "content": string } | EvalItem>
  } | { readonly "type": "item_reference"; readonly "item_reference": string }
  readonly "sampling_params"?: {
    readonly "reasoning_effort"?: ReasoningEffort
    readonly "temperature"?: number
    readonly "max_completion_tokens"?: number
    readonly "top_p"?: number
    readonly "seed"?: number
    readonly "tools"?: ReadonlyArray<Tool>
    readonly "text"?: { readonly "format"?: TextResponseFormatConfiguration }
  }
  readonly "model"?: string
  readonly "source": EvalJsonlFileContentSource | EvalJsonlFileIdSource | EvalResponsesSource
}
export const CreateEvalResponsesRunDataSource = Schema.Struct({
  "type": Schema.Literal("responses").annotate({ "description": "The type of run data source. Always `responses`." }),
  "input_messages": Schema.optionalKey(
    Schema.Union([
      Schema.Struct({
        "type": Schema.Literal("template").annotate({
          "description": "The type of input messages. Always `template`."
        }),
        "template": Schema.Array(
          Schema.Union([
            Schema.Struct({
              "role": Schema.String.annotate({
                "description": "The role of the message (e.g. \"system\", \"assistant\", \"user\")."
              }),
              "content": Schema.String.annotate({ "description": "The content of the message." })
            }).annotate({ "title": "ChatMessage" }),
            EvalItem
          ], { mode: "oneOf" })
        ).annotate({
          "description":
            "A list of chat messages forming the prompt or context. May include variable references to the `item` namespace, ie {{item.name}}."
        })
      }).annotate({ "title": "InputMessagesTemplate" }),
      Schema.Struct({
        "type": Schema.Literal("item_reference").annotate({
          "description": "The type of input messages. Always `item_reference`."
        }),
        "item_reference": Schema.String.annotate({
          "description": "A reference to a variable in the `item` namespace. Ie, \"item.name\""
        })
      }).annotate({ "title": "InputMessagesItemReference" })
    ], { mode: "oneOf" }).annotate({
      "description":
        "Used when sampling from a model. Dictates the structure of the messages passed into the model. Can either be a reference to a prebuilt trajectory (ie, `item.input_trajectory`), or a template with variable references to the `item` namespace."
    })
  ),
  "sampling_params": Schema.optionalKey(Schema.Struct({
    "reasoning_effort": Schema.optionalKey(ReasoningEffort),
    "temperature": Schema.optionalKey(
      Schema.Number.annotate({ "description": "A higher temperature increases randomness in the outputs." }).check(
        Schema.isFinite()
      )
    ),
    "max_completion_tokens": Schema.optionalKey(
      Schema.Number.annotate({ "description": "The maximum number of tokens in the generated output." }).check(
        Schema.isInt()
      )
    ),
    "top_p": Schema.optionalKey(
      Schema.Number.annotate({
        "description": "An alternative to temperature for nucleus sampling; 1.0 includes all tokens."
      }).check(Schema.isFinite())
    ),
    "seed": Schema.optionalKey(
      Schema.Number.annotate({ "description": "A seed value to initialize the randomness, during sampling." }).check(
        Schema.isInt()
      )
    ),
    "tools": Schema.optionalKey(
      Schema.Array(Tool).annotate({
        "description":
          "An array of tools the model may call while generating a response. You\ncan specify which tool to use by setting the `tool_choice` parameter.\n\nThe two categories of tools you can provide the model are:\n\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](/docs/guides/tools-web-search)\n  or [file search](/docs/guides/tools-file-search). Learn more about\n  [built-in tools](/docs/guides/tools).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code. Learn more about\n  [function calling](/docs/guides/function-calling).\n"
      })
    ),
    "text": Schema.optionalKey(
      Schema.Struct({ "format": Schema.optionalKey(TextResponseFormatConfiguration) }).annotate({
        "description":
          "Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](/docs/guides/text)\n- [Structured Outputs](/docs/guides/structured-outputs)\n"
      })
    )
  })),
  "model": Schema.optionalKey(
    Schema.String.annotate({
      "description": "The name of the model to use for generating completions (e.g. \"o3-mini\")."
    })
  ),
  "source": Schema.Union([EvalJsonlFileContentSource, EvalJsonlFileIdSource, EvalResponsesSource], { mode: "oneOf" })
    .annotate({ "description": "Determines what populates the `item` namespace in this run's data source." })
}).annotate({
  "title": "ResponsesRunDataSource",
  "description": "A ResponsesRunDataSource object describing a model sampling configuration.\n"
})
export type EvalGraderLabelModel = {
  readonly "type": "label_model"
  readonly "name": string
  readonly "model": string
  readonly "input": ReadonlyArray<EvalItem>
  readonly "labels": ReadonlyArray<string>
  readonly "passing_labels": ReadonlyArray<string>
}
export const EvalGraderLabelModel = Schema.Struct({
  "type": Schema.Literal("label_model").annotate({ "description": "The object type, which is always `label_model`." }),
  "name": Schema.String.annotate({ "description": "The name of the grader." }),
  "model": Schema.String.annotate({
    "description": "The model to use for the evaluation. Must support structured outputs."
  }),
  "input": Schema.Array(EvalItem),
  "labels": Schema.Array(Schema.String).annotate({
    "description": "The labels to assign to each item in the evaluation."
  }),
  "passing_labels": Schema.Array(Schema.String).annotate({
    "description": "The labels that indicate a passing result. Must be a subset of labels."
  })
}).annotate({
  "title": "LabelModelGrader",
  "description": "A LabelModelGrader object which uses a model to assign labels to each item\nin the evaluation.\n"
})
export type EvalGraderScoreModel = {
  readonly "type": "score_model"
  readonly "name": string
  readonly "model": string
  readonly "sampling_params"?: {
    readonly "seed"?: number | null
    readonly "top_p"?: number | null
    readonly "temperature"?: number | null
    readonly "max_completions_tokens"?: number | null
    readonly "reasoning_effort"?: ReasoningEffort
  }
  readonly "input": ReadonlyArray<EvalItem>
  readonly "range"?: ReadonlyArray<number>
  readonly "pass_threshold"?: number
}
export const EvalGraderScoreModel = Schema.Struct({
  "type": Schema.Literal("score_model").annotate({ "description": "The object type, which is always `score_model`." }),
  "name": Schema.String.annotate({ "description": "The name of the grader." }),
  "model": Schema.String.annotate({ "description": "The model to use for the evaluation." }),
  "sampling_params": Schema.optionalKey(
    Schema.Struct({
      "seed": Schema.optionalKey(
        Schema.Union([
          Schema.Number.annotate({ "description": "A seed value to initialize the randomness, during sampling.\n" })
            .check(Schema.isInt()),
          Schema.Null
        ])
      ),
      "top_p": Schema.optionalKey(
        Schema.Union([
          Schema.Number.annotate({
            "description": "An alternative to temperature for nucleus sampling; 1.0 includes all tokens.\n"
          }).check(Schema.isFinite()),
          Schema.Null
        ])
      ),
      "temperature": Schema.optionalKey(
        Schema.Union([
          Schema.Number.annotate({ "description": "A higher temperature increases randomness in the outputs.\n" })
            .check(Schema.isFinite()),
          Schema.Null
        ])
      ),
      "max_completions_tokens": Schema.optionalKey(
        Schema.Union([
          Schema.Number.annotate({
            "description": "The maximum number of tokens the grader model may generate in its response.\n"
          }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)),
          Schema.Null
        ])
      ),
      "reasoning_effort": Schema.optionalKey(ReasoningEffort)
    }).annotate({ "description": "The sampling parameters for the model." })
  ),
  "input": Schema.Array(EvalItem).annotate({
    "description":
      "The input messages evaluated by the grader. Supports text, output text, input image, and input audio content blocks, and may include template strings.\n"
  }),
  "range": Schema.optionalKey(
    Schema.Array(Schema.Number.check(Schema.isFinite())).annotate({
      "description": "The range of the score. Defaults to `[0, 1]`."
    })
  ),
  "pass_threshold": Schema.optionalKey(
    Schema.Number.annotate({ "description": "The threshold for the score." }).check(Schema.isFinite())
  )
}).annotate({
  "title": "ScoreModelGrader",
  "description": "A ScoreModelGrader object that uses a model to assign a score to the input.\n"
})
export type GraderLabelModel = {
  readonly "type": "label_model"
  readonly "name": string
  readonly "model": string
  readonly "input": ReadonlyArray<EvalItem>
  readonly "labels": ReadonlyArray<string>
  readonly "passing_labels": ReadonlyArray<string>
}
export const GraderLabelModel = Schema.Struct({
  "type": Schema.Literal("label_model").annotate({ "description": "The object type, which is always `label_model`." }),
  "name": Schema.String.annotate({ "description": "The name of the grader." }),
  "model": Schema.String.annotate({
    "description": "The model to use for the evaluation. Must support structured outputs."
  }),
  "input": Schema.Array(EvalItem),
  "labels": Schema.Array(Schema.String).annotate({
    "description": "The labels to assign to each item in the evaluation."
  }),
  "passing_labels": Schema.Array(Schema.String).annotate({
    "description": "The labels that indicate a passing result. Must be a subset of labels."
  })
}).annotate({
  "title": "LabelModelGrader",
  "description": "A LabelModelGrader object which uses a model to assign labels to each item\nin the evaluation.\n"
})
export type GraderScoreModel = {
  readonly "type": "score_model"
  readonly "name": string
  readonly "model": string
  readonly "sampling_params"?: {
    readonly "seed"?: number | null
    readonly "top_p"?: number | null
    readonly "temperature"?: number | null
    readonly "max_completions_tokens"?: number | null
    readonly "reasoning_effort"?: ReasoningEffort
  }
  readonly "input": ReadonlyArray<EvalItem>
  readonly "range"?: ReadonlyArray<number>
}
export const GraderScoreModel = Schema.Struct({
  "type": Schema.Literal("score_model").annotate({ "description": "The object type, which is always `score_model`." }),
  "name": Schema.String.annotate({ "description": "The name of the grader." }),
  "model": Schema.String.annotate({ "description": "The model to use for the evaluation." }),
  "sampling_params": Schema.optionalKey(
    Schema.Struct({
      "seed": Schema.optionalKey(
        Schema.Union([
          Schema.Number.annotate({ "description": "A seed value to initialize the randomness, during sampling.\n" })
            .check(Schema.isInt()),
          Schema.Null
        ])
      ),
      "top_p": Schema.optionalKey(
        Schema.Union([
          Schema.Number.annotate({
            "description": "An alternative to temperature for nucleus sampling; 1.0 includes all tokens.\n"
          }).check(Schema.isFinite()),
          Schema.Null
        ])
      ),
      "temperature": Schema.optionalKey(
        Schema.Union([
          Schema.Number.annotate({ "description": "A higher temperature increases randomness in the outputs.\n" })
            .check(Schema.isFinite()),
          Schema.Null
        ])
      ),
      "max_completions_tokens": Schema.optionalKey(
        Schema.Union([
          Schema.Number.annotate({
            "description": "The maximum number of tokens the grader model may generate in its response.\n"
          }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)),
          Schema.Null
        ])
      ),
      "reasoning_effort": Schema.optionalKey(ReasoningEffort)
    }).annotate({ "description": "The sampling parameters for the model." })
  ),
  "input": Schema.Array(EvalItem).annotate({
    "description":
      "The input messages evaluated by the grader. Supports text, output text, input image, and input audio content blocks, and may include template strings.\n"
  }),
  "range": Schema.optionalKey(
    Schema.Array(Schema.Number.check(Schema.isFinite())).annotate({
      "description": "The range of the score. Defaults to `[0, 1]`."
    })
  )
}).annotate({
  "title": "ScoreModelGrader",
  "description": "A ScoreModelGrader object that uses a model to assign a score to the input.\n"
})
export type InputItem =
  | EasyInputMessage
  | InputMessage
  | OutputMessage
  | FileSearchToolCall
  | ComputerToolCall
  | ComputerCallOutputItemParam
  | WebSearchToolCall
  | FunctionToolCall
  | FunctionCallOutputItemParam
  | ReasoningItem
  | CompactionSummaryItemParam
  | ImageGenToolCall
  | CodeInterpreterToolCall
  | LocalShellToolCall
  | LocalShellToolCallOutput
  | FunctionShellCallItemParam
  | FunctionShellCallOutputItemParam
  | ApplyPatchToolCallItemParam
  | ApplyPatchToolCallOutputItemParam
  | MCPListTools
  | MCPApprovalRequest
  | MCPApprovalResponse
  | MCPToolCall
  | CustomToolCallOutput
  | CustomToolCall
  | ItemReferenceParam
export const InputItem = Schema.Union([
  EasyInputMessage,
  Schema.Union([
    InputMessage,
    OutputMessage,
    FileSearchToolCall,
    ComputerToolCall,
    ComputerCallOutputItemParam,
    WebSearchToolCall,
    FunctionToolCall,
    FunctionCallOutputItemParam,
    ReasoningItem,
    CompactionSummaryItemParam,
    ImageGenToolCall,
    CodeInterpreterToolCall,
    LocalShellToolCall,
    LocalShellToolCallOutput,
    FunctionShellCallItemParam,
    FunctionShellCallOutputItemParam,
    ApplyPatchToolCallItemParam,
    ApplyPatchToolCallOutputItemParam,
    MCPListTools,
    MCPApprovalRequest,
    MCPApprovalResponse,
    MCPToolCall,
    CustomToolCallOutput,
    CustomToolCall
  ], { mode: "oneOf" }).annotate({
    "description":
      "An item representing part of the context for the response to be\ngenerated by the model. Can contain text, images, and audio inputs,\nas well as previous assistant responses and tool call outputs.\n",
    "title": "Item"
  }),
  ItemReferenceParam
], { mode: "oneOf" })
export type ItemResource =
  | InputMessageResource
  | OutputMessage
  | FileSearchToolCall
  | ComputerToolCall
  | ComputerToolCallOutputResource
  | WebSearchToolCall
  | FunctionToolCallResource
  | FunctionToolCallOutputResource
  | ImageGenToolCall
  | CodeInterpreterToolCall
  | LocalShellToolCall
  | LocalShellToolCallOutput
  | FunctionShellCall
  | FunctionShellCallOutput
  | ApplyPatchToolCall
  | ApplyPatchToolCallOutput
  | MCPListTools
  | MCPApprovalRequest
  | MCPApprovalResponseResource
  | MCPToolCall
export const ItemResource = Schema.Union([
  InputMessageResource,
  OutputMessage,
  FileSearchToolCall,
  ComputerToolCall,
  ComputerToolCallOutputResource,
  WebSearchToolCall,
  FunctionToolCallResource,
  FunctionToolCallOutputResource,
  ImageGenToolCall,
  CodeInterpreterToolCall,
  LocalShellToolCall,
  LocalShellToolCallOutput,
  FunctionShellCall,
  FunctionShellCallOutput,
  ApplyPatchToolCall,
  ApplyPatchToolCallOutput,
  MCPListTools,
  MCPApprovalRequest,
  MCPApprovalResponseResource,
  MCPToolCall
], { mode: "oneOf" }).annotate({ "description": "Content item used to generate a response.\n" })
export type OutputItem =
  | OutputMessage
  | FileSearchToolCall
  | FunctionToolCall
  | WebSearchToolCall
  | ComputerToolCall
  | ReasoningItem
  | CompactionBody
  | ImageGenToolCall
  | CodeInterpreterToolCall
  | LocalShellToolCall
  | FunctionShellCall
  | FunctionShellCallOutput
  | ApplyPatchToolCall
  | ApplyPatchToolCallOutput
  | MCPToolCall
  | MCPListTools
  | MCPApprovalRequest
  | CustomToolCall
export const OutputItem = Schema.Union([
  OutputMessage,
  FileSearchToolCall,
  FunctionToolCall,
  WebSearchToolCall,
  ComputerToolCall,
  ReasoningItem,
  CompactionBody,
  ImageGenToolCall,
  CodeInterpreterToolCall,
  LocalShellToolCall,
  FunctionShellCall,
  FunctionShellCallOutput,
  ApplyPatchToolCall,
  ApplyPatchToolCallOutput,
  MCPToolCall,
  MCPListTools,
  MCPApprovalRequest,
  CustomToolCall
])
export type ResponseOutputItemAddedEvent = {
  readonly "type": "response.output_item.added"
  readonly "output_index": number
  readonly "sequence_number": number
  readonly "item":
    | OutputMessage
    | FileSearchToolCall
    | FunctionToolCall
    | WebSearchToolCall
    | ComputerToolCall
    | ReasoningItem
    | CompactionBody
    | ImageGenToolCall
    | CodeInterpreterToolCall
    | LocalShellToolCall
    | FunctionShellCall
    | FunctionShellCallOutput
    | ApplyPatchToolCall
    | ApplyPatchToolCallOutput
    | MCPToolCall
    | MCPListTools
    | MCPApprovalRequest
    | CustomToolCall
}
export const ResponseOutputItemAddedEvent = Schema.Struct({
  "type": Schema.Literal("response.output_item.added").annotate({
    "description": "The type of the event. Always `response.output_item.added`.\n"
  }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item that was added.\n" }).check(
    Schema.isInt()
  ),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\n" }).check(
    Schema.isInt()
  ),
  "item": Schema.Union([
    OutputMessage,
    FileSearchToolCall,
    FunctionToolCall,
    WebSearchToolCall,
    ComputerToolCall,
    ReasoningItem,
    CompactionBody,
    ImageGenToolCall,
    CodeInterpreterToolCall,
    LocalShellToolCall,
    FunctionShellCall,
    FunctionShellCallOutput,
    ApplyPatchToolCall,
    ApplyPatchToolCallOutput,
    MCPToolCall,
    MCPListTools,
    MCPApprovalRequest,
    CustomToolCall
  ]).annotate({ "description": "The output item that was added.\n" })
}).annotate({ "description": "Emitted when a new output item is added." })
export type ResponseOutputItemDoneEvent = {
  readonly "type": "response.output_item.done"
  readonly "output_index": number
  readonly "sequence_number": number
  readonly "item":
    | OutputMessage
    | FileSearchToolCall
    | FunctionToolCall
    | WebSearchToolCall
    | ComputerToolCall
    | ReasoningItem
    | CompactionBody
    | ImageGenToolCall
    | CodeInterpreterToolCall
    | LocalShellToolCall
    | FunctionShellCall
    | FunctionShellCallOutput
    | ApplyPatchToolCall
    | ApplyPatchToolCallOutput
    | MCPToolCall
    | MCPListTools
    | MCPApprovalRequest
    | CustomToolCall
}
export const ResponseOutputItemDoneEvent = Schema.Struct({
  "type": Schema.Literal("response.output_item.done").annotate({
    "description": "The type of the event. Always `response.output_item.done`.\n"
  }),
  "output_index": Schema.Number.annotate({ "description": "The index of the output item that was marked done.\n" })
    .check(Schema.isInt()),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\n" }).check(
    Schema.isInt()
  ),
  "item": Schema.Union([
    OutputMessage,
    FileSearchToolCall,
    FunctionToolCall,
    WebSearchToolCall,
    ComputerToolCall,
    ReasoningItem,
    CompactionBody,
    ImageGenToolCall,
    CodeInterpreterToolCall,
    LocalShellToolCall,
    FunctionShellCall,
    FunctionShellCallOutput,
    ApplyPatchToolCall,
    ApplyPatchToolCallOutput,
    MCPToolCall,
    MCPListTools,
    MCPApprovalRequest,
    CustomToolCall
  ]).annotate({ "description": "The output item that was marked done.\n" })
}).annotate({ "description": "Emitted when an output item is marked done." })
export type ConversationItemList = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<ConversationItem>
  readonly "has_more": boolean
  readonly "first_id": string
  readonly "last_id": string
}
export const ConversationItemList = Schema.Struct({
  "object": Schema.Literal("list").annotate({ "description": "The type of object returned, must be `list`." }),
  "data": Schema.Array(ConversationItem).annotate({ "description": "A list of conversation items." }),
  "has_more": Schema.Boolean.annotate({ "description": "Whether there are more items available." }),
  "first_id": Schema.String.annotate({ "description": "The ID of the first item in the list." }),
  "last_id": Schema.String.annotate({ "description": "The ID of the last item in the list." })
}).annotate({ "title": "The conversation item list", "description": "A list of Conversation items." })
export type CompactResource = {
  readonly "id": string
  readonly "object": "response.compaction"
  readonly "output": ReadonlyArray<ItemField>
  readonly "created_at": number
  readonly "usage": {
    readonly "input_tokens": number
    readonly "input_tokens_details": { readonly "cached_tokens": number }
    readonly "output_tokens": number
    readonly "output_tokens_details": { readonly "reasoning_tokens": number }
    readonly "total_tokens": number
  }
}
export const CompactResource = Schema.Struct({
  "id": Schema.String.annotate({ "description": "The unique identifier for the compacted response." }),
  "object": Schema.Literal("response.compaction").annotate({
    "description": "The object type. Always `response.compaction`."
  }),
  "output": Schema.Array(ItemField).annotate({ "description": "The compacted list of output items." }),
  "created_at": Schema.Number.annotate({
    "description": "Unix timestamp (in seconds) when the compacted conversation was created."
  }).check(Schema.isInt()),
  "usage": Schema.Struct({
    "input_tokens": Schema.Number.annotate({ "description": "The number of input tokens." }).check(Schema.isInt()),
    "input_tokens_details": Schema.Struct({
      "cached_tokens": Schema.Number.annotate({
        "description":
          "The number of tokens that were retrieved from the cache. \n[More on prompt caching](/docs/guides/prompt-caching).\n"
      }).check(Schema.isInt())
    }).annotate({ "description": "A detailed breakdown of the input tokens." }),
    "output_tokens": Schema.Number.annotate({ "description": "The number of output tokens." }).check(Schema.isInt()),
    "output_tokens_details": Schema.Struct({
      "reasoning_tokens": Schema.Number.annotate({ "description": "The number of reasoning tokens." }).check(
        Schema.isInt()
      )
    }).annotate({ "description": "A detailed breakdown of the output tokens." }),
    "total_tokens": Schema.Number.annotate({ "description": "The total number of tokens used." }).check(Schema.isInt())
  }).annotate({
    "description": "Token accounting for the compaction pass, including cached, reasoning, and total tokens."
  })
}).annotate({ "title": "The compacted response object" })
export type CreateEvalLabelModelGrader = {
  readonly "type": "label_model"
  readonly "name": string
  readonly "model": string
  readonly "input": ReadonlyArray<CreateEvalItem>
  readonly "labels": ReadonlyArray<string>
  readonly "passing_labels": ReadonlyArray<string>
}
export const CreateEvalLabelModelGrader = Schema.Struct({
  "type": Schema.Literal("label_model").annotate({ "description": "The object type, which is always `label_model`." }),
  "name": Schema.String.annotate({ "description": "The name of the grader." }),
  "model": Schema.String.annotate({
    "description": "The model to use for the evaluation. Must support structured outputs."
  }),
  "input": Schema.Array(CreateEvalItem).annotate({
    "description":
      "A list of chat messages forming the prompt or context. May include variable references to the `item` namespace, ie {{item.name}}."
  }),
  "labels": Schema.Array(Schema.String).annotate({
    "description": "The labels to classify to each item in the evaluation."
  }),
  "passing_labels": Schema.Array(Schema.String).annotate({
    "description": "The labels that indicate a passing result. Must be a subset of labels."
  })
}).annotate({
  "title": "LabelModelGrader",
  "description": "A LabelModelGrader object which uses a model to assign labels to each item\nin the evaluation.\n"
})
export type CreateEvalRunRequest = {
  readonly "name"?: string
  readonly "metadata"?: Metadata
  readonly "data_source":
    | CreateEvalJsonlRunDataSource
    | CreateEvalCompletionsRunDataSource
    | CreateEvalResponsesRunDataSource
}
export const CreateEvalRunRequest = Schema.Struct({
  "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the run." })),
  "metadata": Schema.optionalKey(Metadata),
  "data_source": Schema.Union([
    CreateEvalJsonlRunDataSource,
    CreateEvalCompletionsRunDataSource,
    CreateEvalResponsesRunDataSource
  ], { mode: "oneOf" }).annotate({ "description": "Details about the run's data source." })
}).annotate({ "title": "CreateEvalRunRequest" })
export type EvalRun = {
  readonly "object": "eval.run"
  readonly "id": string
  readonly "eval_id": string
  readonly "status": string
  readonly "model": string
  readonly "name": string
  readonly "created_at": number
  readonly "report_url": string
  readonly "result_counts": {
    readonly "total": number
    readonly "errored": number
    readonly "failed": number
    readonly "passed": number
  }
  readonly "per_model_usage": ReadonlyArray<
    {
      readonly "model_name": string
      readonly "invocation_count": number
      readonly "prompt_tokens": number
      readonly "completion_tokens": number
      readonly "total_tokens": number
      readonly "cached_tokens": number
    }
  >
  readonly "per_testing_criteria_results": ReadonlyArray<
    { readonly "testing_criteria": string; readonly "passed": number; readonly "failed": number }
  >
  readonly "data_source":
    | CreateEvalJsonlRunDataSource
    | CreateEvalCompletionsRunDataSource
    | CreateEvalResponsesRunDataSource
  readonly "metadata": Metadata
  readonly "error": EvalApiError
}
export const EvalRun = Schema.Struct({
  "object": Schema.Literal("eval.run").annotate({ "description": "The type of the object. Always \"eval.run\"." }),
  "id": Schema.String.annotate({ "description": "Unique identifier for the evaluation run." }),
  "eval_id": Schema.String.annotate({ "description": "The identifier of the associated evaluation." }),
  "status": Schema.String.annotate({ "description": "The status of the evaluation run." }),
  "model": Schema.String.annotate({ "description": "The model that is evaluated, if applicable." }),
  "name": Schema.String.annotate({ "description": "The name of the evaluation run." }),
  "created_at": Schema.Number.annotate({
    "description": "Unix timestamp (in seconds) when the evaluation run was created."
  }).check(Schema.isInt()),
  "report_url": Schema.String.annotate({
    "description": "The URL to the rendered evaluation run report on the UI dashboard."
  }),
  "result_counts": Schema.Struct({
    "total": Schema.Number.annotate({ "description": "Total number of executed output items." }).check(Schema.isInt()),
    "errored": Schema.Number.annotate({ "description": "Number of output items that resulted in an error." }).check(
      Schema.isInt()
    ),
    "failed": Schema.Number.annotate({ "description": "Number of output items that failed to pass the evaluation." })
      .check(Schema.isInt()),
    "passed": Schema.Number.annotate({ "description": "Number of output items that passed the evaluation." }).check(
      Schema.isInt()
    )
  }).annotate({ "description": "Counters summarizing the outcomes of the evaluation run." }),
  "per_model_usage": Schema.Array(Schema.Struct({
    "model_name": Schema.String.annotate({ "description": "The name of the model." }),
    "invocation_count": Schema.Number.annotate({ "description": "The number of invocations." }).check(Schema.isInt()),
    "prompt_tokens": Schema.Number.annotate({ "description": "The number of prompt tokens used." }).check(
      Schema.isInt()
    ),
    "completion_tokens": Schema.Number.annotate({ "description": "The number of completion tokens generated." }).check(
      Schema.isInt()
    ),
    "total_tokens": Schema.Number.annotate({ "description": "The total number of tokens used." }).check(Schema.isInt()),
    "cached_tokens": Schema.Number.annotate({ "description": "The number of tokens retrieved from cache." }).check(
      Schema.isInt()
    )
  })).annotate({ "description": "Usage statistics for each model during the evaluation run." }),
  "per_testing_criteria_results": Schema.Array(Schema.Struct({
    "testing_criteria": Schema.String.annotate({ "description": "A description of the testing criteria." }),
    "passed": Schema.Number.annotate({ "description": "Number of tests passed for this criteria." }).check(
      Schema.isInt()
    ),
    "failed": Schema.Number.annotate({ "description": "Number of tests failed for this criteria." }).check(
      Schema.isInt()
    )
  })).annotate({ "description": "Results per testing criteria applied during the evaluation run." }),
  "data_source": Schema.Union([
    CreateEvalJsonlRunDataSource,
    CreateEvalCompletionsRunDataSource,
    CreateEvalResponsesRunDataSource
  ], { mode: "oneOf" }).annotate({ "description": "Information about the run's data source." }),
  "metadata": Metadata,
  "error": EvalApiError
}).annotate({ "title": "EvalRun", "description": "A schema representing an evaluation run.\n" })
export type Eval = {
  readonly "object": "eval"
  readonly "id": string
  readonly "name": string
  readonly "data_source_config":
    | EvalCustomDataSourceConfig
    | EvalLogsDataSourceConfig
    | EvalStoredCompletionsDataSourceConfig
  readonly "testing_criteria": ReadonlyArray<
    EvalGraderLabelModel | EvalGraderStringCheck | EvalGraderTextSimilarity | EvalGraderPython | EvalGraderScoreModel
  >
  readonly "created_at": number
  readonly "metadata": Metadata
}
export const Eval = Schema.Struct({
  "object": Schema.Literal("eval").annotate({ "description": "The object type." }),
  "id": Schema.String.annotate({ "description": "Unique identifier for the evaluation." }),
  "name": Schema.String.annotate({ "description": "The name of the evaluation." }),
  "data_source_config": Schema.Union([
    EvalCustomDataSourceConfig,
    EvalLogsDataSourceConfig,
    EvalStoredCompletionsDataSourceConfig
  ], { mode: "oneOf" }).annotate({ "description": "Configuration of data sources used in runs of the evaluation." }),
  "testing_criteria": Schema.Array(
    Schema.Union([
      EvalGraderLabelModel,
      EvalGraderStringCheck,
      EvalGraderTextSimilarity,
      EvalGraderPython,
      EvalGraderScoreModel
    ], { mode: "oneOf" })
  ).annotate({ "description": "A list of testing criteria." }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the eval was created."
  }).check(Schema.isInt()),
  "metadata": Metadata
}).annotate({
  "title": "Eval",
  "description":
    "An Eval object with a data source config and testing criteria.\nAn Eval represents a task to be done for your LLM integration.\nLike:\n - Improve the quality of my chatbot\n - See how well my chatbot handles customer support\n - Check if o4-mini is better at my usecase than gpt-4o\n"
})
export type GraderMulti = {
  readonly "type": "multi"
  readonly "name": string
  readonly "graders": GraderStringCheck | GraderTextSimilarity | GraderPython | GraderScoreModel | GraderLabelModel
  readonly "calculate_output": string
}
export const GraderMulti = Schema.Struct({
  "type": Schema.Literal("multi").annotate({ "description": "The object type, which is always `multi`." }),
  "name": Schema.String.annotate({ "description": "The name of the grader." }),
  "graders": Schema.Union([GraderStringCheck, GraderTextSimilarity, GraderPython, GraderScoreModel, GraderLabelModel], {
    mode: "oneOf"
  }),
  "calculate_output": Schema.String.annotate({
    "description": "A formula to calculate the output based on grader results."
  })
}).annotate({
  "title": "MultiGrader",
  "description": "A MultiGrader object combines the output of multiple graders to produce a single score."
})
export type InputParam = string | ReadonlyArray<InputItem>
export const InputParam = Schema.Union([
  Schema.String.annotate({
    "title": "Text input",
    "description": "A text input to the model, equivalent to a text input with the\n`user` role.\n"
  }),
  Schema.Array(InputItem).annotate({
    "title": "Input item list",
    "description": "A list of one or many input items to the model, containing\ndifferent content types.\n"
  })
], { mode: "oneOf" }).annotate({
  "description":
    "Text, image, or file inputs to the model, used to generate a response.\n\nLearn more:\n- [Text inputs and outputs](/docs/guides/text)\n- [Image inputs](/docs/guides/images)\n- [File inputs](/docs/guides/pdf-files)\n- [Conversation state](/docs/guides/conversation-state)\n- [Function calling](/docs/guides/function-calling)\n"
})
export type CreateConversationBody = {
  readonly "metadata"?: {} | null | null
  readonly "items"?: ReadonlyArray<InputItem> | null
}
export const CreateConversationBody = Schema.Struct({
  "metadata": Schema.optionalKey(Schema.Union([
    Schema.Union([
      Schema.Struct({}).annotate({
        "description":
          "Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard.\n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n"
      }),
      Schema.Null
    ]).annotate({
      "description":
        "Set of 16 key-value pairs that can be attached to an object. This can be         useful for storing additional information about the object in a structured         format, and querying for objects via API or the dashboard.\n        Keys are strings with a maximum length of 64 characters. Values are strings         with a maximum length of 512 characters."
    }),
    Schema.Null
  ])),
  "items": Schema.optionalKey(
    Schema.Union([
      Schema.Array(InputItem).annotate({
        "description": "Initial items to include in the conversation context. You may add up to 20 items at a time."
      }).check(Schema.isMaxLength(20)),
      Schema.Null
    ])
  )
})
export type TokenCountsBody = {
  readonly "model"?: string | null
  readonly "input"?: string | ReadonlyArray<InputItem> | null
  readonly "previous_response_id"?: string | null
  readonly "tools"?: ReadonlyArray<Tool> | null
  readonly "text"?: ResponseTextParam | null
  readonly "reasoning"?: {
    readonly "effort"?: ReasoningEffort
    readonly "summary"?: "auto" | "concise" | "detailed" | null
    readonly "generate_summary"?: "auto" | "concise" | "detailed" | null
  } | null
  readonly "truncation"?: "auto" | "disabled"
  readonly "instructions"?: string | null
  readonly "conversation"?: ConversationParam | null
  readonly "tool_choice"?:
    | ToolChoiceOptions
    | ToolChoiceAllowed
    | ToolChoiceTypes
    | ToolChoiceFunction
    | ToolChoiceMCP
    | ToolChoiceCustom
    | SpecificApplyPatchParam
    | SpecificFunctionShellParam
    | null
  readonly "parallel_tool_calls"?: boolean | null
}
export const TokenCountsBody = Schema.Struct({
  "model": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI offers a wide range of models with different capabilities, performance characteristics, and price points. Refer to the [model guide](/docs/models) to browse and compare available models."
      }),
      Schema.Null
    ])
  ),
  "input": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        Schema.String.annotate({
          "description": "A text input to the model, equivalent to a text input with the `user` role."
        }).check(Schema.isMaxLength(10485760)),
        Schema.Array(InputItem).annotate({
          "description": "A list of one or many input items to the model, containing different content types."
        })
      ], { mode: "oneOf" }).annotate({
        "description": "Text, image, or file inputs to the model, used to generate a response"
      }),
      Schema.Null
    ])
  ),
  "previous_response_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "The unique ID of the previous response to the model. Use this to create multi-turn conversations. Learn more about [conversation state](/docs/guides/conversation-state). Cannot be used in conjunction with `conversation`."
      }),
      Schema.Null
    ])
  ),
  "tools": Schema.optionalKey(
    Schema.Union([
      Schema.Array(Tool).annotate({
        "description":
          "An array of tools the model may call while generating a response. You can specify which tool to use by setting the `tool_choice` parameter."
      }),
      Schema.Null
    ])
  ),
  "text": Schema.optionalKey(Schema.Union([ResponseTextParam, Schema.Null])),
  "reasoning": Schema.optionalKey(Schema.Union([
    Schema.Struct({
      "effort": Schema.optionalKey(ReasoningEffort),
      "summary": Schema.optionalKey(Schema.Union([
        Schema.Literals(["auto", "concise", "detailed"]).annotate({
          "description":
            "A summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model's reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n\n`concise` is supported for `computer-use-preview` models and all reasoning models after `gpt-5`.\n"
        }),
        Schema.Null
      ])),
      "generate_summary": Schema.optionalKey(
        Schema.Union([
          Schema.Literals(["auto", "concise", "detailed"]).annotate({
            "description":
              "**Deprecated:** use `summary` instead.\n\nA summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model's reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n"
          }),
          Schema.Null
        ])
      )
    }).annotate({
      "title": "Reasoning",
      "description":
        "**gpt-5 and o-series models only** Configuration options for [reasoning models](https://platform.openai.com/docs/guides/reasoning)."
    }),
    Schema.Null
  ])),
  "truncation": Schema.optionalKey(
    Schema.Literals(["auto", "disabled"]).annotate({
      "description":
        "The truncation strategy to use for the model response. - `auto`: If the input to this Response exceeds the model's context window size, the model will truncate the response to fit the context window by dropping items from the beginning of the conversation. - `disabled` (default): If the input size will exceed the context window size for a model, the request will fail with a 400 error."
    })
  ),
  "instructions": Schema.optionalKey(Schema.Union([
    Schema.String.annotate({
      "description":
        "A system (or developer) message inserted into the model's context.\nWhen used along with `previous_response_id`, the instructions from a previous response will not be carried over to the next response. This makes it simple to swap out system (or developer) messages in new responses."
    }),
    Schema.Null
  ])),
  "conversation": Schema.optionalKey(Schema.Union([ConversationParam, Schema.Null])),
  "tool_choice": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        ToolChoiceOptions,
        ToolChoiceAllowed,
        ToolChoiceTypes,
        ToolChoiceFunction,
        ToolChoiceMCP,
        ToolChoiceCustom,
        SpecificApplyPatchParam,
        SpecificFunctionShellParam
      ], { mode: "oneOf" }).annotate({ "description": "Controls which tool the model should use, if any." }),
      Schema.Null
    ])
  ),
  "parallel_tool_calls": Schema.optionalKey(
    Schema.Union([
      Schema.Boolean.annotate({ "description": "Whether to allow the model to run tool calls in parallel." }),
      Schema.Null
    ])
  )
})
export type CompactResponseMethodPublicBody = {
  readonly "model": ModelIdsCompaction
  readonly "input"?: string | ReadonlyArray<InputItem> | null
  readonly "previous_response_id"?: string | null
  readonly "instructions"?: string | null
  readonly "prompt_cache_key"?: string | null
}
export const CompactResponseMethodPublicBody = Schema.Struct({
  "model": ModelIdsCompaction,
  "input": Schema.optionalKey(
    Schema.Union([
      Schema.Union([
        Schema.String.annotate({
          "description": "A text input to the model, equivalent to a text input with the `user` role."
        }).check(Schema.isMaxLength(10485760)),
        Schema.Array(InputItem).annotate({
          "description": "A list of one or many input items to the model, containing different content types."
        })
      ], { mode: "oneOf" }).annotate({
        "description": "Text, image, or file inputs to the model, used to generate a response"
      }),
      Schema.Null
    ])
  ),
  "previous_response_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "The unique ID of the previous response to the model. Use this to create multi-turn conversations. Learn more about [conversation state](/docs/guides/conversation-state). Cannot be used in conjunction with `conversation`."
      }),
      Schema.Null
    ])
  ),
  "instructions": Schema.optionalKey(Schema.Union([
    Schema.String.annotate({
      "description":
        "A system (or developer) message inserted into the model's context.\nWhen used along with `previous_response_id`, the instructions from a previous response will not be carried over to the next response. This makes it simple to swap out system (or developer) messages in new responses."
    }),
    Schema.Null
  ])),
  "prompt_cache_key": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({ "description": "A key to use when reading from or writing to the prompt cache." }).check(
        Schema.isMaxLength(64)
      ),
      Schema.Null
    ])
  )
})
export type ResponseItemList = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<ItemResource>
  readonly "has_more": boolean
  readonly "first_id": string
  readonly "last_id": string
}
export const ResponseItemList = Schema.Struct({
  "object": Schema.Literal("list").annotate({ "description": "The type of object returned, must be `list`." }),
  "data": Schema.Array(ItemResource).annotate({ "description": "A list of items used to generate this response." }),
  "has_more": Schema.Boolean.annotate({ "description": "Whether there are more items available." }),
  "first_id": Schema.String.annotate({ "description": "The ID of the first item in the list." }),
  "last_id": Schema.String.annotate({ "description": "The ID of the last item in the list." })
}).annotate({ "description": "A list of Response items." })
export type Response = {
  readonly "metadata": {} | null
  readonly "top_logprobs"?: number | null
  readonly "temperature": number | null
  readonly "top_p": number | null
  readonly "user"?: string | null
  readonly "safety_identifier"?: string | null
  readonly "prompt_cache_key"?: string | null
  readonly "service_tier"?: ServiceTier
  readonly "prompt_cache_retention"?: "in-memory" | "24h" | null
  readonly "previous_response_id"?: string | null
  readonly "model":
    | ModelIdsShared
    | "o1-pro"
    | "o1-pro-2025-03-19"
    | "o3-pro"
    | "o3-pro-2025-06-10"
    | "o3-deep-research"
    | "o3-deep-research-2025-06-26"
    | "o4-mini-deep-research"
    | "o4-mini-deep-research-2025-06-26"
    | "computer-use-preview"
    | "computer-use-preview-2025-03-11"
    | "gpt-5-codex"
    | "gpt-5-pro"
    | "gpt-5-pro-2025-10-06"
    | "gpt-5.1-codex-max"
  readonly "reasoning"?: Reasoning | null
  readonly "background"?: boolean | null
  readonly "max_output_tokens"?: number | null
  readonly "max_tool_calls"?: number | null
  readonly "text"?: ResponseTextParam
  readonly "tools": ReadonlyArray<Tool>
  readonly "tool_choice":
    | ToolChoiceOptions
    | ToolChoiceAllowed
    | ToolChoiceTypes
    | ToolChoiceFunction
    | ToolChoiceMCP
    | ToolChoiceCustom
    | SpecificApplyPatchParam
    | SpecificFunctionShellParam
  readonly "prompt"?: Prompt
  readonly "truncation"?: "auto" | "disabled" | null
  readonly "id": string
  readonly "object": "response"
  readonly "status"?: "completed" | "failed" | "in_progress" | "cancelled" | "queued" | "incomplete"
  readonly "created_at": number
  readonly "completed_at"?: number | null
  readonly "error": ResponseError
  readonly "incomplete_details": { readonly "reason"?: "max_output_tokens" | "content_filter" } | null
  readonly "output": ReadonlyArray<OutputItem>
  readonly "instructions": string | ReadonlyArray<InputItem> | null
  readonly "output_text"?: string | null
  readonly "usage"?: ResponseUsage | null
  readonly "parallel_tool_calls": boolean
  readonly "conversation"?: Conversation_2 | null
}
export const Response = Schema.Struct({
  "metadata": Schema.Union([
    Schema.Struct({}).annotate({
      "description":
        "Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard.\n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n"
    }),
    Schema.Null
  ]),
  "top_logprobs": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"
      }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(20)),
      Schema.Null
    ])
  ),
  "temperature": Schema.Union([
    Schema.Number.annotate({
      "description":
        "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"
    }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(2)),
    Schema.Null
  ]),
  "top_p": Schema.Union([
    Schema.Number.annotate({
      "description":
        "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"
    }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1)),
    Schema.Null
  ]),
  "user": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "This field is being replaced by `safety_identifier` and `prompt_cache_key`. Use `prompt_cache_key` instead to maintain caching optimizations.\nA stable identifier for your end-users.\nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
    })
  ),
  "safety_identifier": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies.\nThe IDs should be a string that uniquely identifies each user, with a maximum length of 64 characters. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
    })
  ),
  "prompt_cache_key": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the `user` field. [Learn more](/docs/guides/prompt-caching).\n"
    })
  ),
  "service_tier": Schema.optionalKey(ServiceTier),
  "prompt_cache_retention": Schema.optionalKey(
    Schema.Union([
      Schema.Literals(["in-memory", "24h"]).annotate({
        "description":
          "The retention policy for the prompt cache. Set to `24h` to enable extended prompt caching, which keeps cached prefixes active for longer, up to a maximum of 24 hours. [Learn more](/docs/guides/prompt-caching#prompt-cache-retention).\n"
      }),
      Schema.Null
    ])
  ),
  "previous_response_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "The unique ID of the previous response to the model. Use this to\ncreate multi-turn conversations. Learn more about\n[conversation state](/docs/guides/conversation-state). Cannot be used in conjunction with `conversation`.\n"
      }),
      Schema.Null
    ])
  ),
  "model": Schema.Union([
    ModelIdsShared,
    Schema.Literals([
      "o1-pro",
      "o1-pro-2025-03-19",
      "o3-pro",
      "o3-pro-2025-06-10",
      "o3-deep-research",
      "o3-deep-research-2025-06-26",
      "o4-mini-deep-research",
      "o4-mini-deep-research-2025-06-26",
      "computer-use-preview",
      "computer-use-preview-2025-03-11",
      "gpt-5-codex",
      "gpt-5-pro",
      "gpt-5-pro-2025-10-06",
      "gpt-5.1-codex-max"
    ]).annotate({ "title": "ResponsesOnlyModel" })
  ]).annotate({
    "description":
      "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](/docs/models)\nto browse and compare available models.\n"
  }),
  "reasoning": Schema.optionalKey(Schema.Union([Reasoning, Schema.Null])),
  "background": Schema.optionalKey(
    Schema.Union([
      Schema.Boolean.annotate({
        "description": "Whether to run the model response in the background.\n[Learn more](/docs/guides/background).\n"
      }),
      Schema.Null
    ])
  ),
  "max_output_tokens": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](/docs/guides/reasoning).\n"
      }).check(Schema.isInt()),
      Schema.Null
    ])
  ),
  "max_tool_calls": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "The maximum number of total calls to built-in tools that can be processed in a response. This maximum number applies across all built-in tool calls, not per individual tool. Any further attempts to call a tool by the model will be ignored.\n"
      }).check(Schema.isInt()),
      Schema.Null
    ])
  ),
  "text": Schema.optionalKey(ResponseTextParam),
  "tools": Schema.Array(Tool).annotate({
    "description":
      "An array of tools the model may call while generating a response. You\ncan specify which tool to use by setting the `tool_choice` parameter.\n\nWe support the following categories of tools:\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](/docs/guides/tools-web-search)\n  or [file search](/docs/guides/tools-file-search). Learn more about\n  [built-in tools](/docs/guides/tools).\n- **MCP Tools**: Integrations with third-party systems via custom MCP servers\n  or predefined connectors such as Google Drive and SharePoint. Learn more about\n  [MCP Tools](/docs/guides/tools-connectors-mcp).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code with strongly typed arguments\n  and outputs. Learn more about\n  [function calling](/docs/guides/function-calling). You can also use\n  custom tools to call your own code.\n"
  }),
  "tool_choice": Schema.Union([
    ToolChoiceOptions,
    ToolChoiceAllowed,
    ToolChoiceTypes,
    ToolChoiceFunction,
    ToolChoiceMCP,
    ToolChoiceCustom,
    SpecificApplyPatchParam,
    SpecificFunctionShellParam
  ], { mode: "oneOf" }).annotate({
    "description":
      "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"
  }),
  "prompt": Schema.optionalKey(Prompt),
  "truncation": Schema.optionalKey(Schema.Union([
    Schema.Literals(["auto", "disabled"]).annotate({
      "description":
        "The truncation strategy to use for the model response.\n- `auto`: If the input to this Response exceeds\n  the model's context window size, the model will truncate the\n  response to fit the context window by dropping items from the beginning of the conversation.\n- `disabled` (default): If the input size will exceed the context window\n  size for a model, the request will fail with a 400 error.\n"
    }),
    Schema.Null
  ])),
  "id": Schema.String.annotate({ "description": "Unique identifier for this Response.\n" }),
  "object": Schema.Literal("response").annotate({
    "description": "The object type of this resource - always set to `response`.\n"
  }),
  "status": Schema.optionalKey(
    Schema.Literals(["completed", "failed", "in_progress", "cancelled", "queued", "incomplete"]).annotate({
      "description":
        "The status of the response generation. One of `completed`, `failed`,\n`in_progress`, `cancelled`, `queued`, or `incomplete`.\n"
    })
  ),
  "created_at": Schema.Number.annotate({
    "description": "Unix timestamp (in seconds) of when this Response was created.\n"
  }).check(Schema.isFinite()),
  "completed_at": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "Unix timestamp (in seconds) of when this Response was completed.\nOnly present when the status is `completed`.\n"
      }).check(Schema.isFinite()),
      Schema.Null
    ])
  ),
  "error": ResponseError,
  "incomplete_details": Schema.Union([
    Schema.Struct({
      "reason": Schema.optionalKey(
        Schema.Literals(["max_output_tokens", "content_filter"]).annotate({
          "description": "The reason why the response is incomplete."
        })
      )
    }).annotate({ "description": "Details about why the response is incomplete.\n" }),
    Schema.Null
  ]),
  "output": Schema.Array(OutputItem).annotate({
    "description":
      "An array of content items generated by the model.\n\n- The length and order of items in the `output` array is dependent\n  on the model's response.\n- Rather than accessing the first item in the `output` array and\n  assuming it's an `assistant` message with the content generated by\n  the model, you might consider using the `output_text` property where\n  supported in SDKs.\n"
  }),
  "instructions": Schema.Union([
    Schema.Union([
      Schema.String.annotate({
        "description": "A text input to the model, equivalent to a text input with the\n`developer` role.\n"
      }),
      Schema.Array(InputItem).annotate({
        "title": "Input item list",
        "description": "A list of one or many input items to the model, containing\ndifferent content types.\n"
      })
    ], { mode: "oneOf" }).annotate({
      "description":
        "A system (or developer) message inserted into the model's context.\n\nWhen using along with `previous_response_id`, the instructions from a previous\nresponse will not be carried over to the next response. This makes it simple\nto swap out system (or developer) messages in new responses.\n"
    }),
    Schema.Null
  ]),
  "output_text": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "SDK-only convenience property that contains the aggregated text output\nfrom all `output_text` items in the `output` array, if any are present.\nSupported in the Python and JavaScript SDKs.\n"
      }),
      Schema.Null
    ])
  ),
  "usage": Schema.optionalKey(Schema.Union([ResponseUsage, Schema.Null])),
  "parallel_tool_calls": Schema.Boolean.annotate({
    "description": "Whether to allow the model to run tool calls in parallel.\n"
  }),
  "conversation": Schema.optionalKey(Schema.Union([Conversation_2, Schema.Null]))
}).annotate({ "title": "The response object" })
export type ResponseCompletedEvent = {
  readonly "type": "response.completed"
  readonly "response": {
    readonly "metadata": {} | null
    readonly "top_logprobs"?: number | null
    readonly "temperature": number | null
    readonly "top_p": number | null
    readonly "user"?: string | null
    readonly "safety_identifier"?: string | null
    readonly "prompt_cache_key"?: string | null
    readonly "service_tier"?: ServiceTier
    readonly "prompt_cache_retention"?: "in-memory" | "24h" | null
    readonly "previous_response_id"?: string | null
    readonly "model":
      | ModelIdsShared
      | "o1-pro"
      | "o1-pro-2025-03-19"
      | "o3-pro"
      | "o3-pro-2025-06-10"
      | "o3-deep-research"
      | "o3-deep-research-2025-06-26"
      | "o4-mini-deep-research"
      | "o4-mini-deep-research-2025-06-26"
      | "computer-use-preview"
      | "computer-use-preview-2025-03-11"
      | "gpt-5-codex"
      | "gpt-5-pro"
      | "gpt-5-pro-2025-10-06"
      | "gpt-5.1-codex-max"
    readonly "reasoning"?: Reasoning | null
    readonly "background"?: boolean | null
    readonly "max_output_tokens"?: number | null
    readonly "max_tool_calls"?: number | null
    readonly "text"?: ResponseTextParam
    readonly "tools": ReadonlyArray<Tool>
    readonly "tool_choice":
      | ToolChoiceOptions
      | ToolChoiceAllowed
      | ToolChoiceTypes
      | ToolChoiceFunction
      | ToolChoiceMCP
      | ToolChoiceCustom
      | SpecificApplyPatchParam
      | SpecificFunctionShellParam
    readonly "prompt"?: Prompt
    readonly "truncation"?: "auto" | "disabled" | null
    readonly "id": string
    readonly "object": "response"
    readonly "status"?: "completed" | "failed" | "in_progress" | "cancelled" | "queued" | "incomplete"
    readonly "created_at": number
    readonly "completed_at"?: number | null
    readonly "error": ResponseError
    readonly "incomplete_details": { readonly "reason"?: "max_output_tokens" | "content_filter" } | null
    readonly "output": ReadonlyArray<OutputItem>
    readonly "instructions": string | ReadonlyArray<InputItem> | null
    readonly "output_text"?: string | null
    readonly "usage"?: ResponseUsage | null
    readonly "parallel_tool_calls": boolean
    readonly "conversation"?: Conversation_2 | null
  }
  readonly "sequence_number": number
}
export const ResponseCompletedEvent = Schema.Struct({
  "type": Schema.Literal("response.completed").annotate({
    "description": "The type of the event. Always `response.completed`.\n"
  }),
  "response": Schema.Struct({
    "metadata": Schema.Union([
      Schema.Struct({}).annotate({
        "description":
          "Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard.\n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n"
      }),
      Schema.Null
    ]),
    "top_logprobs": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"
        }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(20)),
        Schema.Null
      ])
    ),
    "temperature": Schema.Union([
      Schema.Number.annotate({
        "description":
          "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(2)),
      Schema.Null
    ]),
    "top_p": Schema.Union([
      Schema.Number.annotate({
        "description":
          "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1)),
      Schema.Null
    ]),
    "user": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "This field is being replaced by `safety_identifier` and `prompt_cache_key`. Use `prompt_cache_key` instead to maintain caching optimizations.\nA stable identifier for your end-users.\nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
      })
    ),
    "safety_identifier": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies.\nThe IDs should be a string that uniquely identifies each user, with a maximum length of 64 characters. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
      })
    ),
    "prompt_cache_key": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the `user` field. [Learn more](/docs/guides/prompt-caching).\n"
      })
    ),
    "service_tier": Schema.optionalKey(ServiceTier),
    "prompt_cache_retention": Schema.optionalKey(
      Schema.Union([
        Schema.Literals(["in-memory", "24h"]).annotate({
          "description":
            "The retention policy for the prompt cache. Set to `24h` to enable extended prompt caching, which keeps cached prefixes active for longer, up to a maximum of 24 hours. [Learn more](/docs/guides/prompt-caching#prompt-cache-retention).\n"
        }),
        Schema.Null
      ])
    ),
    "previous_response_id": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description":
            "The unique ID of the previous response to the model. Use this to\ncreate multi-turn conversations. Learn more about\n[conversation state](/docs/guides/conversation-state). Cannot be used in conjunction with `conversation`.\n"
        }),
        Schema.Null
      ])
    ),
    "model": Schema.Union([
      ModelIdsShared,
      Schema.Literals([
        "o1-pro",
        "o1-pro-2025-03-19",
        "o3-pro",
        "o3-pro-2025-06-10",
        "o3-deep-research",
        "o3-deep-research-2025-06-26",
        "o4-mini-deep-research",
        "o4-mini-deep-research-2025-06-26",
        "computer-use-preview",
        "computer-use-preview-2025-03-11",
        "gpt-5-codex",
        "gpt-5-pro",
        "gpt-5-pro-2025-10-06",
        "gpt-5.1-codex-max"
      ]).annotate({ "title": "ResponsesOnlyModel" })
    ]).annotate({
      "description":
        "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](/docs/models)\nto browse and compare available models.\n"
    }),
    "reasoning": Schema.optionalKey(Schema.Union([Reasoning, Schema.Null])),
    "background": Schema.optionalKey(
      Schema.Union([
        Schema.Boolean.annotate({
          "description":
            "Whether to run the model response in the background.\n[Learn more](/docs/guides/background).\n"
        }),
        Schema.Null
      ])
    ),
    "max_output_tokens": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](/docs/guides/reasoning).\n"
        }).check(Schema.isInt()),
        Schema.Null
      ])
    ),
    "max_tool_calls": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "The maximum number of total calls to built-in tools that can be processed in a response. This maximum number applies across all built-in tool calls, not per individual tool. Any further attempts to call a tool by the model will be ignored.\n"
        }).check(Schema.isInt()),
        Schema.Null
      ])
    ),
    "text": Schema.optionalKey(ResponseTextParam),
    "tools": Schema.Array(Tool).annotate({
      "description":
        "An array of tools the model may call while generating a response. You\ncan specify which tool to use by setting the `tool_choice` parameter.\n\nWe support the following categories of tools:\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](/docs/guides/tools-web-search)\n  or [file search](/docs/guides/tools-file-search). Learn more about\n  [built-in tools](/docs/guides/tools).\n- **MCP Tools**: Integrations with third-party systems via custom MCP servers\n  or predefined connectors such as Google Drive and SharePoint. Learn more about\n  [MCP Tools](/docs/guides/tools-connectors-mcp).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code with strongly typed arguments\n  and outputs. Learn more about\n  [function calling](/docs/guides/function-calling). You can also use\n  custom tools to call your own code.\n"
    }),
    "tool_choice": Schema.Union([
      ToolChoiceOptions,
      ToolChoiceAllowed,
      ToolChoiceTypes,
      ToolChoiceFunction,
      ToolChoiceMCP,
      ToolChoiceCustom,
      SpecificApplyPatchParam,
      SpecificFunctionShellParam
    ], { mode: "oneOf" }).annotate({
      "description":
        "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"
    }),
    "prompt": Schema.optionalKey(Prompt),
    "truncation": Schema.optionalKey(Schema.Union([
      Schema.Literals(["auto", "disabled"]).annotate({
        "description":
          "The truncation strategy to use for the model response.\n- `auto`: If the input to this Response exceeds\n  the model's context window size, the model will truncate the\n  response to fit the context window by dropping items from the beginning of the conversation.\n- `disabled` (default): If the input size will exceed the context window\n  size for a model, the request will fail with a 400 error.\n"
      }),
      Schema.Null
    ])),
    "id": Schema.String.annotate({ "description": "Unique identifier for this Response.\n" }),
    "object": Schema.Literal("response").annotate({
      "description": "The object type of this resource - always set to `response`.\n"
    }),
    "status": Schema.optionalKey(
      Schema.Literals(["completed", "failed", "in_progress", "cancelled", "queued", "incomplete"]).annotate({
        "description":
          "The status of the response generation. One of `completed`, `failed`,\n`in_progress`, `cancelled`, `queued`, or `incomplete`.\n"
      })
    ),
    "created_at": Schema.Number.annotate({
      "description": "Unix timestamp (in seconds) of when this Response was created.\n"
    }).check(Schema.isFinite()),
    "completed_at": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "Unix timestamp (in seconds) of when this Response was completed.\nOnly present when the status is `completed`.\n"
        }).check(Schema.isFinite()),
        Schema.Null
      ])
    ),
    "error": ResponseError,
    "incomplete_details": Schema.Union([
      Schema.Struct({
        "reason": Schema.optionalKey(
          Schema.Literals(["max_output_tokens", "content_filter"]).annotate({
            "description": "The reason why the response is incomplete."
          })
        )
      }).annotate({ "description": "Details about why the response is incomplete.\n" }),
      Schema.Null
    ]),
    "output": Schema.Array(OutputItem).annotate({
      "description":
        "An array of content items generated by the model.\n\n- The length and order of items in the `output` array is dependent\n  on the model's response.\n- Rather than accessing the first item in the `output` array and\n  assuming it's an `assistant` message with the content generated by\n  the model, you might consider using the `output_text` property where\n  supported in SDKs.\n"
    }),
    "instructions": Schema.Union([
      Schema.Union([
        Schema.String.annotate({
          "description": "A text input to the model, equivalent to a text input with the\n`developer` role.\n"
        }),
        Schema.Array(InputItem).annotate({
          "title": "Input item list",
          "description": "A list of one or many input items to the model, containing\ndifferent content types.\n"
        })
      ], { mode: "oneOf" }).annotate({
        "description":
          "A system (or developer) message inserted into the model's context.\n\nWhen using along with `previous_response_id`, the instructions from a previous\nresponse will not be carried over to the next response. This makes it simple\nto swap out system (or developer) messages in new responses.\n"
      }),
      Schema.Null
    ]),
    "output_text": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description":
            "SDK-only convenience property that contains the aggregated text output\nfrom all `output_text` items in the `output` array, if any are present.\nSupported in the Python and JavaScript SDKs.\n"
        }),
        Schema.Null
      ])
    ),
    "usage": Schema.optionalKey(Schema.Union([ResponseUsage, Schema.Null])),
    "parallel_tool_calls": Schema.Boolean.annotate({
      "description": "Whether to allow the model to run tool calls in parallel.\n"
    }),
    "conversation": Schema.optionalKey(Schema.Union([Conversation_2, Schema.Null]))
  }).annotate({ "title": "The response object", "description": "Properties of the completed response.\n" }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number for this event." }).check(
    Schema.isInt()
  )
}).annotate({ "description": "Emitted when the model response is complete." })
export type ResponseCreatedEvent = {
  readonly "type": "response.created"
  readonly "response": {
    readonly "metadata": {} | null
    readonly "top_logprobs"?: number | null
    readonly "temperature": number | null
    readonly "top_p": number | null
    readonly "user"?: string | null
    readonly "safety_identifier"?: string | null
    readonly "prompt_cache_key"?: string | null
    readonly "service_tier"?: ServiceTier
    readonly "prompt_cache_retention"?: "in-memory" | "24h" | null
    readonly "previous_response_id"?: string | null
    readonly "model":
      | ModelIdsShared
      | "o1-pro"
      | "o1-pro-2025-03-19"
      | "o3-pro"
      | "o3-pro-2025-06-10"
      | "o3-deep-research"
      | "o3-deep-research-2025-06-26"
      | "o4-mini-deep-research"
      | "o4-mini-deep-research-2025-06-26"
      | "computer-use-preview"
      | "computer-use-preview-2025-03-11"
      | "gpt-5-codex"
      | "gpt-5-pro"
      | "gpt-5-pro-2025-10-06"
      | "gpt-5.1-codex-max"
    readonly "reasoning"?: Reasoning | null
    readonly "background"?: boolean | null
    readonly "max_output_tokens"?: number | null
    readonly "max_tool_calls"?: number | null
    readonly "text"?: ResponseTextParam
    readonly "tools": ReadonlyArray<Tool>
    readonly "tool_choice":
      | ToolChoiceOptions
      | ToolChoiceAllowed
      | ToolChoiceTypes
      | ToolChoiceFunction
      | ToolChoiceMCP
      | ToolChoiceCustom
      | SpecificApplyPatchParam
      | SpecificFunctionShellParam
    readonly "prompt"?: Prompt
    readonly "truncation"?: "auto" | "disabled" | null
    readonly "id": string
    readonly "object": "response"
    readonly "status"?: "completed" | "failed" | "in_progress" | "cancelled" | "queued" | "incomplete"
    readonly "created_at": number
    readonly "completed_at"?: number | null
    readonly "error": ResponseError
    readonly "incomplete_details": { readonly "reason"?: "max_output_tokens" | "content_filter" } | null
    readonly "output": ReadonlyArray<OutputItem>
    readonly "instructions": string | ReadonlyArray<InputItem> | null
    readonly "output_text"?: string | null
    readonly "usage"?: ResponseUsage | null
    readonly "parallel_tool_calls": boolean
    readonly "conversation"?: Conversation_2 | null
  }
  readonly "sequence_number": number
}
export const ResponseCreatedEvent = Schema.Struct({
  "type": Schema.Literal("response.created").annotate({
    "description": "The type of the event. Always `response.created`.\n"
  }),
  "response": Schema.Struct({
    "metadata": Schema.Union([
      Schema.Struct({}).annotate({
        "description":
          "Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard.\n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n"
      }),
      Schema.Null
    ]),
    "top_logprobs": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"
        }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(20)),
        Schema.Null
      ])
    ),
    "temperature": Schema.Union([
      Schema.Number.annotate({
        "description":
          "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(2)),
      Schema.Null
    ]),
    "top_p": Schema.Union([
      Schema.Number.annotate({
        "description":
          "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1)),
      Schema.Null
    ]),
    "user": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "This field is being replaced by `safety_identifier` and `prompt_cache_key`. Use `prompt_cache_key` instead to maintain caching optimizations.\nA stable identifier for your end-users.\nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
      })
    ),
    "safety_identifier": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies.\nThe IDs should be a string that uniquely identifies each user, with a maximum length of 64 characters. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
      })
    ),
    "prompt_cache_key": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the `user` field. [Learn more](/docs/guides/prompt-caching).\n"
      })
    ),
    "service_tier": Schema.optionalKey(ServiceTier),
    "prompt_cache_retention": Schema.optionalKey(
      Schema.Union([
        Schema.Literals(["in-memory", "24h"]).annotate({
          "description":
            "The retention policy for the prompt cache. Set to `24h` to enable extended prompt caching, which keeps cached prefixes active for longer, up to a maximum of 24 hours. [Learn more](/docs/guides/prompt-caching#prompt-cache-retention).\n"
        }),
        Schema.Null
      ])
    ),
    "previous_response_id": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description":
            "The unique ID of the previous response to the model. Use this to\ncreate multi-turn conversations. Learn more about\n[conversation state](/docs/guides/conversation-state). Cannot be used in conjunction with `conversation`.\n"
        }),
        Schema.Null
      ])
    ),
    "model": Schema.Union([
      ModelIdsShared,
      Schema.Literals([
        "o1-pro",
        "o1-pro-2025-03-19",
        "o3-pro",
        "o3-pro-2025-06-10",
        "o3-deep-research",
        "o3-deep-research-2025-06-26",
        "o4-mini-deep-research",
        "o4-mini-deep-research-2025-06-26",
        "computer-use-preview",
        "computer-use-preview-2025-03-11",
        "gpt-5-codex",
        "gpt-5-pro",
        "gpt-5-pro-2025-10-06",
        "gpt-5.1-codex-max"
      ]).annotate({ "title": "ResponsesOnlyModel" })
    ]).annotate({
      "description":
        "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](/docs/models)\nto browse and compare available models.\n"
    }),
    "reasoning": Schema.optionalKey(Schema.Union([Reasoning, Schema.Null])),
    "background": Schema.optionalKey(
      Schema.Union([
        Schema.Boolean.annotate({
          "description":
            "Whether to run the model response in the background.\n[Learn more](/docs/guides/background).\n"
        }),
        Schema.Null
      ])
    ),
    "max_output_tokens": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](/docs/guides/reasoning).\n"
        }).check(Schema.isInt()),
        Schema.Null
      ])
    ),
    "max_tool_calls": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "The maximum number of total calls to built-in tools that can be processed in a response. This maximum number applies across all built-in tool calls, not per individual tool. Any further attempts to call a tool by the model will be ignored.\n"
        }).check(Schema.isInt()),
        Schema.Null
      ])
    ),
    "text": Schema.optionalKey(ResponseTextParam),
    "tools": Schema.Array(Tool).annotate({
      "description":
        "An array of tools the model may call while generating a response. You\ncan specify which tool to use by setting the `tool_choice` parameter.\n\nWe support the following categories of tools:\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](/docs/guides/tools-web-search)\n  or [file search](/docs/guides/tools-file-search). Learn more about\n  [built-in tools](/docs/guides/tools).\n- **MCP Tools**: Integrations with third-party systems via custom MCP servers\n  or predefined connectors such as Google Drive and SharePoint. Learn more about\n  [MCP Tools](/docs/guides/tools-connectors-mcp).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code with strongly typed arguments\n  and outputs. Learn more about\n  [function calling](/docs/guides/function-calling). You can also use\n  custom tools to call your own code.\n"
    }),
    "tool_choice": Schema.Union([
      ToolChoiceOptions,
      ToolChoiceAllowed,
      ToolChoiceTypes,
      ToolChoiceFunction,
      ToolChoiceMCP,
      ToolChoiceCustom,
      SpecificApplyPatchParam,
      SpecificFunctionShellParam
    ], { mode: "oneOf" }).annotate({
      "description":
        "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"
    }),
    "prompt": Schema.optionalKey(Prompt),
    "truncation": Schema.optionalKey(Schema.Union([
      Schema.Literals(["auto", "disabled"]).annotate({
        "description":
          "The truncation strategy to use for the model response.\n- `auto`: If the input to this Response exceeds\n  the model's context window size, the model will truncate the\n  response to fit the context window by dropping items from the beginning of the conversation.\n- `disabled` (default): If the input size will exceed the context window\n  size for a model, the request will fail with a 400 error.\n"
      }),
      Schema.Null
    ])),
    "id": Schema.String.annotate({ "description": "Unique identifier for this Response.\n" }),
    "object": Schema.Literal("response").annotate({
      "description": "The object type of this resource - always set to `response`.\n"
    }),
    "status": Schema.optionalKey(
      Schema.Literals(["completed", "failed", "in_progress", "cancelled", "queued", "incomplete"]).annotate({
        "description":
          "The status of the response generation. One of `completed`, `failed`,\n`in_progress`, `cancelled`, `queued`, or `incomplete`.\n"
      })
    ),
    "created_at": Schema.Number.annotate({
      "description": "Unix timestamp (in seconds) of when this Response was created.\n"
    }).check(Schema.isFinite()),
    "completed_at": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "Unix timestamp (in seconds) of when this Response was completed.\nOnly present when the status is `completed`.\n"
        }).check(Schema.isFinite()),
        Schema.Null
      ])
    ),
    "error": ResponseError,
    "incomplete_details": Schema.Union([
      Schema.Struct({
        "reason": Schema.optionalKey(
          Schema.Literals(["max_output_tokens", "content_filter"]).annotate({
            "description": "The reason why the response is incomplete."
          })
        )
      }).annotate({ "description": "Details about why the response is incomplete.\n" }),
      Schema.Null
    ]),
    "output": Schema.Array(OutputItem).annotate({
      "description":
        "An array of content items generated by the model.\n\n- The length and order of items in the `output` array is dependent\n  on the model's response.\n- Rather than accessing the first item in the `output` array and\n  assuming it's an `assistant` message with the content generated by\n  the model, you might consider using the `output_text` property where\n  supported in SDKs.\n"
    }),
    "instructions": Schema.Union([
      Schema.Union([
        Schema.String.annotate({
          "description": "A text input to the model, equivalent to a text input with the\n`developer` role.\n"
        }),
        Schema.Array(InputItem).annotate({
          "title": "Input item list",
          "description": "A list of one or many input items to the model, containing\ndifferent content types.\n"
        })
      ], { mode: "oneOf" }).annotate({
        "description":
          "A system (or developer) message inserted into the model's context.\n\nWhen using along with `previous_response_id`, the instructions from a previous\nresponse will not be carried over to the next response. This makes it simple\nto swap out system (or developer) messages in new responses.\n"
      }),
      Schema.Null
    ]),
    "output_text": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description":
            "SDK-only convenience property that contains the aggregated text output\nfrom all `output_text` items in the `output` array, if any are present.\nSupported in the Python and JavaScript SDKs.\n"
        }),
        Schema.Null
      ])
    ),
    "usage": Schema.optionalKey(Schema.Union([ResponseUsage, Schema.Null])),
    "parallel_tool_calls": Schema.Boolean.annotate({
      "description": "Whether to allow the model to run tool calls in parallel.\n"
    }),
    "conversation": Schema.optionalKey(Schema.Union([Conversation_2, Schema.Null]))
  }).annotate({ "title": "The response object", "description": "The response that was created.\n" }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number for this event." }).check(
    Schema.isInt()
  )
}).annotate({ "description": "An event that is emitted when a response is created.\n" })
export type ResponseFailedEvent = {
  readonly "type": "response.failed"
  readonly "sequence_number": number
  readonly "response": {
    readonly "metadata": {} | null
    readonly "top_logprobs"?: number | null
    readonly "temperature": number | null
    readonly "top_p": number | null
    readonly "user"?: string | null
    readonly "safety_identifier"?: string | null
    readonly "prompt_cache_key"?: string | null
    readonly "service_tier"?: ServiceTier
    readonly "prompt_cache_retention"?: "in-memory" | "24h" | null
    readonly "previous_response_id"?: string | null
    readonly "model":
      | ModelIdsShared
      | "o1-pro"
      | "o1-pro-2025-03-19"
      | "o3-pro"
      | "o3-pro-2025-06-10"
      | "o3-deep-research"
      | "o3-deep-research-2025-06-26"
      | "o4-mini-deep-research"
      | "o4-mini-deep-research-2025-06-26"
      | "computer-use-preview"
      | "computer-use-preview-2025-03-11"
      | "gpt-5-codex"
      | "gpt-5-pro"
      | "gpt-5-pro-2025-10-06"
      | "gpt-5.1-codex-max"
    readonly "reasoning"?: Reasoning | null
    readonly "background"?: boolean | null
    readonly "max_output_tokens"?: number | null
    readonly "max_tool_calls"?: number | null
    readonly "text"?: ResponseTextParam
    readonly "tools": ReadonlyArray<Tool>
    readonly "tool_choice":
      | ToolChoiceOptions
      | ToolChoiceAllowed
      | ToolChoiceTypes
      | ToolChoiceFunction
      | ToolChoiceMCP
      | ToolChoiceCustom
      | SpecificApplyPatchParam
      | SpecificFunctionShellParam
    readonly "prompt"?: Prompt
    readonly "truncation"?: "auto" | "disabled" | null
    readonly "id": string
    readonly "object": "response"
    readonly "status"?: "completed" | "failed" | "in_progress" | "cancelled" | "queued" | "incomplete"
    readonly "created_at": number
    readonly "completed_at"?: number | null
    readonly "error": ResponseError
    readonly "incomplete_details": { readonly "reason"?: "max_output_tokens" | "content_filter" } | null
    readonly "output": ReadonlyArray<OutputItem>
    readonly "instructions": string | ReadonlyArray<InputItem> | null
    readonly "output_text"?: string | null
    readonly "usage"?: ResponseUsage | null
    readonly "parallel_tool_calls": boolean
    readonly "conversation"?: Conversation_2 | null
  }
}
export const ResponseFailedEvent = Schema.Struct({
  "type": Schema.Literal("response.failed").annotate({
    "description": "The type of the event. Always `response.failed`.\n"
  }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  ),
  "response": Schema.Struct({
    "metadata": Schema.Union([
      Schema.Struct({}).annotate({
        "description":
          "Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard.\n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n"
      }),
      Schema.Null
    ]),
    "top_logprobs": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"
        }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(20)),
        Schema.Null
      ])
    ),
    "temperature": Schema.Union([
      Schema.Number.annotate({
        "description":
          "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(2)),
      Schema.Null
    ]),
    "top_p": Schema.Union([
      Schema.Number.annotate({
        "description":
          "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1)),
      Schema.Null
    ]),
    "user": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "This field is being replaced by `safety_identifier` and `prompt_cache_key`. Use `prompt_cache_key` instead to maintain caching optimizations.\nA stable identifier for your end-users.\nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
      })
    ),
    "safety_identifier": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies.\nThe IDs should be a string that uniquely identifies each user, with a maximum length of 64 characters. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
      })
    ),
    "prompt_cache_key": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the `user` field. [Learn more](/docs/guides/prompt-caching).\n"
      })
    ),
    "service_tier": Schema.optionalKey(ServiceTier),
    "prompt_cache_retention": Schema.optionalKey(
      Schema.Union([
        Schema.Literals(["in-memory", "24h"]).annotate({
          "description":
            "The retention policy for the prompt cache. Set to `24h` to enable extended prompt caching, which keeps cached prefixes active for longer, up to a maximum of 24 hours. [Learn more](/docs/guides/prompt-caching#prompt-cache-retention).\n"
        }),
        Schema.Null
      ])
    ),
    "previous_response_id": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description":
            "The unique ID of the previous response to the model. Use this to\ncreate multi-turn conversations. Learn more about\n[conversation state](/docs/guides/conversation-state). Cannot be used in conjunction with `conversation`.\n"
        }),
        Schema.Null
      ])
    ),
    "model": Schema.Union([
      ModelIdsShared,
      Schema.Literals([
        "o1-pro",
        "o1-pro-2025-03-19",
        "o3-pro",
        "o3-pro-2025-06-10",
        "o3-deep-research",
        "o3-deep-research-2025-06-26",
        "o4-mini-deep-research",
        "o4-mini-deep-research-2025-06-26",
        "computer-use-preview",
        "computer-use-preview-2025-03-11",
        "gpt-5-codex",
        "gpt-5-pro",
        "gpt-5-pro-2025-10-06",
        "gpt-5.1-codex-max"
      ]).annotate({ "title": "ResponsesOnlyModel" })
    ]).annotate({
      "description":
        "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](/docs/models)\nto browse and compare available models.\n"
    }),
    "reasoning": Schema.optionalKey(Schema.Union([Reasoning, Schema.Null])),
    "background": Schema.optionalKey(
      Schema.Union([
        Schema.Boolean.annotate({
          "description":
            "Whether to run the model response in the background.\n[Learn more](/docs/guides/background).\n"
        }),
        Schema.Null
      ])
    ),
    "max_output_tokens": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](/docs/guides/reasoning).\n"
        }).check(Schema.isInt()),
        Schema.Null
      ])
    ),
    "max_tool_calls": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "The maximum number of total calls to built-in tools that can be processed in a response. This maximum number applies across all built-in tool calls, not per individual tool. Any further attempts to call a tool by the model will be ignored.\n"
        }).check(Schema.isInt()),
        Schema.Null
      ])
    ),
    "text": Schema.optionalKey(ResponseTextParam),
    "tools": Schema.Array(Tool).annotate({
      "description":
        "An array of tools the model may call while generating a response. You\ncan specify which tool to use by setting the `tool_choice` parameter.\n\nWe support the following categories of tools:\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](/docs/guides/tools-web-search)\n  or [file search](/docs/guides/tools-file-search). Learn more about\n  [built-in tools](/docs/guides/tools).\n- **MCP Tools**: Integrations with third-party systems via custom MCP servers\n  or predefined connectors such as Google Drive and SharePoint. Learn more about\n  [MCP Tools](/docs/guides/tools-connectors-mcp).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code with strongly typed arguments\n  and outputs. Learn more about\n  [function calling](/docs/guides/function-calling). You can also use\n  custom tools to call your own code.\n"
    }),
    "tool_choice": Schema.Union([
      ToolChoiceOptions,
      ToolChoiceAllowed,
      ToolChoiceTypes,
      ToolChoiceFunction,
      ToolChoiceMCP,
      ToolChoiceCustom,
      SpecificApplyPatchParam,
      SpecificFunctionShellParam
    ], { mode: "oneOf" }).annotate({
      "description":
        "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"
    }),
    "prompt": Schema.optionalKey(Prompt),
    "truncation": Schema.optionalKey(Schema.Union([
      Schema.Literals(["auto", "disabled"]).annotate({
        "description":
          "The truncation strategy to use for the model response.\n- `auto`: If the input to this Response exceeds\n  the model's context window size, the model will truncate the\n  response to fit the context window by dropping items from the beginning of the conversation.\n- `disabled` (default): If the input size will exceed the context window\n  size for a model, the request will fail with a 400 error.\n"
      }),
      Schema.Null
    ])),
    "id": Schema.String.annotate({ "description": "Unique identifier for this Response.\n" }),
    "object": Schema.Literal("response").annotate({
      "description": "The object type of this resource - always set to `response`.\n"
    }),
    "status": Schema.optionalKey(
      Schema.Literals(["completed", "failed", "in_progress", "cancelled", "queued", "incomplete"]).annotate({
        "description":
          "The status of the response generation. One of `completed`, `failed`,\n`in_progress`, `cancelled`, `queued`, or `incomplete`.\n"
      })
    ),
    "created_at": Schema.Number.annotate({
      "description": "Unix timestamp (in seconds) of when this Response was created.\n"
    }).check(Schema.isFinite()),
    "completed_at": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "Unix timestamp (in seconds) of when this Response was completed.\nOnly present when the status is `completed`.\n"
        }).check(Schema.isFinite()),
        Schema.Null
      ])
    ),
    "error": ResponseError,
    "incomplete_details": Schema.Union([
      Schema.Struct({
        "reason": Schema.optionalKey(
          Schema.Literals(["max_output_tokens", "content_filter"]).annotate({
            "description": "The reason why the response is incomplete."
          })
        )
      }).annotate({ "description": "Details about why the response is incomplete.\n" }),
      Schema.Null
    ]),
    "output": Schema.Array(OutputItem).annotate({
      "description":
        "An array of content items generated by the model.\n\n- The length and order of items in the `output` array is dependent\n  on the model's response.\n- Rather than accessing the first item in the `output` array and\n  assuming it's an `assistant` message with the content generated by\n  the model, you might consider using the `output_text` property where\n  supported in SDKs.\n"
    }),
    "instructions": Schema.Union([
      Schema.Union([
        Schema.String.annotate({
          "description": "A text input to the model, equivalent to a text input with the\n`developer` role.\n"
        }),
        Schema.Array(InputItem).annotate({
          "title": "Input item list",
          "description": "A list of one or many input items to the model, containing\ndifferent content types.\n"
        })
      ], { mode: "oneOf" }).annotate({
        "description":
          "A system (or developer) message inserted into the model's context.\n\nWhen using along with `previous_response_id`, the instructions from a previous\nresponse will not be carried over to the next response. This makes it simple\nto swap out system (or developer) messages in new responses.\n"
      }),
      Schema.Null
    ]),
    "output_text": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description":
            "SDK-only convenience property that contains the aggregated text output\nfrom all `output_text` items in the `output` array, if any are present.\nSupported in the Python and JavaScript SDKs.\n"
        }),
        Schema.Null
      ])
    ),
    "usage": Schema.optionalKey(Schema.Union([ResponseUsage, Schema.Null])),
    "parallel_tool_calls": Schema.Boolean.annotate({
      "description": "Whether to allow the model to run tool calls in parallel.\n"
    }),
    "conversation": Schema.optionalKey(Schema.Union([Conversation_2, Schema.Null]))
  }).annotate({ "title": "The response object", "description": "The response that failed.\n" })
}).annotate({ "description": "An event that is emitted when a response fails.\n" })
export type ResponseInProgressEvent = {
  readonly "type": "response.in_progress"
  readonly "response": {
    readonly "metadata": {} | null
    readonly "top_logprobs"?: number | null
    readonly "temperature": number | null
    readonly "top_p": number | null
    readonly "user"?: string | null
    readonly "safety_identifier"?: string | null
    readonly "prompt_cache_key"?: string | null
    readonly "service_tier"?: ServiceTier
    readonly "prompt_cache_retention"?: "in-memory" | "24h" | null
    readonly "previous_response_id"?: string | null
    readonly "model":
      | ModelIdsShared
      | "o1-pro"
      | "o1-pro-2025-03-19"
      | "o3-pro"
      | "o3-pro-2025-06-10"
      | "o3-deep-research"
      | "o3-deep-research-2025-06-26"
      | "o4-mini-deep-research"
      | "o4-mini-deep-research-2025-06-26"
      | "computer-use-preview"
      | "computer-use-preview-2025-03-11"
      | "gpt-5-codex"
      | "gpt-5-pro"
      | "gpt-5-pro-2025-10-06"
      | "gpt-5.1-codex-max"
    readonly "reasoning"?: Reasoning | null
    readonly "background"?: boolean | null
    readonly "max_output_tokens"?: number | null
    readonly "max_tool_calls"?: number | null
    readonly "text"?: ResponseTextParam
    readonly "tools": ReadonlyArray<Tool>
    readonly "tool_choice":
      | ToolChoiceOptions
      | ToolChoiceAllowed
      | ToolChoiceTypes
      | ToolChoiceFunction
      | ToolChoiceMCP
      | ToolChoiceCustom
      | SpecificApplyPatchParam
      | SpecificFunctionShellParam
    readonly "prompt"?: Prompt
    readonly "truncation"?: "auto" | "disabled" | null
    readonly "id": string
    readonly "object": "response"
    readonly "status"?: "completed" | "failed" | "in_progress" | "cancelled" | "queued" | "incomplete"
    readonly "created_at": number
    readonly "completed_at"?: number | null
    readonly "error": ResponseError
    readonly "incomplete_details": { readonly "reason"?: "max_output_tokens" | "content_filter" } | null
    readonly "output": ReadonlyArray<OutputItem>
    readonly "instructions": string | ReadonlyArray<InputItem> | null
    readonly "output_text"?: string | null
    readonly "usage"?: ResponseUsage | null
    readonly "parallel_tool_calls": boolean
    readonly "conversation"?: Conversation_2 | null
  }
  readonly "sequence_number": number
}
export const ResponseInProgressEvent = Schema.Struct({
  "type": Schema.Literal("response.in_progress").annotate({
    "description": "The type of the event. Always `response.in_progress`.\n"
  }),
  "response": Schema.Struct({
    "metadata": Schema.Union([
      Schema.Struct({}).annotate({
        "description":
          "Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard.\n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n"
      }),
      Schema.Null
    ]),
    "top_logprobs": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"
        }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(20)),
        Schema.Null
      ])
    ),
    "temperature": Schema.Union([
      Schema.Number.annotate({
        "description":
          "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(2)),
      Schema.Null
    ]),
    "top_p": Schema.Union([
      Schema.Number.annotate({
        "description":
          "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1)),
      Schema.Null
    ]),
    "user": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "This field is being replaced by `safety_identifier` and `prompt_cache_key`. Use `prompt_cache_key` instead to maintain caching optimizations.\nA stable identifier for your end-users.\nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
      })
    ),
    "safety_identifier": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies.\nThe IDs should be a string that uniquely identifies each user, with a maximum length of 64 characters. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
      })
    ),
    "prompt_cache_key": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the `user` field. [Learn more](/docs/guides/prompt-caching).\n"
      })
    ),
    "service_tier": Schema.optionalKey(ServiceTier),
    "prompt_cache_retention": Schema.optionalKey(
      Schema.Union([
        Schema.Literals(["in-memory", "24h"]).annotate({
          "description":
            "The retention policy for the prompt cache. Set to `24h` to enable extended prompt caching, which keeps cached prefixes active for longer, up to a maximum of 24 hours. [Learn more](/docs/guides/prompt-caching#prompt-cache-retention).\n"
        }),
        Schema.Null
      ])
    ),
    "previous_response_id": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description":
            "The unique ID of the previous response to the model. Use this to\ncreate multi-turn conversations. Learn more about\n[conversation state](/docs/guides/conversation-state). Cannot be used in conjunction with `conversation`.\n"
        }),
        Schema.Null
      ])
    ),
    "model": Schema.Union([
      ModelIdsShared,
      Schema.Literals([
        "o1-pro",
        "o1-pro-2025-03-19",
        "o3-pro",
        "o3-pro-2025-06-10",
        "o3-deep-research",
        "o3-deep-research-2025-06-26",
        "o4-mini-deep-research",
        "o4-mini-deep-research-2025-06-26",
        "computer-use-preview",
        "computer-use-preview-2025-03-11",
        "gpt-5-codex",
        "gpt-5-pro",
        "gpt-5-pro-2025-10-06",
        "gpt-5.1-codex-max"
      ]).annotate({ "title": "ResponsesOnlyModel" })
    ]).annotate({
      "description":
        "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](/docs/models)\nto browse and compare available models.\n"
    }),
    "reasoning": Schema.optionalKey(Schema.Union([Reasoning, Schema.Null])),
    "background": Schema.optionalKey(
      Schema.Union([
        Schema.Boolean.annotate({
          "description":
            "Whether to run the model response in the background.\n[Learn more](/docs/guides/background).\n"
        }),
        Schema.Null
      ])
    ),
    "max_output_tokens": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](/docs/guides/reasoning).\n"
        }).check(Schema.isInt()),
        Schema.Null
      ])
    ),
    "max_tool_calls": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "The maximum number of total calls to built-in tools that can be processed in a response. This maximum number applies across all built-in tool calls, not per individual tool. Any further attempts to call a tool by the model will be ignored.\n"
        }).check(Schema.isInt()),
        Schema.Null
      ])
    ),
    "text": Schema.optionalKey(ResponseTextParam),
    "tools": Schema.Array(Tool).annotate({
      "description":
        "An array of tools the model may call while generating a response. You\ncan specify which tool to use by setting the `tool_choice` parameter.\n\nWe support the following categories of tools:\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](/docs/guides/tools-web-search)\n  or [file search](/docs/guides/tools-file-search). Learn more about\n  [built-in tools](/docs/guides/tools).\n- **MCP Tools**: Integrations with third-party systems via custom MCP servers\n  or predefined connectors such as Google Drive and SharePoint. Learn more about\n  [MCP Tools](/docs/guides/tools-connectors-mcp).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code with strongly typed arguments\n  and outputs. Learn more about\n  [function calling](/docs/guides/function-calling). You can also use\n  custom tools to call your own code.\n"
    }),
    "tool_choice": Schema.Union([
      ToolChoiceOptions,
      ToolChoiceAllowed,
      ToolChoiceTypes,
      ToolChoiceFunction,
      ToolChoiceMCP,
      ToolChoiceCustom,
      SpecificApplyPatchParam,
      SpecificFunctionShellParam
    ], { mode: "oneOf" }).annotate({
      "description":
        "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"
    }),
    "prompt": Schema.optionalKey(Prompt),
    "truncation": Schema.optionalKey(Schema.Union([
      Schema.Literals(["auto", "disabled"]).annotate({
        "description":
          "The truncation strategy to use for the model response.\n- `auto`: If the input to this Response exceeds\n  the model's context window size, the model will truncate the\n  response to fit the context window by dropping items from the beginning of the conversation.\n- `disabled` (default): If the input size will exceed the context window\n  size for a model, the request will fail with a 400 error.\n"
      }),
      Schema.Null
    ])),
    "id": Schema.String.annotate({ "description": "Unique identifier for this Response.\n" }),
    "object": Schema.Literal("response").annotate({
      "description": "The object type of this resource - always set to `response`.\n"
    }),
    "status": Schema.optionalKey(
      Schema.Literals(["completed", "failed", "in_progress", "cancelled", "queued", "incomplete"]).annotate({
        "description":
          "The status of the response generation. One of `completed`, `failed`,\n`in_progress`, `cancelled`, `queued`, or `incomplete`.\n"
      })
    ),
    "created_at": Schema.Number.annotate({
      "description": "Unix timestamp (in seconds) of when this Response was created.\n"
    }).check(Schema.isFinite()),
    "completed_at": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "Unix timestamp (in seconds) of when this Response was completed.\nOnly present when the status is `completed`.\n"
        }).check(Schema.isFinite()),
        Schema.Null
      ])
    ),
    "error": ResponseError,
    "incomplete_details": Schema.Union([
      Schema.Struct({
        "reason": Schema.optionalKey(
          Schema.Literals(["max_output_tokens", "content_filter"]).annotate({
            "description": "The reason why the response is incomplete."
          })
        )
      }).annotate({ "description": "Details about why the response is incomplete.\n" }),
      Schema.Null
    ]),
    "output": Schema.Array(OutputItem).annotate({
      "description":
        "An array of content items generated by the model.\n\n- The length and order of items in the `output` array is dependent\n  on the model's response.\n- Rather than accessing the first item in the `output` array and\n  assuming it's an `assistant` message with the content generated by\n  the model, you might consider using the `output_text` property where\n  supported in SDKs.\n"
    }),
    "instructions": Schema.Union([
      Schema.Union([
        Schema.String.annotate({
          "description": "A text input to the model, equivalent to a text input with the\n`developer` role.\n"
        }),
        Schema.Array(InputItem).annotate({
          "title": "Input item list",
          "description": "A list of one or many input items to the model, containing\ndifferent content types.\n"
        })
      ], { mode: "oneOf" }).annotate({
        "description":
          "A system (or developer) message inserted into the model's context.\n\nWhen using along with `previous_response_id`, the instructions from a previous\nresponse will not be carried over to the next response. This makes it simple\nto swap out system (or developer) messages in new responses.\n"
      }),
      Schema.Null
    ]),
    "output_text": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description":
            "SDK-only convenience property that contains the aggregated text output\nfrom all `output_text` items in the `output` array, if any are present.\nSupported in the Python and JavaScript SDKs.\n"
        }),
        Schema.Null
      ])
    ),
    "usage": Schema.optionalKey(Schema.Union([ResponseUsage, Schema.Null])),
    "parallel_tool_calls": Schema.Boolean.annotate({
      "description": "Whether to allow the model to run tool calls in parallel.\n"
    }),
    "conversation": Schema.optionalKey(Schema.Union([Conversation_2, Schema.Null]))
  }).annotate({ "title": "The response object", "description": "The response that is in progress.\n" }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  )
}).annotate({ "description": "Emitted when the response is in progress." })
export type ResponseIncompleteEvent = {
  readonly "type": "response.incomplete"
  readonly "response": {
    readonly "metadata": {} | null
    readonly "top_logprobs"?: number | null
    readonly "temperature": number | null
    readonly "top_p": number | null
    readonly "user"?: string | null
    readonly "safety_identifier"?: string | null
    readonly "prompt_cache_key"?: string | null
    readonly "service_tier"?: ServiceTier
    readonly "prompt_cache_retention"?: "in-memory" | "24h" | null
    readonly "previous_response_id"?: string | null
    readonly "model":
      | ModelIdsShared
      | "o1-pro"
      | "o1-pro-2025-03-19"
      | "o3-pro"
      | "o3-pro-2025-06-10"
      | "o3-deep-research"
      | "o3-deep-research-2025-06-26"
      | "o4-mini-deep-research"
      | "o4-mini-deep-research-2025-06-26"
      | "computer-use-preview"
      | "computer-use-preview-2025-03-11"
      | "gpt-5-codex"
      | "gpt-5-pro"
      | "gpt-5-pro-2025-10-06"
      | "gpt-5.1-codex-max"
    readonly "reasoning"?: Reasoning | null
    readonly "background"?: boolean | null
    readonly "max_output_tokens"?: number | null
    readonly "max_tool_calls"?: number | null
    readonly "text"?: ResponseTextParam
    readonly "tools": ReadonlyArray<Tool>
    readonly "tool_choice":
      | ToolChoiceOptions
      | ToolChoiceAllowed
      | ToolChoiceTypes
      | ToolChoiceFunction
      | ToolChoiceMCP
      | ToolChoiceCustom
      | SpecificApplyPatchParam
      | SpecificFunctionShellParam
    readonly "prompt"?: Prompt
    readonly "truncation"?: "auto" | "disabled" | null
    readonly "id": string
    readonly "object": "response"
    readonly "status"?: "completed" | "failed" | "in_progress" | "cancelled" | "queued" | "incomplete"
    readonly "created_at": number
    readonly "completed_at"?: number | null
    readonly "error": ResponseError
    readonly "incomplete_details": { readonly "reason"?: "max_output_tokens" | "content_filter" } | null
    readonly "output": ReadonlyArray<OutputItem>
    readonly "instructions": string | ReadonlyArray<InputItem> | null
    readonly "output_text"?: string | null
    readonly "usage"?: ResponseUsage | null
    readonly "parallel_tool_calls": boolean
    readonly "conversation"?: Conversation_2 | null
  }
  readonly "sequence_number": number
}
export const ResponseIncompleteEvent = Schema.Struct({
  "type": Schema.Literal("response.incomplete").annotate({
    "description": "The type of the event. Always `response.incomplete`.\n"
  }),
  "response": Schema.Struct({
    "metadata": Schema.Union([
      Schema.Struct({}).annotate({
        "description":
          "Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard.\n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n"
      }),
      Schema.Null
    ]),
    "top_logprobs": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"
        }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(20)),
        Schema.Null
      ])
    ),
    "temperature": Schema.Union([
      Schema.Number.annotate({
        "description":
          "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(2)),
      Schema.Null
    ]),
    "top_p": Schema.Union([
      Schema.Number.annotate({
        "description":
          "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1)),
      Schema.Null
    ]),
    "user": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "This field is being replaced by `safety_identifier` and `prompt_cache_key`. Use `prompt_cache_key` instead to maintain caching optimizations.\nA stable identifier for your end-users.\nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
      })
    ),
    "safety_identifier": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies.\nThe IDs should be a string that uniquely identifies each user, with a maximum length of 64 characters. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
      })
    ),
    "prompt_cache_key": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the `user` field. [Learn more](/docs/guides/prompt-caching).\n"
      })
    ),
    "service_tier": Schema.optionalKey(ServiceTier),
    "prompt_cache_retention": Schema.optionalKey(
      Schema.Union([
        Schema.Literals(["in-memory", "24h"]).annotate({
          "description":
            "The retention policy for the prompt cache. Set to `24h` to enable extended prompt caching, which keeps cached prefixes active for longer, up to a maximum of 24 hours. [Learn more](/docs/guides/prompt-caching#prompt-cache-retention).\n"
        }),
        Schema.Null
      ])
    ),
    "previous_response_id": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description":
            "The unique ID of the previous response to the model. Use this to\ncreate multi-turn conversations. Learn more about\n[conversation state](/docs/guides/conversation-state). Cannot be used in conjunction with `conversation`.\n"
        }),
        Schema.Null
      ])
    ),
    "model": Schema.Union([
      ModelIdsShared,
      Schema.Literals([
        "o1-pro",
        "o1-pro-2025-03-19",
        "o3-pro",
        "o3-pro-2025-06-10",
        "o3-deep-research",
        "o3-deep-research-2025-06-26",
        "o4-mini-deep-research",
        "o4-mini-deep-research-2025-06-26",
        "computer-use-preview",
        "computer-use-preview-2025-03-11",
        "gpt-5-codex",
        "gpt-5-pro",
        "gpt-5-pro-2025-10-06",
        "gpt-5.1-codex-max"
      ]).annotate({ "title": "ResponsesOnlyModel" })
    ]).annotate({
      "description":
        "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](/docs/models)\nto browse and compare available models.\n"
    }),
    "reasoning": Schema.optionalKey(Schema.Union([Reasoning, Schema.Null])),
    "background": Schema.optionalKey(
      Schema.Union([
        Schema.Boolean.annotate({
          "description":
            "Whether to run the model response in the background.\n[Learn more](/docs/guides/background).\n"
        }),
        Schema.Null
      ])
    ),
    "max_output_tokens": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](/docs/guides/reasoning).\n"
        }).check(Schema.isInt()),
        Schema.Null
      ])
    ),
    "max_tool_calls": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "The maximum number of total calls to built-in tools that can be processed in a response. This maximum number applies across all built-in tool calls, not per individual tool. Any further attempts to call a tool by the model will be ignored.\n"
        }).check(Schema.isInt()),
        Schema.Null
      ])
    ),
    "text": Schema.optionalKey(ResponseTextParam),
    "tools": Schema.Array(Tool).annotate({
      "description":
        "An array of tools the model may call while generating a response. You\ncan specify which tool to use by setting the `tool_choice` parameter.\n\nWe support the following categories of tools:\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](/docs/guides/tools-web-search)\n  or [file search](/docs/guides/tools-file-search). Learn more about\n  [built-in tools](/docs/guides/tools).\n- **MCP Tools**: Integrations with third-party systems via custom MCP servers\n  or predefined connectors such as Google Drive and SharePoint. Learn more about\n  [MCP Tools](/docs/guides/tools-connectors-mcp).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code with strongly typed arguments\n  and outputs. Learn more about\n  [function calling](/docs/guides/function-calling). You can also use\n  custom tools to call your own code.\n"
    }),
    "tool_choice": Schema.Union([
      ToolChoiceOptions,
      ToolChoiceAllowed,
      ToolChoiceTypes,
      ToolChoiceFunction,
      ToolChoiceMCP,
      ToolChoiceCustom,
      SpecificApplyPatchParam,
      SpecificFunctionShellParam
    ], { mode: "oneOf" }).annotate({
      "description":
        "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"
    }),
    "prompt": Schema.optionalKey(Prompt),
    "truncation": Schema.optionalKey(Schema.Union([
      Schema.Literals(["auto", "disabled"]).annotate({
        "description":
          "The truncation strategy to use for the model response.\n- `auto`: If the input to this Response exceeds\n  the model's context window size, the model will truncate the\n  response to fit the context window by dropping items from the beginning of the conversation.\n- `disabled` (default): If the input size will exceed the context window\n  size for a model, the request will fail with a 400 error.\n"
      }),
      Schema.Null
    ])),
    "id": Schema.String.annotate({ "description": "Unique identifier for this Response.\n" }),
    "object": Schema.Literal("response").annotate({
      "description": "The object type of this resource - always set to `response`.\n"
    }),
    "status": Schema.optionalKey(
      Schema.Literals(["completed", "failed", "in_progress", "cancelled", "queued", "incomplete"]).annotate({
        "description":
          "The status of the response generation. One of `completed`, `failed`,\n`in_progress`, `cancelled`, `queued`, or `incomplete`.\n"
      })
    ),
    "created_at": Schema.Number.annotate({
      "description": "Unix timestamp (in seconds) of when this Response was created.\n"
    }).check(Schema.isFinite()),
    "completed_at": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "Unix timestamp (in seconds) of when this Response was completed.\nOnly present when the status is `completed`.\n"
        }).check(Schema.isFinite()),
        Schema.Null
      ])
    ),
    "error": ResponseError,
    "incomplete_details": Schema.Union([
      Schema.Struct({
        "reason": Schema.optionalKey(
          Schema.Literals(["max_output_tokens", "content_filter"]).annotate({
            "description": "The reason why the response is incomplete."
          })
        )
      }).annotate({ "description": "Details about why the response is incomplete.\n" }),
      Schema.Null
    ]),
    "output": Schema.Array(OutputItem).annotate({
      "description":
        "An array of content items generated by the model.\n\n- The length and order of items in the `output` array is dependent\n  on the model's response.\n- Rather than accessing the first item in the `output` array and\n  assuming it's an `assistant` message with the content generated by\n  the model, you might consider using the `output_text` property where\n  supported in SDKs.\n"
    }),
    "instructions": Schema.Union([
      Schema.Union([
        Schema.String.annotate({
          "description": "A text input to the model, equivalent to a text input with the\n`developer` role.\n"
        }),
        Schema.Array(InputItem).annotate({
          "title": "Input item list",
          "description": "A list of one or many input items to the model, containing\ndifferent content types.\n"
        })
      ], { mode: "oneOf" }).annotate({
        "description":
          "A system (or developer) message inserted into the model's context.\n\nWhen using along with `previous_response_id`, the instructions from a previous\nresponse will not be carried over to the next response. This makes it simple\nto swap out system (or developer) messages in new responses.\n"
      }),
      Schema.Null
    ]),
    "output_text": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description":
            "SDK-only convenience property that contains the aggregated text output\nfrom all `output_text` items in the `output` array, if any are present.\nSupported in the Python and JavaScript SDKs.\n"
        }),
        Schema.Null
      ])
    ),
    "usage": Schema.optionalKey(Schema.Union([ResponseUsage, Schema.Null])),
    "parallel_tool_calls": Schema.Boolean.annotate({
      "description": "Whether to allow the model to run tool calls in parallel.\n"
    }),
    "conversation": Schema.optionalKey(Schema.Union([Conversation_2, Schema.Null]))
  }).annotate({ "title": "The response object", "description": "The response that was incomplete.\n" }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(
    Schema.isInt()
  )
}).annotate({ "description": "An event that is emitted when a response finishes as incomplete.\n" })
export type ResponseQueuedEvent = {
  readonly "type": "response.queued"
  readonly "response": {
    readonly "metadata": {} | null
    readonly "top_logprobs"?: number | null
    readonly "temperature": number | null
    readonly "top_p": number | null
    readonly "user"?: string | null
    readonly "safety_identifier"?: string | null
    readonly "prompt_cache_key"?: string | null
    readonly "service_tier"?: ServiceTier
    readonly "prompt_cache_retention"?: "in-memory" | "24h" | null
    readonly "previous_response_id"?: string | null
    readonly "model":
      | ModelIdsShared
      | "o1-pro"
      | "o1-pro-2025-03-19"
      | "o3-pro"
      | "o3-pro-2025-06-10"
      | "o3-deep-research"
      | "o3-deep-research-2025-06-26"
      | "o4-mini-deep-research"
      | "o4-mini-deep-research-2025-06-26"
      | "computer-use-preview"
      | "computer-use-preview-2025-03-11"
      | "gpt-5-codex"
      | "gpt-5-pro"
      | "gpt-5-pro-2025-10-06"
      | "gpt-5.1-codex-max"
    readonly "reasoning"?: Reasoning | null
    readonly "background"?: boolean | null
    readonly "max_output_tokens"?: number | null
    readonly "max_tool_calls"?: number | null
    readonly "text"?: ResponseTextParam
    readonly "tools": ReadonlyArray<Tool>
    readonly "tool_choice":
      | ToolChoiceOptions
      | ToolChoiceAllowed
      | ToolChoiceTypes
      | ToolChoiceFunction
      | ToolChoiceMCP
      | ToolChoiceCustom
      | SpecificApplyPatchParam
      | SpecificFunctionShellParam
    readonly "prompt"?: Prompt
    readonly "truncation"?: "auto" | "disabled" | null
    readonly "id": string
    readonly "object": "response"
    readonly "status"?: "completed" | "failed" | "in_progress" | "cancelled" | "queued" | "incomplete"
    readonly "created_at": number
    readonly "completed_at"?: number | null
    readonly "error": ResponseError
    readonly "incomplete_details": { readonly "reason"?: "max_output_tokens" | "content_filter" } | null
    readonly "output": ReadonlyArray<OutputItem>
    readonly "instructions": string | ReadonlyArray<InputItem> | null
    readonly "output_text"?: string | null
    readonly "usage"?: ResponseUsage | null
    readonly "parallel_tool_calls": boolean
    readonly "conversation"?: Conversation_2 | null
  }
  readonly "sequence_number": number
}
export const ResponseQueuedEvent = Schema.Struct({
  "type": Schema.Literal("response.queued").annotate({
    "description": "The type of the event. Always 'response.queued'."
  }),
  "response": Schema.Struct({
    "metadata": Schema.Union([
      Schema.Struct({}).annotate({
        "description":
          "Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard.\n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n"
      }),
      Schema.Null
    ]),
    "top_logprobs": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"
        }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(20)),
        Schema.Null
      ])
    ),
    "temperature": Schema.Union([
      Schema.Number.annotate({
        "description":
          "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(2)),
      Schema.Null
    ]),
    "top_p": Schema.Union([
      Schema.Number.annotate({
        "description":
          "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1)),
      Schema.Null
    ]),
    "user": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "This field is being replaced by `safety_identifier` and `prompt_cache_key`. Use `prompt_cache_key` instead to maintain caching optimizations.\nA stable identifier for your end-users.\nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
      })
    ),
    "safety_identifier": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies.\nThe IDs should be a string that uniquely identifies each user, with a maximum length of 64 characters. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
      })
    ),
    "prompt_cache_key": Schema.optionalKey(
      Schema.Union([Schema.String, Schema.Null]).annotate({
        "description":
          "Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the `user` field. [Learn more](/docs/guides/prompt-caching).\n"
      })
    ),
    "service_tier": Schema.optionalKey(ServiceTier),
    "prompt_cache_retention": Schema.optionalKey(
      Schema.Union([
        Schema.Literals(["in-memory", "24h"]).annotate({
          "description":
            "The retention policy for the prompt cache. Set to `24h` to enable extended prompt caching, which keeps cached prefixes active for longer, up to a maximum of 24 hours. [Learn more](/docs/guides/prompt-caching#prompt-cache-retention).\n"
        }),
        Schema.Null
      ])
    ),
    "previous_response_id": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description":
            "The unique ID of the previous response to the model. Use this to\ncreate multi-turn conversations. Learn more about\n[conversation state](/docs/guides/conversation-state). Cannot be used in conjunction with `conversation`.\n"
        }),
        Schema.Null
      ])
    ),
    "model": Schema.Union([
      ModelIdsShared,
      Schema.Literals([
        "o1-pro",
        "o1-pro-2025-03-19",
        "o3-pro",
        "o3-pro-2025-06-10",
        "o3-deep-research",
        "o3-deep-research-2025-06-26",
        "o4-mini-deep-research",
        "o4-mini-deep-research-2025-06-26",
        "computer-use-preview",
        "computer-use-preview-2025-03-11",
        "gpt-5-codex",
        "gpt-5-pro",
        "gpt-5-pro-2025-10-06",
        "gpt-5.1-codex-max"
      ]).annotate({ "title": "ResponsesOnlyModel" })
    ]).annotate({
      "description":
        "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](/docs/models)\nto browse and compare available models.\n"
    }),
    "reasoning": Schema.optionalKey(Schema.Union([Reasoning, Schema.Null])),
    "background": Schema.optionalKey(
      Schema.Union([
        Schema.Boolean.annotate({
          "description":
            "Whether to run the model response in the background.\n[Learn more](/docs/guides/background).\n"
        }),
        Schema.Null
      ])
    ),
    "max_output_tokens": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](/docs/guides/reasoning).\n"
        }).check(Schema.isInt()),
        Schema.Null
      ])
    ),
    "max_tool_calls": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "The maximum number of total calls to built-in tools that can be processed in a response. This maximum number applies across all built-in tool calls, not per individual tool. Any further attempts to call a tool by the model will be ignored.\n"
        }).check(Schema.isInt()),
        Schema.Null
      ])
    ),
    "text": Schema.optionalKey(ResponseTextParam),
    "tools": Schema.Array(Tool).annotate({
      "description":
        "An array of tools the model may call while generating a response. You\ncan specify which tool to use by setting the `tool_choice` parameter.\n\nWe support the following categories of tools:\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](/docs/guides/tools-web-search)\n  or [file search](/docs/guides/tools-file-search). Learn more about\n  [built-in tools](/docs/guides/tools).\n- **MCP Tools**: Integrations with third-party systems via custom MCP servers\n  or predefined connectors such as Google Drive and SharePoint. Learn more about\n  [MCP Tools](/docs/guides/tools-connectors-mcp).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code with strongly typed arguments\n  and outputs. Learn more about\n  [function calling](/docs/guides/function-calling). You can also use\n  custom tools to call your own code.\n"
    }),
    "tool_choice": Schema.Union([
      ToolChoiceOptions,
      ToolChoiceAllowed,
      ToolChoiceTypes,
      ToolChoiceFunction,
      ToolChoiceMCP,
      ToolChoiceCustom,
      SpecificApplyPatchParam,
      SpecificFunctionShellParam
    ], { mode: "oneOf" }).annotate({
      "description":
        "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"
    }),
    "prompt": Schema.optionalKey(Prompt),
    "truncation": Schema.optionalKey(Schema.Union([
      Schema.Literals(["auto", "disabled"]).annotate({
        "description":
          "The truncation strategy to use for the model response.\n- `auto`: If the input to this Response exceeds\n  the model's context window size, the model will truncate the\n  response to fit the context window by dropping items from the beginning of the conversation.\n- `disabled` (default): If the input size will exceed the context window\n  size for a model, the request will fail with a 400 error.\n"
      }),
      Schema.Null
    ])),
    "id": Schema.String.annotate({ "description": "Unique identifier for this Response.\n" }),
    "object": Schema.Literal("response").annotate({
      "description": "The object type of this resource - always set to `response`.\n"
    }),
    "status": Schema.optionalKey(
      Schema.Literals(["completed", "failed", "in_progress", "cancelled", "queued", "incomplete"]).annotate({
        "description":
          "The status of the response generation. One of `completed`, `failed`,\n`in_progress`, `cancelled`, `queued`, or `incomplete`.\n"
      })
    ),
    "created_at": Schema.Number.annotate({
      "description": "Unix timestamp (in seconds) of when this Response was created.\n"
    }).check(Schema.isFinite()),
    "completed_at": Schema.optionalKey(
      Schema.Union([
        Schema.Number.annotate({
          "description":
            "Unix timestamp (in seconds) of when this Response was completed.\nOnly present when the status is `completed`.\n"
        }).check(Schema.isFinite()),
        Schema.Null
      ])
    ),
    "error": ResponseError,
    "incomplete_details": Schema.Union([
      Schema.Struct({
        "reason": Schema.optionalKey(
          Schema.Literals(["max_output_tokens", "content_filter"]).annotate({
            "description": "The reason why the response is incomplete."
          })
        )
      }).annotate({ "description": "Details about why the response is incomplete.\n" }),
      Schema.Null
    ]),
    "output": Schema.Array(OutputItem).annotate({
      "description":
        "An array of content items generated by the model.\n\n- The length and order of items in the `output` array is dependent\n  on the model's response.\n- Rather than accessing the first item in the `output` array and\n  assuming it's an `assistant` message with the content generated by\n  the model, you might consider using the `output_text` property where\n  supported in SDKs.\n"
    }),
    "instructions": Schema.Union([
      Schema.Union([
        Schema.String.annotate({
          "description": "A text input to the model, equivalent to a text input with the\n`developer` role.\n"
        }),
        Schema.Array(InputItem).annotate({
          "title": "Input item list",
          "description": "A list of one or many input items to the model, containing\ndifferent content types.\n"
        })
      ], { mode: "oneOf" }).annotate({
        "description":
          "A system (or developer) message inserted into the model's context.\n\nWhen using along with `previous_response_id`, the instructions from a previous\nresponse will not be carried over to the next response. This makes it simple\nto swap out system (or developer) messages in new responses.\n"
      }),
      Schema.Null
    ]),
    "output_text": Schema.optionalKey(
      Schema.Union([
        Schema.String.annotate({
          "description":
            "SDK-only convenience property that contains the aggregated text output\nfrom all `output_text` items in the `output` array, if any are present.\nSupported in the Python and JavaScript SDKs.\n"
        }),
        Schema.Null
      ])
    ),
    "usage": Schema.optionalKey(Schema.Union([ResponseUsage, Schema.Null])),
    "parallel_tool_calls": Schema.Boolean.annotate({
      "description": "Whether to allow the model to run tool calls in parallel.\n"
    }),
    "conversation": Schema.optionalKey(Schema.Union([Conversation_2, Schema.Null]))
  }).annotate({ "title": "The response object", "description": "The full response object that is queued." }),
  "sequence_number": Schema.Number.annotate({ "description": "The sequence number for this event." }).check(
    Schema.isInt()
  )
}).annotate({
  "title": "ResponseQueuedEvent",
  "description": "Emitted when a response is queued and waiting to be processed.\n"
})
export type CreateEvalRequest = {
  readonly "name"?: string
  readonly "metadata"?: Metadata
  readonly "data_source_config":
    | CreateEvalCustomDataSourceConfig
    | CreateEvalLogsDataSourceConfig
    | CreateEvalStoredCompletionsDataSourceConfig
  readonly "testing_criteria": ReadonlyArray<
    | CreateEvalLabelModelGrader
    | EvalGraderStringCheck
    | EvalGraderTextSimilarity
    | EvalGraderPython
    | EvalGraderScoreModel
  >
}
export const CreateEvalRequest = Schema.Struct({
  "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the evaluation." })),
  "metadata": Schema.optionalKey(Metadata),
  "data_source_config": Schema.Union([
    CreateEvalCustomDataSourceConfig,
    CreateEvalLogsDataSourceConfig,
    CreateEvalStoredCompletionsDataSourceConfig
  ], { mode: "oneOf" }).annotate({
    "description":
      "The configuration for the data source used for the evaluation runs. Dictates the schema of the data used in the evaluation."
  }),
  "testing_criteria": Schema.Array(
    Schema.Union([
      CreateEvalLabelModelGrader,
      EvalGraderStringCheck,
      EvalGraderTextSimilarity,
      EvalGraderPython,
      EvalGraderScoreModel
    ], { mode: "oneOf" })
  ).annotate({
    "description":
      "A list of graders for all eval runs in this group. Graders can reference variables in the data source using double curly braces notation, like `{{item.variable_name}}`. To reference the model's output, use the `sample` namespace (ie, `{{sample.output_text}}`)."
  })
}).annotate({ "title": "CreateEvalRequest" })
export type EvalRunList = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<EvalRun>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const EvalRunList = Schema.Struct({
  "object": Schema.Literal("list").annotate({
    "description": "The type of this object. It is always set to \"list\".\n"
  }),
  "data": Schema.Array(EvalRun).annotate({ "description": "An array of eval run objects.\n" }),
  "first_id": Schema.String.annotate({ "description": "The identifier of the first eval run in the data array." }),
  "last_id": Schema.String.annotate({ "description": "The identifier of the last eval run in the data array." }),
  "has_more": Schema.Boolean.annotate({ "description": "Indicates whether there are more evals available." })
}).annotate({ "title": "EvalRunList", "description": "An object representing a list of runs for an evaluation.\n" })
export type EvalList = {
  readonly "object": "list"
  readonly "data": ReadonlyArray<Eval>
  readonly "first_id": string
  readonly "last_id": string
  readonly "has_more": boolean
}
export const EvalList = Schema.Struct({
  "object": Schema.Literal("list").annotate({
    "description": "The type of this object. It is always set to \"list\".\n"
  }),
  "data": Schema.Array(Eval).annotate({ "description": "An array of eval objects.\n" }),
  "first_id": Schema.String.annotate({ "description": "The identifier of the first eval in the data array." }),
  "last_id": Schema.String.annotate({ "description": "The identifier of the last eval in the data array." }),
  "has_more": Schema.Boolean.annotate({ "description": "Indicates whether there are more evals available." })
}).annotate({ "title": "EvalList", "description": "An object representing a list of evals.\n" })
export type FineTuneReinforcementMethod = {
  readonly "grader": GraderStringCheck | GraderTextSimilarity | GraderPython | GraderScoreModel | GraderMulti
  readonly "hyperparameters"?: FineTuneReinforcementHyperparameters
}
export const FineTuneReinforcementMethod = Schema.Struct({
  "grader": Schema.Union([GraderStringCheck, GraderTextSimilarity, GraderPython, GraderScoreModel, GraderMulti], {
    mode: "oneOf"
  }).annotate({ "description": "The grader used for the fine-tuning job." }),
  "hyperparameters": Schema.optionalKey(FineTuneReinforcementHyperparameters)
}).annotate({ "description": "Configuration for the reinforcement fine-tuning method." })
export type RunGraderRequest = {
  readonly "grader": GraderStringCheck | GraderTextSimilarity | GraderPython | GraderScoreModel | GraderMulti
  readonly "item"?: {}
  readonly "model_sample": string
}
export const RunGraderRequest = Schema.Struct({
  "grader": Schema.Union([GraderStringCheck, GraderTextSimilarity, GraderPython, GraderScoreModel, GraderMulti], {
    mode: "oneOf"
  }).annotate({ "description": "The grader used for the fine-tuning job." }),
  "item": Schema.optionalKey(
    Schema.Struct({}).annotate({
      "description":
        "The dataset item provided to the grader. This will be used to populate \nthe `item` namespace. See [the guide](/docs/guides/graders) for more details. \n"
    })
  ),
  "model_sample": Schema.String.annotate({
    "description":
      "The model sample to be evaluated. This value will be used to populate \nthe `sample` namespace. See [the guide](/docs/guides/graders) for more details.\nThe `output_json` variable will be populated if the model sample is a \nvalid JSON string.\n \n"
  })
}).annotate({ "title": "RunGraderRequest" })
export type ValidateGraderRequest = {
  readonly "grader": GraderStringCheck | GraderTextSimilarity | GraderPython | GraderScoreModel | GraderMulti
}
export const ValidateGraderRequest = Schema.Struct({
  "grader": Schema.Union([GraderStringCheck, GraderTextSimilarity, GraderPython, GraderScoreModel, GraderMulti], {
    mode: "oneOf"
  }).annotate({ "description": "The grader used for the fine-tuning job." })
}).annotate({ "title": "ValidateGraderRequest" })
export type ValidateGraderResponse = {
  readonly "grader"?: GraderStringCheck | GraderTextSimilarity | GraderPython | GraderScoreModel | GraderMulti
}
export const ValidateGraderResponse = Schema.Struct({
  "grader": Schema.optionalKey(
    Schema.Union([GraderStringCheck, GraderTextSimilarity, GraderPython, GraderScoreModel, GraderMulti], {
      mode: "oneOf"
    }).annotate({ "description": "The grader used for the fine-tuning job." })
  )
}).annotate({ "title": "ValidateGraderResponse" })
export type CreateResponse = {
  readonly "metadata"?: Metadata
  readonly "top_logprobs"?: number
  readonly "temperature"?: number | null
  readonly "top_p"?: number | null
  readonly "user"?: string | null
  readonly "safety_identifier"?: string | null
  readonly "prompt_cache_key"?: string | null
  readonly "service_tier"?: ServiceTier
  readonly "prompt_cache_retention"?: "in-memory" | "24h" | null
  readonly "previous_response_id"?: string | null
  readonly "model"?:
    | ModelIdsShared
    | "o1-pro"
    | "o1-pro-2025-03-19"
    | "o3-pro"
    | "o3-pro-2025-06-10"
    | "o3-deep-research"
    | "o3-deep-research-2025-06-26"
    | "o4-mini-deep-research"
    | "o4-mini-deep-research-2025-06-26"
    | "computer-use-preview"
    | "computer-use-preview-2025-03-11"
    | "gpt-5-codex"
    | "gpt-5-pro"
    | "gpt-5-pro-2025-10-06"
    | "gpt-5.1-codex-max"
  readonly "reasoning"?: Reasoning | null
  readonly "background"?: boolean | null
  readonly "max_output_tokens"?: number | null
  readonly "max_tool_calls"?: number | null
  readonly "text"?: ResponseTextParam
  readonly "tools"?: ToolsArray
  readonly "tool_choice"?: ToolChoiceParam
  readonly "prompt"?: Prompt
  readonly "truncation"?: "auto" | "disabled" | null
  readonly "input"?: InputParam
  readonly "include"?: ReadonlyArray<IncludeEnum> | null
  readonly "parallel_tool_calls"?: boolean | null
  readonly "store"?: boolean | null
  readonly "instructions"?: string | null
  readonly "stream"?: boolean | null
  readonly "stream_options"?: ResponseStreamOptions
  readonly "conversation"?: ConversationParam | null
  readonly "context_management"?: ReadonlyArray<ContextManagementParam> | null
}
export const CreateResponse = Schema.Struct({
  "metadata": Schema.optionalKey(Metadata),
  "top_logprobs": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"
      }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(20)).check(
        Schema.makeFilterGroup([Schema.isGreaterThanOrEqualTo(0), Schema.isLessThanOrEqualTo(20)], {
          "description":
            "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"
        })
      )
    ])
  ),
  "temperature": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(2)),
      Schema.Null
    ])
  ),
  "top_p": Schema.optionalKey(Schema.Union([
    Schema.Number.annotate({
      "description":
        "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"
    }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1)),
    Schema.Null
  ])),
  "user": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "This field is being replaced by `safety_identifier` and `prompt_cache_key`. Use `prompt_cache_key` instead to maintain caching optimizations.\nA stable identifier for your end-users.\nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
    })
  ),
  "safety_identifier": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies.\nThe IDs should be a string that uniquely identifies each user, with a maximum length of 64 characters. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
    })
  ),
  "prompt_cache_key": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the `user` field. [Learn more](/docs/guides/prompt-caching).\n"
    })
  ),
  "service_tier": Schema.optionalKey(ServiceTier),
  "prompt_cache_retention": Schema.optionalKey(
    Schema.Union([
      Schema.Literals(["in-memory", "24h"]).annotate({
        "description":
          "The retention policy for the prompt cache. Set to `24h` to enable extended prompt caching, which keeps cached prefixes active for longer, up to a maximum of 24 hours. [Learn more](/docs/guides/prompt-caching#prompt-cache-retention).\n"
      }),
      Schema.Null
    ])
  ),
  "previous_response_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "The unique ID of the previous response to the model. Use this to\ncreate multi-turn conversations. Learn more about\n[conversation state](/docs/guides/conversation-state). Cannot be used in conjunction with `conversation`.\n"
      }),
      Schema.Null
    ])
  ),
  "model": Schema.optionalKey(
    Schema.Union([
      ModelIdsShared,
      Schema.Literals([
        "o1-pro",
        "o1-pro-2025-03-19",
        "o3-pro",
        "o3-pro-2025-06-10",
        "o3-deep-research",
        "o3-deep-research-2025-06-26",
        "o4-mini-deep-research",
        "o4-mini-deep-research-2025-06-26",
        "computer-use-preview",
        "computer-use-preview-2025-03-11",
        "gpt-5-codex",
        "gpt-5-pro",
        "gpt-5-pro-2025-10-06",
        "gpt-5.1-codex-max"
      ]).annotate({ "title": "ResponsesOnlyModel" })
    ]).annotate({
      "description":
        "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](/docs/models)\nto browse and compare available models.\n"
    })
  ),
  "reasoning": Schema.optionalKey(Schema.Union([Reasoning, Schema.Null])),
  "background": Schema.optionalKey(
    Schema.Union([
      Schema.Boolean.annotate({
        "description": "Whether to run the model response in the background.\n[Learn more](/docs/guides/background).\n"
      }),
      Schema.Null
    ])
  ),
  "max_output_tokens": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](/docs/guides/reasoning).\n"
      }).check(Schema.isInt()),
      Schema.Null
    ])
  ),
  "max_tool_calls": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "The maximum number of total calls to built-in tools that can be processed in a response. This maximum number applies across all built-in tool calls, not per individual tool. Any further attempts to call a tool by the model will be ignored.\n"
      }).check(Schema.isInt()),
      Schema.Null
    ])
  ),
  "text": Schema.optionalKey(ResponseTextParam),
  "tools": Schema.optionalKey(ToolsArray),
  "tool_choice": Schema.optionalKey(ToolChoiceParam),
  "prompt": Schema.optionalKey(Prompt),
  "truncation": Schema.optionalKey(Schema.Union([
    Schema.Literals(["auto", "disabled"]).annotate({
      "description":
        "The truncation strategy to use for the model response.\n- `auto`: If the input to this Response exceeds\n  the model's context window size, the model will truncate the\n  response to fit the context window by dropping items from the beginning of the conversation.\n- `disabled` (default): If the input size will exceed the context window\n  size for a model, the request will fail with a 400 error.\n"
    }),
    Schema.Null
  ])),
  "input": Schema.optionalKey(InputParam),
  "include": Schema.optionalKey(Schema.Union([
    Schema.Array(IncludeEnum).annotate({
      "description":
        "Specify additional output data to include in the model response. Currently supported values are:\n- `web_search_call.action.sources`: Include the sources of the web search tool call.\n- `code_interpreter_call.outputs`: Includes the outputs of python code execution in code interpreter tool call items.\n- `computer_call_output.output.image_url`: Include image urls from the computer call output.\n- `file_search_call.results`: Include the search results of the file search tool call.\n- `message.input_image.image_url`: Include image urls from the input message.\n- `message.output_text.logprobs`: Include logprobs with assistant messages.\n- `reasoning.encrypted_content`: Includes an encrypted version of reasoning tokens in reasoning item outputs. This enables reasoning items to be used in multi-turn conversations when using the Responses API statelessly (like when the `store` parameter is set to `false`, or when an organization is enrolled in the zero data retention program)."
    }),
    Schema.Null
  ])),
  "parallel_tool_calls": Schema.optionalKey(
    Schema.Union([
      Schema.Boolean.annotate({ "description": "Whether to allow the model to run tool calls in parallel.\n" }),
      Schema.Null
    ])
  ),
  "store": Schema.optionalKey(
    Schema.Union([
      Schema.Boolean.annotate({
        "description": "Whether to store the generated model response for later retrieval via\nAPI.\n"
      }),
      Schema.Null
    ])
  ),
  "instructions": Schema.optionalKey(Schema.Union([
    Schema.String.annotate({
      "description":
        "A system (or developer) message inserted into the model's context.\n\nWhen using along with `previous_response_id`, the instructions from a previous\nresponse will not be carried over to the next response. This makes it simple\nto swap out system (or developer) messages in new responses.\n"
    }),
    Schema.Null
  ])),
  "stream": Schema.optionalKey(Schema.Union([
    Schema.Boolean.annotate({
      "description":
        "If set to true, the model response data will be streamed to the client\nas it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).\nSee the [Streaming section below](/docs/api-reference/responses-streaming)\nfor more information.\n"
    }),
    Schema.Null
  ])),
  "stream_options": Schema.optionalKey(ResponseStreamOptions),
  "conversation": Schema.optionalKey(Schema.Union([ConversationParam, Schema.Null])),
  "context_management": Schema.optionalKey(
    Schema.Union([
      Schema.Array(ContextManagementParam).annotate({
        "description": "Context management configuration for this request.\n"
      }).check(Schema.isMinLength(1)),
      Schema.Null
    ])
  )
})
export type ResponsesClientEventResponseCreate = {
  readonly "type": "response.create"
  readonly "metadata"?: Metadata
  readonly "top_logprobs"?: number
  readonly "temperature"?: number | null
  readonly "top_p"?: number | null
  readonly "user"?: string | null
  readonly "safety_identifier"?: string | null
  readonly "prompt_cache_key"?: string | null
  readonly "service_tier"?: ServiceTier
  readonly "prompt_cache_retention"?: "in-memory" | "24h" | null
  readonly "previous_response_id"?: string | null
  readonly "model"?:
    | ModelIdsShared
    | "o1-pro"
    | "o1-pro-2025-03-19"
    | "o3-pro"
    | "o3-pro-2025-06-10"
    | "o3-deep-research"
    | "o3-deep-research-2025-06-26"
    | "o4-mini-deep-research"
    | "o4-mini-deep-research-2025-06-26"
    | "computer-use-preview"
    | "computer-use-preview-2025-03-11"
    | "gpt-5-codex"
    | "gpt-5-pro"
    | "gpt-5-pro-2025-10-06"
    | "gpt-5.1-codex-max"
  readonly "reasoning"?: Reasoning | null
  readonly "background"?: boolean | null
  readonly "max_output_tokens"?: number | null
  readonly "max_tool_calls"?: number | null
  readonly "text"?: ResponseTextParam
  readonly "tools"?: ToolsArray
  readonly "tool_choice"?: ToolChoiceParam
  readonly "prompt"?: Prompt
  readonly "truncation"?: "auto" | "disabled" | null
  readonly "input"?: InputParam
  readonly "include"?: ReadonlyArray<IncludeEnum> | null
  readonly "parallel_tool_calls"?: boolean | null
  readonly "store"?: boolean | null
  readonly "instructions"?: string | null
  readonly "stream"?: boolean | null
  readonly "stream_options"?: ResponseStreamOptions
  readonly "conversation"?: ConversationParam | null
  readonly "context_management"?: ReadonlyArray<ContextManagementParam> | null
}
export const ResponsesClientEventResponseCreate = Schema.Struct({
  "type": Schema.Literal("response.create").annotate({
    "description": "The type of the client event. Always `response.create`.\n"
  }),
  "metadata": Schema.optionalKey(Metadata),
  "top_logprobs": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"
      }).check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(20)).check(
        Schema.makeFilterGroup([Schema.isGreaterThanOrEqualTo(0), Schema.isLessThanOrEqualTo(20)], {
          "description":
            "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"
        })
      )
    ])
  ),
  "temperature": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"
      }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(2)),
      Schema.Null
    ])
  ),
  "top_p": Schema.optionalKey(Schema.Union([
    Schema.Number.annotate({
      "description":
        "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"
    }).check(Schema.isFinite()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1)),
    Schema.Null
  ])),
  "user": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "This field is being replaced by `safety_identifier` and `prompt_cache_key`. Use `prompt_cache_key` instead to maintain caching optimizations.\nA stable identifier for your end-users.\nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
    })
  ),
  "safety_identifier": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies.\nThe IDs should be a string that uniquely identifies each user, with a maximum length of 64 characters. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](/docs/guides/safety-best-practices#safety-identifiers).\n"
    })
  ),
  "prompt_cache_key": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the `user` field. [Learn more](/docs/guides/prompt-caching).\n"
    })
  ),
  "service_tier": Schema.optionalKey(ServiceTier),
  "prompt_cache_retention": Schema.optionalKey(
    Schema.Union([
      Schema.Literals(["in-memory", "24h"]).annotate({
        "description":
          "The retention policy for the prompt cache. Set to `24h` to enable extended prompt caching, which keeps cached prefixes active for longer, up to a maximum of 24 hours. [Learn more](/docs/guides/prompt-caching#prompt-cache-retention).\n"
      }),
      Schema.Null
    ])
  ),
  "previous_response_id": Schema.optionalKey(
    Schema.Union([
      Schema.String.annotate({
        "description":
          "The unique ID of the previous response to the model. Use this to\ncreate multi-turn conversations. Learn more about\n[conversation state](/docs/guides/conversation-state). Cannot be used in conjunction with `conversation`.\n"
      }),
      Schema.Null
    ])
  ),
  "model": Schema.optionalKey(
    Schema.Union([
      ModelIdsShared,
      Schema.Literals([
        "o1-pro",
        "o1-pro-2025-03-19",
        "o3-pro",
        "o3-pro-2025-06-10",
        "o3-deep-research",
        "o3-deep-research-2025-06-26",
        "o4-mini-deep-research",
        "o4-mini-deep-research-2025-06-26",
        "computer-use-preview",
        "computer-use-preview-2025-03-11",
        "gpt-5-codex",
        "gpt-5-pro",
        "gpt-5-pro-2025-10-06",
        "gpt-5.1-codex-max"
      ]).annotate({ "title": "ResponsesOnlyModel" })
    ]).annotate({
      "description":
        "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](/docs/models)\nto browse and compare available models.\n"
    })
  ),
  "reasoning": Schema.optionalKey(Schema.Union([Reasoning, Schema.Null])),
  "background": Schema.optionalKey(
    Schema.Union([
      Schema.Boolean.annotate({
        "description": "Whether to run the model response in the background.\n[Learn more](/docs/guides/background).\n"
      }),
      Schema.Null
    ])
  ),
  "max_output_tokens": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](/docs/guides/reasoning).\n"
      }).check(Schema.isInt()),
      Schema.Null
    ])
  ),
  "max_tool_calls": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "The maximum number of total calls to built-in tools that can be processed in a response. This maximum number applies across all built-in tool calls, not per individual tool. Any further attempts to call a tool by the model will be ignored.\n"
      }).check(Schema.isInt()),
      Schema.Null
    ])
  ),
  "text": Schema.optionalKey(ResponseTextParam),
  "tools": Schema.optionalKey(ToolsArray),
  "tool_choice": Schema.optionalKey(ToolChoiceParam),
  "prompt": Schema.optionalKey(Prompt),
  "truncation": Schema.optionalKey(Schema.Union([
    Schema.Literals(["auto", "disabled"]).annotate({
      "description":
        "The truncation strategy to use for the model response.\n- `auto`: If the input to this Response exceeds\n  the model's context window size, the model will truncate the\n  response to fit the context window by dropping items from the beginning of the conversation.\n- `disabled` (default): If the input size will exceed the context window\n  size for a model, the request will fail with a 400 error.\n"
    }),
    Schema.Null
  ])),
  "input": Schema.optionalKey(InputParam),
  "include": Schema.optionalKey(Schema.Union([
    Schema.Array(IncludeEnum).annotate({
      "description":
        "Specify additional output data to include in the model response. Currently supported values are:\n- `web_search_call.action.sources`: Include the sources of the web search tool call.\n- `code_interpreter_call.outputs`: Includes the outputs of python code execution in code interpreter tool call items.\n- `computer_call_output.output.image_url`: Include image urls from the computer call output.\n- `file_search_call.results`: Include the search results of the file search tool call.\n- `message.input_image.image_url`: Include image urls from the input message.\n- `message.output_text.logprobs`: Include logprobs with assistant messages.\n- `reasoning.encrypted_content`: Includes an encrypted version of reasoning tokens in reasoning item outputs. This enables reasoning items to be used in multi-turn conversations when using the Responses API statelessly (like when the `store` parameter is set to `false`, or when an organization is enrolled in the zero data retention program)."
    }),
    Schema.Null
  ])),
  "parallel_tool_calls": Schema.optionalKey(
    Schema.Union([
      Schema.Boolean.annotate({ "description": "Whether to allow the model to run tool calls in parallel.\n" }),
      Schema.Null
    ])
  ),
  "store": Schema.optionalKey(
    Schema.Union([
      Schema.Boolean.annotate({
        "description": "Whether to store the generated model response for later retrieval via\nAPI.\n"
      }),
      Schema.Null
    ])
  ),
  "instructions": Schema.optionalKey(Schema.Union([
    Schema.String.annotate({
      "description":
        "A system (or developer) message inserted into the model's context.\n\nWhen using along with `previous_response_id`, the instructions from a previous\nresponse will not be carried over to the next response. This makes it simple\nto swap out system (or developer) messages in new responses.\n"
    }),
    Schema.Null
  ])),
  "stream": Schema.optionalKey(Schema.Union([
    Schema.Boolean.annotate({
      "description":
        "If set to true, the model response data will be streamed to the client\nas it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).\nSee the [Streaming section below](/docs/api-reference/responses-streaming)\nfor more information.\n"
    }),
    Schema.Null
  ])),
  "stream_options": Schema.optionalKey(ResponseStreamOptions),
  "conversation": Schema.optionalKey(Schema.Union([ConversationParam, Schema.Null])),
  "context_management": Schema.optionalKey(
    Schema.Union([
      Schema.Array(ContextManagementParam).annotate({
        "description": "Context management configuration for this request.\n"
      }).check(Schema.isMinLength(1)),
      Schema.Null
    ])
  )
}).annotate({
  "description":
    "Client event for creating a response over a persistent WebSocket connection.\nThis payload uses the same top-level fields as `POST /v1/responses`.\n\nNotes:\n- `stream` is implicit over WebSocket and should not be sent.\n- `background` is not supported over WebSocket.\n"
})
export type ResponseStreamEvent =
  | ResponseAudioDeltaEvent
  | ResponseAudioDoneEvent
  | ResponseAudioTranscriptDeltaEvent
  | ResponseAudioTranscriptDoneEvent
  | ResponseCodeInterpreterCallCodeDeltaEvent
  | ResponseCodeInterpreterCallCodeDoneEvent
  | ResponseCodeInterpreterCallCompletedEvent
  | ResponseCodeInterpreterCallInProgressEvent
  | ResponseCodeInterpreterCallInterpretingEvent
  | ResponseCompletedEvent
  | ResponseContentPartAddedEvent
  | ResponseContentPartDoneEvent
  | ResponseCreatedEvent
  | ResponseErrorEvent
  | ResponseFileSearchCallCompletedEvent
  | ResponseFileSearchCallInProgressEvent
  | ResponseFileSearchCallSearchingEvent
  | ResponseFunctionCallArgumentsDeltaEvent
  | ResponseFunctionCallArgumentsDoneEvent
  | ResponseInProgressEvent
  | ResponseFailedEvent
  | ResponseIncompleteEvent
  | ResponseOutputItemAddedEvent
  | ResponseOutputItemDoneEvent
  | ResponseReasoningSummaryPartAddedEvent
  | ResponseReasoningSummaryPartDoneEvent
  | ResponseReasoningSummaryTextDeltaEvent
  | ResponseReasoningSummaryTextDoneEvent
  | ResponseReasoningTextDeltaEvent
  | ResponseReasoningTextDoneEvent
  | ResponseRefusalDeltaEvent
  | ResponseRefusalDoneEvent
  | ResponseTextDeltaEvent
  | ResponseTextDoneEvent
  | ResponseWebSearchCallCompletedEvent
  | ResponseWebSearchCallInProgressEvent
  | ResponseWebSearchCallSearchingEvent
  | ResponseImageGenCallCompletedEvent
  | ResponseImageGenCallGeneratingEvent
  | ResponseImageGenCallInProgressEvent
  | ResponseImageGenCallPartialImageEvent
  | ResponseMCPCallArgumentsDeltaEvent
  | ResponseMCPCallArgumentsDoneEvent
  | ResponseMCPCallCompletedEvent
  | ResponseMCPCallFailedEvent
  | ResponseMCPCallInProgressEvent
  | ResponseMCPListToolsCompletedEvent
  | ResponseMCPListToolsFailedEvent
  | ResponseMCPListToolsInProgressEvent
  | ResponseOutputTextAnnotationAddedEvent
  | ResponseQueuedEvent
  | ResponseCustomToolCallInputDeltaEvent
  | ResponseCustomToolCallInputDoneEvent
  | ResponseApplyPatchCallOperationDiffDeltaEvent
  | ResponseApplyPatchCallOperationDiffDoneEvent
export const ResponseStreamEvent = Schema.Union([
  ResponseAudioDeltaEvent,
  ResponseAudioDoneEvent,
  ResponseAudioTranscriptDeltaEvent,
  ResponseAudioTranscriptDoneEvent,
  ResponseCodeInterpreterCallCodeDeltaEvent,
  ResponseCodeInterpreterCallCodeDoneEvent,
  ResponseCodeInterpreterCallCompletedEvent,
  ResponseCodeInterpreterCallInProgressEvent,
  ResponseCodeInterpreterCallInterpretingEvent,
  ResponseCompletedEvent,
  ResponseContentPartAddedEvent,
  ResponseContentPartDoneEvent,
  ResponseCreatedEvent,
  ResponseErrorEvent,
  ResponseFileSearchCallCompletedEvent,
  ResponseFileSearchCallInProgressEvent,
  ResponseFileSearchCallSearchingEvent,
  ResponseFunctionCallArgumentsDeltaEvent,
  ResponseFunctionCallArgumentsDoneEvent,
  ResponseInProgressEvent,
  ResponseFailedEvent,
  ResponseIncompleteEvent,
  ResponseOutputItemAddedEvent,
  ResponseOutputItemDoneEvent,
  ResponseReasoningSummaryPartAddedEvent,
  ResponseReasoningSummaryPartDoneEvent,
  ResponseReasoningSummaryTextDeltaEvent,
  ResponseReasoningSummaryTextDoneEvent,
  ResponseReasoningTextDeltaEvent,
  ResponseReasoningTextDoneEvent,
  ResponseRefusalDeltaEvent,
  ResponseRefusalDoneEvent,
  ResponseTextDeltaEvent,
  ResponseTextDoneEvent,
  ResponseWebSearchCallCompletedEvent,
  ResponseWebSearchCallInProgressEvent,
  ResponseWebSearchCallSearchingEvent,
  ResponseImageGenCallCompletedEvent,
  ResponseImageGenCallGeneratingEvent,
  ResponseImageGenCallInProgressEvent,
  ResponseImageGenCallPartialImageEvent,
  ResponseMCPCallArgumentsDeltaEvent,
  ResponseMCPCallArgumentsDoneEvent,
  ResponseMCPCallCompletedEvent,
  ResponseMCPCallFailedEvent,
  ResponseMCPCallInProgressEvent,
  ResponseMCPListToolsCompletedEvent,
  ResponseMCPListToolsFailedEvent,
  ResponseMCPListToolsInProgressEvent,
  ResponseOutputTextAnnotationAddedEvent,
  ResponseQueuedEvent,
  ResponseCustomToolCallInputDeltaEvent,
  ResponseCustomToolCallInputDoneEvent,
  ResponseApplyPatchCallOperationDiffDeltaEvent,
  ResponseApplyPatchCallOperationDiffDoneEvent
])
export type FineTuneMethod = {
  readonly "type": "supervised" | "dpo" | "reinforcement"
  readonly "supervised"?: FineTuneSupervisedMethod
  readonly "dpo"?: FineTuneDPOMethod
  readonly "reinforcement"?: FineTuneReinforcementMethod
}
export const FineTuneMethod = Schema.Struct({
  "type": Schema.Literals(["supervised", "dpo", "reinforcement"]).annotate({
    "description": "The type of method. Is either `supervised`, `dpo`, or `reinforcement`."
  }),
  "supervised": Schema.optionalKey(FineTuneSupervisedMethod),
  "dpo": Schema.optionalKey(FineTuneDPOMethod),
  "reinforcement": Schema.optionalKey(FineTuneReinforcementMethod)
}).annotate({ "description": "The method used for fine-tuning." })
export type CreateFineTuningJobRequest = {
  readonly "model": string | "babbage-002" | "davinci-002" | "gpt-3.5-turbo" | "gpt-4o-mini"
  readonly "training_file": string
  readonly "hyperparameters"?: {
    readonly "batch_size"?: "auto" | number
    readonly "learning_rate_multiplier"?: "auto" | number
    readonly "n_epochs"?: "auto" | number
  }
  readonly "suffix"?: string | null
  readonly "validation_file"?: string | null
  readonly "integrations"?: ReadonlyArray<unknown> | null
  readonly "seed"?: number | null
  readonly "method"?: FineTuneMethod
  readonly "metadata"?: Metadata
}
export const CreateFineTuningJobRequest = Schema.Struct({
  "model": Schema.Union([
    Schema.String,
    Schema.Literals(["babbage-002", "davinci-002", "gpt-3.5-turbo", "gpt-4o-mini"])
  ]).annotate({
    "description":
      "The name of the model to fine-tune. You can select one of the\n[supported models](/docs/guides/fine-tuning#which-models-can-be-fine-tuned).\n"
  }),
  "training_file": Schema.String.annotate({
    "description":
      "The ID of an uploaded file that contains training data.\n\nSee [upload file](/docs/api-reference/files/create) for how to upload a file.\n\nYour dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.\n\nThe contents of the file should differ depending on if the model uses the [chat](/docs/api-reference/fine-tuning/chat-input), [completions](/docs/api-reference/fine-tuning/completions-input) format, or if the fine-tuning method uses the [preference](/docs/api-reference/fine-tuning/preference-input) format.\n\nSee the [fine-tuning guide](/docs/guides/model-optimization) for more details.\n"
  }),
  "hyperparameters": Schema.optionalKey(
    Schema.Struct({
      "batch_size": Schema.optionalKey(
        Schema.Union([
          Schema.Literal("auto"),
          Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(
            Schema.isLessThanOrEqualTo(256)
          )
        ], { mode: "oneOf" }).annotate({
          "description":
            "Number of examples in each batch. A larger batch size means that model parameters\nare updated less frequently, but with lower variance.\n"
        })
      ),
      "learning_rate_multiplier": Schema.optionalKey(
        Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isFinite()).check(Schema.isGreaterThan(0))], {
          mode: "oneOf"
        }).annotate({
          "description":
            "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid\noverfitting.\n"
        })
      ),
      "n_epochs": Schema.optionalKey(
        Schema.Union([
          Schema.Literal("auto"),
          Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(
            Schema.isLessThanOrEqualTo(50)
          )
        ], { mode: "oneOf" }).annotate({
          "description":
            "The number of epochs to train the model for. An epoch refers to one full cycle\nthrough the training dataset.\n"
        })
      )
    }).annotate({
      "description":
        "The hyperparameters used for the fine-tuning job.\nThis value is now deprecated in favor of `method`, and should be passed in under the `method` parameter.\n"
    })
  ),
  "suffix": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "A string of up to 64 characters that will be added to your fine-tuned model name.\n\nFor example, a `suffix` of \"custom-model-name\" would produce a model name like `ft:gpt-4o-mini:openai:custom-model-name:7p4lURel`.\n"
    })
  ),
  "validation_file": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description":
        "The ID of an uploaded file that contains validation data.\n\nIf you provide this file, the data is used to generate validation\nmetrics periodically during fine-tuning. These metrics can be viewed in\nthe fine-tuning results file.\nThe same data should not be present in both train and validation files.\n\nYour dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.\n\nSee the [fine-tuning guide](/docs/guides/model-optimization) for more details.\n"
    })
  ),
  "integrations": Schema.optionalKey(
    Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]).annotate({
      "description": "A list of integrations to enable for your fine-tuning job."
    })
  ),
  "seed": Schema.optionalKey(
    Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({
      "description":
        "The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases.\nIf a seed is not specified, one will be generated for you.\n"
    })
  ),
  "method": Schema.optionalKey(FineTuneMethod),
  "metadata": Schema.optionalKey(Metadata)
})
export type FineTuningJob = {
  readonly "id": string
  readonly "created_at": number
  readonly "error": { readonly "code": string; readonly "message": string; readonly "param": string | null } | null
  readonly "fine_tuned_model": string | null
  readonly "finished_at": number | null
  readonly "hyperparameters": {
    readonly "batch_size"?: "auto" | number | null
    readonly "learning_rate_multiplier"?: "auto" | number
    readonly "n_epochs"?: "auto" | number
  }
  readonly "model": string
  readonly "object": "fine_tuning.job"
  readonly "organization_id": string
  readonly "result_files": ReadonlyArray<string>
  readonly "status": "validating_files" | "queued" | "running" | "succeeded" | "failed" | "cancelled"
  readonly "trained_tokens": number | null
  readonly "training_file": string
  readonly "validation_file": string | null
  readonly "integrations"?: ReadonlyArray<FineTuningIntegration> | null
  readonly "seed": number
  readonly "estimated_finish"?: number | null
  readonly "method"?: FineTuneMethod
  readonly "metadata"?: Metadata
}
export const FineTuningJob = Schema.Struct({
  "id": Schema.String.annotate({
    "description": "The object identifier, which can be referenced in the API endpoints."
  }),
  "created_at": Schema.Number.annotate({
    "description": "The Unix timestamp (in seconds) for when the fine-tuning job was created."
  }).check(Schema.isInt()),
  "error": Schema.Union([
    Schema.Struct({
      "code": Schema.String.annotate({ "description": "A machine-readable error code." }),
      "message": Schema.String.annotate({ "description": "A human-readable error message." }),
      "param": Schema.Union([
        Schema.String.annotate({
          "description":
            "The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific."
        }),
        Schema.Null
      ])
    }).annotate({
      "description":
        "For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure."
    }),
    Schema.Null
  ]),
  "fine_tuned_model": Schema.Union([
    Schema.String.annotate({
      "description":
        "The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running."
    }),
    Schema.Null
  ]),
  "finished_at": Schema.Union([
    Schema.Number.annotate({
      "description":
        "The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running."
    }).check(Schema.isInt()),
    Schema.Null
  ]),
  "hyperparameters": Schema.Struct({
    "batch_size": Schema.optionalKey(
      Schema.Union([
        Schema.Union([
          Schema.Literal("auto"),
          Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(
            Schema.isLessThanOrEqualTo(256)
          )
        ], { mode: "oneOf" }).annotate({
          "description":
            "Number of examples in each batch. A larger batch size means that model parameters\nare updated less frequently, but with lower variance.\n"
        }),
        Schema.Null
      ])
    ),
    "learning_rate_multiplier": Schema.optionalKey(
      Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isFinite()).check(Schema.isGreaterThan(0))], {
        mode: "oneOf"
      }).annotate({
        "description":
          "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid\noverfitting.\n"
      })
    ),
    "n_epochs": Schema.optionalKey(
      Schema.Union([
        Schema.Literal("auto"),
        Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(1)).check(
          Schema.isLessThanOrEqualTo(50)
        )
      ], { mode: "oneOf" }).annotate({
        "description":
          "The number of epochs to train the model for. An epoch refers to one full cycle\nthrough the training dataset.\n"
      })
    )
  }).annotate({
    "description":
      "The hyperparameters used for the fine-tuning job. This value will only be returned when running `supervised` jobs."
  }),
  "model": Schema.String.annotate({ "description": "The base model that is being fine-tuned." }),
  "object": Schema.Literal("fine_tuning.job").annotate({
    "description": "The object type, which is always \"fine_tuning.job\"."
  }),
  "organization_id": Schema.String.annotate({ "description": "The organization that owns the fine-tuning job." }),
  "result_files": Schema.Array(Schema.String).annotate({
    "description":
      "The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](/docs/api-reference/files/retrieve-contents)."
  }),
  "status": Schema.Literals(["validating_files", "queued", "running", "succeeded", "failed", "cancelled"]).annotate({
    "description":
      "The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`."
  }),
  "trained_tokens": Schema.Union([
    Schema.Number.annotate({
      "description":
        "The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running."
    }).check(Schema.isInt()),
    Schema.Null
  ]),
  "training_file": Schema.String.annotate({
    "description":
      "The file ID used for training. You can retrieve the training data with the [Files API](/docs/api-reference/files/retrieve-contents)."
  }),
  "validation_file": Schema.Union([
    Schema.String.annotate({
      "description":
        "The file ID used for validation. You can retrieve the validation results with the [Files API](/docs/api-reference/files/retrieve-contents)."
    }),
    Schema.Null
  ]),
  "integrations": Schema.optionalKey(
    Schema.Union([
      Schema.Array(Schema.Union([FineTuningIntegration], { mode: "oneOf" })).annotate({
        "description": "A list of integrations to enable for this fine-tuning job."
      }).check(Schema.isMaxLength(5)),
      Schema.Null
    ])
  ),
  "seed": Schema.Number.annotate({ "description": "The seed used for the fine-tuning job." }).check(Schema.isInt()),
  "estimated_finish": Schema.optionalKey(
    Schema.Union([
      Schema.Number.annotate({
        "description":
          "The Unix timestamp (in seconds) for when the fine-tuning job is estimated to finish. The value will be null if the fine-tuning job is not running."
      }).check(Schema.isInt()),
      Schema.Null
    ])
  ),
  "method": Schema.optionalKey(FineTuneMethod),
  "metadata": Schema.optionalKey(Metadata)
}).annotate({
  "title": "FineTuningJob",
  "description": "The `fine_tuning.job` object represents a fine-tuning job that has been created through the API.\n"
})
export type ListPaginatedFineTuningJobsResponse = {
  readonly "data": ReadonlyArray<FineTuningJob>
  readonly "has_more": boolean
  readonly "object": "list"
}
export const ListPaginatedFineTuningJobsResponse = Schema.Struct({
  "data": Schema.Array(FineTuningJob),
  "has_more": Schema.Boolean,
  "object": Schema.Literal("list")
})
// schemas
export type ListAssistantsParams = {
  readonly "limit"?: number
  readonly "order"?: "asc" | "desc"
  readonly "after"?: string
  readonly "before"?: string
}
export const ListAssistantsParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])),
  "after": Schema.optionalKey(Schema.String),
  "before": Schema.optionalKey(Schema.String)
})
export type ListAssistants200 = ListAssistantsResponse
export const ListAssistants200 = ListAssistantsResponse
export type CreateAssistantRequestJson = CreateAssistantRequest
export const CreateAssistantRequestJson = CreateAssistantRequest
export type CreateAssistant200 = AssistantObject
export const CreateAssistant200 = AssistantObject
export type GetAssistant200 = AssistantObject
export const GetAssistant200 = AssistantObject
export type ModifyAssistantRequestJson = ModifyAssistantRequest
export const ModifyAssistantRequestJson = ModifyAssistantRequest
export type ModifyAssistant200 = AssistantObject
export const ModifyAssistant200 = AssistantObject
export type DeleteAssistant200 = DeleteAssistantResponse
export const DeleteAssistant200 = DeleteAssistantResponse
export type CreateSpeechRequestJson = CreateSpeechRequest
export const CreateSpeechRequestJson = CreateSpeechRequest
export type CreateSpeech200Sse = CreateSpeechResponseStreamEvent
export const CreateSpeech200Sse = CreateSpeechResponseStreamEvent
export type CreateTranscriptionRequestFormData = CreateTranscriptionRequest
export const CreateTranscriptionRequestFormData = CreateTranscriptionRequest
export type CreateTranscription200 =
  | CreateTranscriptionResponseJson
  | CreateTranscriptionResponseDiarizedJson
  | CreateTranscriptionResponseVerboseJson
export const CreateTranscription200 = Schema.Union([
  CreateTranscriptionResponseJson,
  CreateTranscriptionResponseDiarizedJson,
  CreateTranscriptionResponseVerboseJson
], { mode: "oneOf" })
export type CreateTranscription200Sse = CreateTranscriptionResponseStreamEvent
export const CreateTranscription200Sse = CreateTranscriptionResponseStreamEvent
export type CreateTranslationRequestFormData = CreateTranslationRequest
export const CreateTranslationRequestFormData = CreateTranslationRequest
export type CreateTranslation200 = CreateTranslationResponseJson | CreateTranslationResponseVerboseJson
export const CreateTranslation200 = Schema.Union(
  [CreateTranslationResponseJson, CreateTranslationResponseVerboseJson],
  { mode: "oneOf" }
)
export type ListVoiceConsentsParams = { readonly "after"?: string; readonly "limit"?: number }
export const ListVoiceConsentsParams = Schema.Struct({
  "after": Schema.optionalKey(Schema.String),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt()))
})
export type ListVoiceConsents200 = VoiceConsentListResource
export const ListVoiceConsents200 = VoiceConsentListResource
export type CreateVoiceConsentRequestFormData = CreateVoiceConsentRequest
export const CreateVoiceConsentRequestFormData = CreateVoiceConsentRequest
export type CreateVoiceConsent200 = VoiceConsentResource
export const CreateVoiceConsent200 = VoiceConsentResource
export type GetVoiceConsent200 = VoiceConsentResource
export const GetVoiceConsent200 = VoiceConsentResource
export type UpdateVoiceConsentRequestJson = UpdateVoiceConsentRequest
export const UpdateVoiceConsentRequestJson = UpdateVoiceConsentRequest
export type UpdateVoiceConsent200 = VoiceConsentResource
export const UpdateVoiceConsent200 = VoiceConsentResource
export type DeleteVoiceConsent200 = VoiceConsentDeletedResource
export const DeleteVoiceConsent200 = VoiceConsentDeletedResource
export type CreateVoiceRequestFormData = CreateVoiceRequest
export const CreateVoiceRequestFormData = CreateVoiceRequest
export type CreateVoice200 = VoiceResource
export const CreateVoice200 = VoiceResource
export type ListBatchesParams = { readonly "after"?: string; readonly "limit"?: number }
export const ListBatchesParams = Schema.Struct({
  "after": Schema.optionalKey(Schema.String),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt()))
})
export type ListBatches200 = ListBatchesResponse
export const ListBatches200 = ListBatchesResponse
export type CreateBatchRequestJson = {
  readonly "input_file_id": string
  readonly "endpoint":
    | "/v1/responses"
    | "/v1/chat/completions"
    | "/v1/embeddings"
    | "/v1/completions"
    | "/v1/moderations"
    | "/v1/images/generations"
    | "/v1/images/edits"
  readonly "completion_window": "24h"
  readonly "metadata"?: Metadata
  readonly "output_expires_after"?: BatchFileExpirationAfter
}
export const CreateBatchRequestJson = Schema.Struct({
  "input_file_id": Schema.String.annotate({
    "description":
      "The ID of an uploaded file that contains requests for the new batch.\n\nSee [upload file](/docs/api-reference/files/create) for how to upload a file.\n\nYour input file must be formatted as a [JSONL file](/docs/api-reference/batch/request-input), and must be uploaded with the purpose `batch`. The file can contain up to 50,000 requests, and can be up to 200 MB in size.\n"
  }),
  "endpoint": Schema.Literals([
    "/v1/responses",
    "/v1/chat/completions",
    "/v1/embeddings",
    "/v1/completions",
    "/v1/moderations",
    "/v1/images/generations",
    "/v1/images/edits"
  ]).annotate({
    "description":
      "The endpoint to be used for all requests in the batch. Currently `/v1/responses`, `/v1/chat/completions`, `/v1/embeddings`, `/v1/completions`, `/v1/moderations`, `/v1/images/generations`, and `/v1/images/edits` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch."
  }),
  "completion_window": Schema.Literal("24h").annotate({
    "description": "The time frame within which the batch should be processed. Currently only `24h` is supported."
  }),
  "metadata": Schema.optionalKey(Metadata),
  "output_expires_after": Schema.optionalKey(BatchFileExpirationAfter)
})
export type CreateBatch200 = Batch
export const CreateBatch200 = Batch
export type RetrieveBatch200 = Batch
export const RetrieveBatch200 = Batch
export type CancelBatch200 = Batch
export const CancelBatch200 = Batch
export type ListChatCompletionsParams = {
  readonly "model"?: string
  readonly "metadata"?: Metadata
  readonly "after"?: string
  readonly "limit"?: number
  readonly "order"?: "asc" | "desc"
}
export const ListChatCompletionsParams = Schema.Struct({
  "model": Schema.optionalKey(Schema.String),
  "metadata": Schema.optionalKey(Metadata),
  "after": Schema.optionalKey(Schema.String),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]))
})
export type ListChatCompletions200 = ChatCompletionList
export const ListChatCompletions200 = ChatCompletionList
export type CreateChatCompletionRequestJson = CreateChatCompletionRequest
export const CreateChatCompletionRequestJson = CreateChatCompletionRequest
export type CreateChatCompletion200 = CreateChatCompletionResponse
export const CreateChatCompletion200 = CreateChatCompletionResponse
export type CreateChatCompletion200Sse = CreateChatCompletionStreamResponse
export const CreateChatCompletion200Sse = CreateChatCompletionStreamResponse
export type GetChatCompletion200 = CreateChatCompletionResponse
export const GetChatCompletion200 = CreateChatCompletionResponse
export type UpdateChatCompletionRequestJson = { readonly "metadata": Metadata }
export const UpdateChatCompletionRequestJson = Schema.Struct({ "metadata": Metadata })
export type UpdateChatCompletion200 = CreateChatCompletionResponse
export const UpdateChatCompletion200 = CreateChatCompletionResponse
export type DeleteChatCompletion200 = ChatCompletionDeleted
export const DeleteChatCompletion200 = ChatCompletionDeleted
export type GetChatCompletionMessagesParams = {
  readonly "after"?: string
  readonly "limit"?: number
  readonly "order"?: "asc" | "desc"
}
export const GetChatCompletionMessagesParams = Schema.Struct({
  "after": Schema.optionalKey(Schema.String),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]))
})
export type GetChatCompletionMessages200 = ChatCompletionMessageList
export const GetChatCompletionMessages200 = ChatCompletionMessageList
export type CreateCompletionRequestJson = CreateCompletionRequest
export const CreateCompletionRequestJson = CreateCompletionRequest
export type CreateCompletion200 = CreateCompletionResponse
export const CreateCompletion200 = CreateCompletionResponse
export type ListContainersParams = {
  readonly "limit"?: number
  readonly "order"?: "asc" | "desc"
  readonly "after"?: string
  readonly "name"?: string
}
export const ListContainersParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])),
  "after": Schema.optionalKey(Schema.String),
  "name": Schema.optionalKey(Schema.String)
})
export type ListContainers200 = ContainerListResource
export const ListContainers200 = ContainerListResource
export type CreateContainerRequestJson = CreateContainerBody
export const CreateContainerRequestJson = CreateContainerBody
export type CreateContainer200 = ContainerResource
export const CreateContainer200 = ContainerResource
export type RetrieveContainer200 = ContainerResource
export const RetrieveContainer200 = ContainerResource
export type ListContainerFilesParams = {
  readonly "limit"?: number
  readonly "order"?: "asc" | "desc"
  readonly "after"?: string
}
export const ListContainerFilesParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])),
  "after": Schema.optionalKey(Schema.String)
})
export type ListContainerFiles200 = ContainerFileListResource
export const ListContainerFiles200 = ContainerFileListResource
export type CreateContainerFileRequestJson = CreateContainerFileBody
export const CreateContainerFileRequestJson = CreateContainerFileBody
export type CreateContainerFileRequestFormData = CreateContainerFileBody
export const CreateContainerFileRequestFormData = CreateContainerFileBody
export type CreateContainerFile200 = ContainerFileResource
export const CreateContainerFile200 = ContainerFileResource
export type RetrieveContainerFile200 = ContainerFileResource
export const RetrieveContainerFile200 = ContainerFileResource
export type ListConversationItemsParams = {
  readonly "limit"?: number
  readonly "order"?: "asc" | "desc"
  readonly "after"?: string
  readonly "include"?: ReadonlyArray<IncludeEnum>
}
export const ListConversationItemsParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])),
  "after": Schema.optionalKey(Schema.String),
  "include": Schema.optionalKey(Schema.Array(IncludeEnum))
})
export type ListConversationItems200 = ConversationItemList
export const ListConversationItems200 = ConversationItemList
export type CreateConversationItemsParams = { readonly "include"?: ReadonlyArray<IncludeEnum> }
export const CreateConversationItemsParams = Schema.Struct({ "include": Schema.optionalKey(Schema.Array(IncludeEnum)) })
export type CreateConversationItemsRequestJson = {
  readonly "items": ReadonlyArray<InputItem>
  readonly [x: string]: unknown
}
export const CreateConversationItemsRequestJson = Schema.StructWithRest(
  Schema.Struct({
    "items": Schema.Array(InputItem).annotate({
      "description": "The items to add to the conversation. You may add up to 20 items at a time.\n"
    }).check(Schema.isMaxLength(20))
  }),
  [Schema.Record(Schema.String, Schema.Json)]
)
export type CreateConversationItems200 = ConversationItemList
export const CreateConversationItems200 = ConversationItemList
export type GetConversationItemParams = { readonly "include"?: ReadonlyArray<IncludeEnum> }
export const GetConversationItemParams = Schema.Struct({ "include": Schema.optionalKey(Schema.Array(IncludeEnum)) })
export type GetConversationItem200 = ConversationItem
export const GetConversationItem200 = ConversationItem
export type DeleteConversationItem200 = ConversationResource
export const DeleteConversationItem200 = ConversationResource
export type CreateEmbeddingRequestJson = CreateEmbeddingRequest
export const CreateEmbeddingRequestJson = CreateEmbeddingRequest
export type CreateEmbedding200 = CreateEmbeddingResponse
export const CreateEmbedding200 = CreateEmbeddingResponse
export type ListEvalsParams = {
  readonly "after"?: string
  readonly "limit"?: number
  readonly "order"?: "asc" | "desc"
  readonly "order_by"?: "created_at" | "updated_at"
}
export const ListEvalsParams = Schema.Struct({
  "after": Schema.optionalKey(Schema.String),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])),
  "order_by": Schema.optionalKey(Schema.Literals(["created_at", "updated_at"]))
})
export type ListEvals200 = EvalList
export const ListEvals200 = EvalList
export type CreateEvalRequestJson = CreateEvalRequest
export const CreateEvalRequestJson = CreateEvalRequest
export type CreateEval201 = Eval
export const CreateEval201 = Eval
export type GetEval200 = Eval
export const GetEval200 = Eval
export type UpdateEvalRequestJson = { readonly "name"?: string; readonly "metadata"?: Metadata }
export const UpdateEvalRequestJson = Schema.Struct({
  "name": Schema.optionalKey(Schema.String.annotate({ "description": "Rename the evaluation." })),
  "metadata": Schema.optionalKey(Metadata)
})
export type UpdateEval200 = Eval
export const UpdateEval200 = Eval
export type DeleteEval200 = { readonly "object": string; readonly "deleted": boolean; readonly "eval_id": string }
export const DeleteEval200 = Schema.Struct({
  "object": Schema.String,
  "deleted": Schema.Boolean,
  "eval_id": Schema.String
})
export type DeleteEval404 = Error
export const DeleteEval404 = Error
export type GetEvalRunsParams = {
  readonly "after"?: string
  readonly "limit"?: number
  readonly "order"?: "asc" | "desc"
  readonly "status"?: "queued" | "in_progress" | "completed" | "canceled" | "failed"
}
export const GetEvalRunsParams = Schema.Struct({
  "after": Schema.optionalKey(Schema.String),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])),
  "status": Schema.optionalKey(Schema.Literals(["queued", "in_progress", "completed", "canceled", "failed"]))
})
export type GetEvalRuns200 = EvalRunList
export const GetEvalRuns200 = EvalRunList
export type CreateEvalRunRequestJson = CreateEvalRunRequest
export const CreateEvalRunRequestJson = CreateEvalRunRequest
export type CreateEvalRun201 = EvalRun
export const CreateEvalRun201 = EvalRun
export type CreateEvalRun400 = Error
export const CreateEvalRun400 = Error
export type GetEvalRun200 = EvalRun
export const GetEvalRun200 = EvalRun
export type CancelEvalRun200 = EvalRun
export const CancelEvalRun200 = EvalRun
export type DeleteEvalRun200 = { readonly "object"?: string; readonly "deleted"?: boolean; readonly "run_id"?: string }
export const DeleteEvalRun200 = Schema.Struct({
  "object": Schema.optionalKey(Schema.String),
  "deleted": Schema.optionalKey(Schema.Boolean),
  "run_id": Schema.optionalKey(Schema.String)
})
export type DeleteEvalRun404 = Error
export const DeleteEvalRun404 = Error
export type GetEvalRunOutputItemsParams = {
  readonly "after"?: string
  readonly "limit"?: number
  readonly "status"?: "fail" | "pass"
  readonly "order"?: "asc" | "desc"
}
export const GetEvalRunOutputItemsParams = Schema.Struct({
  "after": Schema.optionalKey(Schema.String),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "status": Schema.optionalKey(Schema.Literals(["fail", "pass"])),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]))
})
export type GetEvalRunOutputItems200 = EvalRunOutputItemList
export const GetEvalRunOutputItems200 = EvalRunOutputItemList
export type GetEvalRunOutputItem200 = EvalRunOutputItem
export const GetEvalRunOutputItem200 = EvalRunOutputItem
export type ListFilesParams = {
  readonly "purpose"?: string
  readonly "limit"?: number
  readonly "order"?: "asc" | "desc"
  readonly "after"?: string
}
export const ListFilesParams = Schema.Struct({
  "purpose": Schema.optionalKey(Schema.String),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])),
  "after": Schema.optionalKey(Schema.String)
})
export type ListFiles200 = ListFilesResponse
export const ListFiles200 = ListFilesResponse
export type CreateFileRequestFormData = CreateFileRequest
export const CreateFileRequestFormData = CreateFileRequest
export type CreateFile200 = OpenAIFile
export const CreateFile200 = OpenAIFile
export type RetrieveFile200 = OpenAIFile
export const RetrieveFile200 = OpenAIFile
export type DeleteFile200 = DeleteFileResponse
export const DeleteFile200 = DeleteFileResponse
export type DownloadFile200 = string
export const DownloadFile200 = Schema.String
export type RunGraderRequestJson = RunGraderRequest
export const RunGraderRequestJson = RunGraderRequest
export type RunGrader200 = RunGraderResponse
export const RunGrader200 = RunGraderResponse
export type ValidateGraderRequestJson = ValidateGraderRequest
export const ValidateGraderRequestJson = ValidateGraderRequest
export type ValidateGrader200 = ValidateGraderResponse
export const ValidateGrader200 = ValidateGraderResponse
export type ListFineTuningCheckpointPermissionsParams = {
  readonly "project_id"?: string
  readonly "after"?: string
  readonly "limit"?: number
  readonly "order"?: "ascending" | "descending"
}
export const ListFineTuningCheckpointPermissionsParams = Schema.Struct({
  "project_id": Schema.optionalKey(Schema.String),
  "after": Schema.optionalKey(Schema.String),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["ascending", "descending"]))
})
export type ListFineTuningCheckpointPermissions200 = ListFineTuningCheckpointPermissionResponse
export const ListFineTuningCheckpointPermissions200 = ListFineTuningCheckpointPermissionResponse
export type CreateFineTuningCheckpointPermissionRequestJson = CreateFineTuningCheckpointPermissionRequest
export const CreateFineTuningCheckpointPermissionRequestJson = CreateFineTuningCheckpointPermissionRequest
export type CreateFineTuningCheckpointPermission200 = ListFineTuningCheckpointPermissionResponse
export const CreateFineTuningCheckpointPermission200 = ListFineTuningCheckpointPermissionResponse
export type DeleteFineTuningCheckpointPermission200 = DeleteFineTuningCheckpointPermissionResponse
export const DeleteFineTuningCheckpointPermission200 = DeleteFineTuningCheckpointPermissionResponse
export type ListPaginatedFineTuningJobsParams = {
  readonly "after"?: string
  readonly "limit"?: number
  readonly "metadata"?: {} | null
}
export const ListPaginatedFineTuningJobsParams = Schema.Struct({
  "after": Schema.optionalKey(Schema.String),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "metadata": Schema.optionalKey(Schema.Union([Schema.Struct({}), Schema.Null]))
})
export type ListPaginatedFineTuningJobs200 = ListPaginatedFineTuningJobsResponse
export const ListPaginatedFineTuningJobs200 = ListPaginatedFineTuningJobsResponse
export type CreateFineTuningJobRequestJson = CreateFineTuningJobRequest
export const CreateFineTuningJobRequestJson = CreateFineTuningJobRequest
export type CreateFineTuningJob200 = FineTuningJob
export const CreateFineTuningJob200 = FineTuningJob
export type RetrieveFineTuningJob200 = FineTuningJob
export const RetrieveFineTuningJob200 = FineTuningJob
export type CancelFineTuningJob200 = FineTuningJob
export const CancelFineTuningJob200 = FineTuningJob
export type ListFineTuningJobCheckpointsParams = { readonly "after"?: string; readonly "limit"?: number }
export const ListFineTuningJobCheckpointsParams = Schema.Struct({
  "after": Schema.optionalKey(Schema.String),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt()))
})
export type ListFineTuningJobCheckpoints200 = ListFineTuningJobCheckpointsResponse
export const ListFineTuningJobCheckpoints200 = ListFineTuningJobCheckpointsResponse
export type ListFineTuningEventsParams = { readonly "after"?: string; readonly "limit"?: number }
export const ListFineTuningEventsParams = Schema.Struct({
  "after": Schema.optionalKey(Schema.String),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt()))
})
export type ListFineTuningEvents200 = ListFineTuningJobEventsResponse
export const ListFineTuningEvents200 = ListFineTuningJobEventsResponse
export type PauseFineTuningJob200 = FineTuningJob
export const PauseFineTuningJob200 = FineTuningJob
export type ResumeFineTuningJob200 = FineTuningJob
export const ResumeFineTuningJob200 = FineTuningJob
export type CreateImageEditRequestJson = EditImageBodyJsonParam
export const CreateImageEditRequestJson = EditImageBodyJsonParam
export type CreateImageEditRequestFormData = CreateImageEditRequest
export const CreateImageEditRequestFormData = CreateImageEditRequest
export type CreateImageEdit200 = ImagesResponse
export const CreateImageEdit200 = ImagesResponse
export type CreateImageEdit200Sse = ImageEditStreamEvent
export const CreateImageEdit200Sse = ImageEditStreamEvent
export type CreateImageRequestJson = CreateImageRequest
export const CreateImageRequestJson = CreateImageRequest
export type CreateImage200 = ImagesResponse
export const CreateImage200 = ImagesResponse
export type CreateImage200Sse = ImageGenStreamEvent
export const CreateImage200Sse = ImageGenStreamEvent
export type CreateImageVariationRequestFormData = CreateImageVariationRequest
export const CreateImageVariationRequestFormData = CreateImageVariationRequest
export type CreateImageVariation200 = ImagesResponse
export const CreateImageVariation200 = ImagesResponse
export type ListModels200 = ListModelsResponse
export const ListModels200 = ListModelsResponse
export type RetrieveModel200 = Model
export const RetrieveModel200 = Model
export type DeleteModel200 = DeleteModelResponse
export const DeleteModel200 = DeleteModelResponse
export type CreateModerationRequestJson = CreateModerationRequest
export const CreateModerationRequestJson = CreateModerationRequest
export type CreateModeration200 = CreateModerationResponse
export const CreateModeration200 = CreateModerationResponse
export type AdminApiKeysListParams = {
  readonly "after"?: string | null
  readonly "order"?: "asc" | "desc"
  readonly "limit"?: number
}
export const AdminApiKeysListParams = Schema.Struct({
  "after": Schema.optionalKey(
    Schema.Union([Schema.String, Schema.Null]).annotate({
      "description": "Return keys with IDs that come after this ID in the pagination order."
    })
  ),
  "order": Schema.optionalKey(
    Schema.Literals(["asc", "desc"]).annotate({
      "description": "Order results by creation time, ascending or descending."
    })
  ),
  "limit": Schema.optionalKey(
    Schema.Number.annotate({ "description": "Maximum number of keys to return." }).check(Schema.isInt())
  )
})
export type AdminApiKeysList200 = ApiKeyList
export const AdminApiKeysList200 = ApiKeyList
export type AdminApiKeysCreateRequestJson = { readonly "name": string }
export const AdminApiKeysCreateRequestJson = Schema.Struct({ "name": Schema.String })
export type AdminApiKeysCreate200 = AdminApiKey
export const AdminApiKeysCreate200 = AdminApiKey
export type AdminApiKeysGet200 = AdminApiKey
export const AdminApiKeysGet200 = AdminApiKey
export type AdminApiKeysDelete200 = { readonly "id"?: string; readonly "object"?: string; readonly "deleted"?: boolean }
export const AdminApiKeysDelete200 = Schema.Struct({
  "id": Schema.optionalKey(Schema.String),
  "object": Schema.optionalKey(Schema.String),
  "deleted": Schema.optionalKey(Schema.Boolean)
})
export type ListAuditLogsParams = {
  readonly "effective_at[gt]"?: number
  readonly "effective_at[gte]"?: number
  readonly "effective_at[lt]"?: number
  readonly "effective_at[lte]"?: number
  readonly "project_ids[]"?: ReadonlyArray<string>
  readonly "event_types[]"?: ReadonlyArray<AuditLogEventType>
  readonly "actor_ids[]"?: ReadonlyArray<string>
  readonly "actor_emails[]"?: ReadonlyArray<string>
  readonly "resource_ids[]"?: ReadonlyArray<string>
  readonly "limit"?: number
  readonly "after"?: string
  readonly "before"?: string
}
export const ListAuditLogsParams = Schema.Struct({
  "effective_at[gt]": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "Return only events whose `effective_at` (Unix seconds) is greater than this value."
    }).check(Schema.isInt())
  ),
  "effective_at[gte]": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "Return only events whose `effective_at` (Unix seconds) is greater than or equal to this value."
    }).check(Schema.isInt())
  ),
  "effective_at[lt]": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "Return only events whose `effective_at` (Unix seconds) is less than this value."
    }).check(Schema.isInt())
  ),
  "effective_at[lte]": Schema.optionalKey(
    Schema.Number.annotate({
      "description": "Return only events whose `effective_at` (Unix seconds) is less than or equal to this value."
    }).check(Schema.isInt())
  ),
  "project_ids[]": Schema.optionalKey(Schema.Array(Schema.String)),
  "event_types[]": Schema.optionalKey(Schema.Array(AuditLogEventType)),
  "actor_ids[]": Schema.optionalKey(Schema.Array(Schema.String)),
  "actor_emails[]": Schema.optionalKey(Schema.Array(Schema.String)),
  "resource_ids[]": Schema.optionalKey(Schema.Array(Schema.String)),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "after": Schema.optionalKey(Schema.String),
  "before": Schema.optionalKey(Schema.String)
})
export type ListAuditLogs200 = ListAuditLogsResponse
export const ListAuditLogs200 = ListAuditLogsResponse
export type ListOrganizationCertificatesParams = {
  readonly "limit"?: number
  readonly "after"?: string
  readonly "order"?: "asc" | "desc"
}
export const ListOrganizationCertificatesParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "after": Schema.optionalKey(Schema.String),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]))
})
export type ListOrganizationCertificates200 = ListCertificatesResponse
export const ListOrganizationCertificates200 = ListCertificatesResponse
export type UploadCertificateRequestJson = UploadCertificateRequest
export const UploadCertificateRequestJson = UploadCertificateRequest
export type UploadCertificate200 = Certificate
export const UploadCertificate200 = Certificate
export type ActivateOrganizationCertificatesRequestJson = ToggleCertificatesRequest
export const ActivateOrganizationCertificatesRequestJson = ToggleCertificatesRequest
export type ActivateOrganizationCertificates200 = ListCertificatesResponse
export const ActivateOrganizationCertificates200 = ListCertificatesResponse
export type DeactivateOrganizationCertificatesRequestJson = ToggleCertificatesRequest
export const DeactivateOrganizationCertificatesRequestJson = ToggleCertificatesRequest
export type DeactivateOrganizationCertificates200 = ListCertificatesResponse
export const DeactivateOrganizationCertificates200 = ListCertificatesResponse
export type GetCertificateParams = { readonly "include"?: ReadonlyArray<"content"> }
export const GetCertificateParams = Schema.Struct({
  "include": Schema.optionalKey(Schema.Array(Schema.Literal("content")))
})
export type GetCertificate200 = Certificate
export const GetCertificate200 = Certificate
export type ModifyCertificateRequestJson = ModifyCertificateRequest
export const ModifyCertificateRequestJson = ModifyCertificateRequest
export type ModifyCertificate200 = Certificate
export const ModifyCertificate200 = Certificate
export type DeleteCertificate200 = DeleteCertificateResponse
export const DeleteCertificate200 = DeleteCertificateResponse
export type UsageCostsParams = {
  readonly "start_time": number
  readonly "end_time"?: number
  readonly "bucket_width"?: "1d"
  readonly "project_ids"?: ReadonlyArray<string>
  readonly "group_by"?: ReadonlyArray<"project_id" | "line_item">
  readonly "limit"?: number
  readonly "page"?: string
}
export const UsageCostsParams = Schema.Struct({
  "start_time": Schema.Number.check(Schema.isInt()),
  "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "bucket_width": Schema.optionalKey(Schema.Literal("1d")),
  "project_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "group_by": Schema.optionalKey(Schema.Array(Schema.Literals(["project_id", "line_item"]))),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "page": Schema.optionalKey(Schema.String)
})
export type UsageCosts200 = UsageResponse
export const UsageCosts200 = UsageResponse
export type ListGroupsParams = {
  readonly "limit"?: number
  readonly "after"?: string
  readonly "order"?: "asc" | "desc"
}
export const ListGroupsParams = Schema.Struct({
  "limit": Schema.optionalKey(
    Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1000))
  ),
  "after": Schema.optionalKey(Schema.String),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]))
})
export type ListGroups200 = GroupListResource
export const ListGroups200 = GroupListResource
export type CreateGroupRequestJson = CreateGroupBody
export const CreateGroupRequestJson = CreateGroupBody
export type CreateGroup200 = GroupResponse
export const CreateGroup200 = GroupResponse
export type UpdateGroupRequestJson = UpdateGroupBody
export const UpdateGroupRequestJson = UpdateGroupBody
export type UpdateGroup200 = GroupResourceWithSuccess
export const UpdateGroup200 = GroupResourceWithSuccess
export type DeleteGroup200 = GroupDeletedResource
export const DeleteGroup200 = GroupDeletedResource
export type ListGroupRoleAssignmentsParams = {
  readonly "limit"?: number
  readonly "after"?: string
  readonly "order"?: "asc" | "desc"
}
export const ListGroupRoleAssignmentsParams = Schema.Struct({
  "limit": Schema.optionalKey(
    Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1000))
  ),
  "after": Schema.optionalKey(Schema.String),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]))
})
export type ListGroupRoleAssignments200 = RoleListResource
export const ListGroupRoleAssignments200 = RoleListResource
export type AssignGroupRoleRequestJson = PublicAssignOrganizationGroupRoleBody
export const AssignGroupRoleRequestJson = PublicAssignOrganizationGroupRoleBody
export type AssignGroupRole200 = GroupRoleAssignment
export const AssignGroupRole200 = GroupRoleAssignment
export type UnassignGroupRole200 = DeletedRoleAssignmentResource
export const UnassignGroupRole200 = DeletedRoleAssignmentResource
export type ListGroupUsersParams = {
  readonly "limit"?: number
  readonly "after"?: string
  readonly "order"?: "asc" | "desc"
}
export const ListGroupUsersParams = Schema.Struct({
  "limit": Schema.optionalKey(
    Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1000))
  ),
  "after": Schema.optionalKey(Schema.String),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]))
})
export type ListGroupUsers200 = UserListResource
export const ListGroupUsers200 = UserListResource
export type AddGroupUserRequestJson = CreateGroupUserBody
export const AddGroupUserRequestJson = CreateGroupUserBody
export type AddGroupUser200 = GroupUserAssignment
export const AddGroupUser200 = GroupUserAssignment
export type RemoveGroupUser200 = GroupUserDeletedResource
export const RemoveGroupUser200 = GroupUserDeletedResource
export type ListInvitesParams = { readonly "limit"?: number; readonly "after"?: string }
export const ListInvitesParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "after": Schema.optionalKey(Schema.String)
})
export type ListInvites200 = InviteListResponse
export const ListInvites200 = InviteListResponse
export type InviteUserRequestJson = InviteRequest
export const InviteUserRequestJson = InviteRequest
export type InviteUser200 = Invite
export const InviteUser200 = Invite
export type RetrieveInvite200 = Invite
export const RetrieveInvite200 = Invite
export type DeleteInvite200 = InviteDeleteResponse
export const DeleteInvite200 = InviteDeleteResponse
export type ListProjectsParams = {
  readonly "limit"?: number
  readonly "after"?: string
  readonly "include_archived"?: boolean
}
export const ListProjectsParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "after": Schema.optionalKey(Schema.String),
  "include_archived": Schema.optionalKey(Schema.Boolean)
})
export type ListProjects200 = ProjectListResponse
export const ListProjects200 = ProjectListResponse
export type CreateProjectRequestJson = ProjectCreateRequest
export const CreateProjectRequestJson = ProjectCreateRequest
export type CreateProject200 = Project
export const CreateProject200 = Project
export type RetrieveProject200 = Project
export const RetrieveProject200 = Project
export type ModifyProjectRequestJson = ProjectUpdateRequest
export const ModifyProjectRequestJson = ProjectUpdateRequest
export type ModifyProject200 = Project
export const ModifyProject200 = Project
export type ModifyProject400 = ErrorResponse
export const ModifyProject400 = ErrorResponse
export type ListProjectApiKeysParams = { readonly "limit"?: number; readonly "after"?: string }
export const ListProjectApiKeysParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "after": Schema.optionalKey(Schema.String)
})
export type ListProjectApiKeys200 = ProjectApiKeyListResponse
export const ListProjectApiKeys200 = ProjectApiKeyListResponse
export type RetrieveProjectApiKey200 = ProjectApiKey
export const RetrieveProjectApiKey200 = ProjectApiKey
export type DeleteProjectApiKey200 = ProjectApiKeyDeleteResponse
export const DeleteProjectApiKey200 = ProjectApiKeyDeleteResponse
export type DeleteProjectApiKey400 = ErrorResponse
export const DeleteProjectApiKey400 = ErrorResponse
export type ArchiveProject200 = Project
export const ArchiveProject200 = Project
export type ListProjectCertificatesParams = {
  readonly "limit"?: number
  readonly "after"?: string
  readonly "order"?: "asc" | "desc"
}
export const ListProjectCertificatesParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "after": Schema.optionalKey(Schema.String),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]))
})
export type ListProjectCertificates200 = ListCertificatesResponse
export const ListProjectCertificates200 = ListCertificatesResponse
export type ActivateProjectCertificatesRequestJson = ToggleCertificatesRequest
export const ActivateProjectCertificatesRequestJson = ToggleCertificatesRequest
export type ActivateProjectCertificates200 = ListCertificatesResponse
export const ActivateProjectCertificates200 = ListCertificatesResponse
export type DeactivateProjectCertificatesRequestJson = ToggleCertificatesRequest
export const DeactivateProjectCertificatesRequestJson = ToggleCertificatesRequest
export type DeactivateProjectCertificates200 = ListCertificatesResponse
export const DeactivateProjectCertificates200 = ListCertificatesResponse
export type ListProjectGroupsParams = {
  readonly "limit"?: number
  readonly "after"?: string
  readonly "order"?: "asc" | "desc"
}
export const ListProjectGroupsParams = Schema.Struct({
  "limit": Schema.optionalKey(
    Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(100))
  ),
  "after": Schema.optionalKey(Schema.String),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]))
})
export type ListProjectGroups200 = ProjectGroupListResource
export const ListProjectGroups200 = ProjectGroupListResource
export type AddProjectGroupRequestJson = InviteProjectGroupBody
export const AddProjectGroupRequestJson = InviteProjectGroupBody
export type AddProjectGroup200 = ProjectGroup
export const AddProjectGroup200 = ProjectGroup
export type RemoveProjectGroup200 = ProjectGroupDeletedResource
export const RemoveProjectGroup200 = ProjectGroupDeletedResource
export type ListProjectRateLimitsParams = {
  readonly "limit"?: number
  readonly "after"?: string
  readonly "before"?: string
}
export const ListProjectRateLimitsParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "after": Schema.optionalKey(Schema.String),
  "before": Schema.optionalKey(Schema.String)
})
export type ListProjectRateLimits200 = ProjectRateLimitListResponse
export const ListProjectRateLimits200 = ProjectRateLimitListResponse
export type UpdateProjectRateLimitsRequestJson = ProjectRateLimitUpdateRequest
export const UpdateProjectRateLimitsRequestJson = ProjectRateLimitUpdateRequest
export type UpdateProjectRateLimits200 = ProjectRateLimit
export const UpdateProjectRateLimits200 = ProjectRateLimit
export type UpdateProjectRateLimits400 = ErrorResponse
export const UpdateProjectRateLimits400 = ErrorResponse
export type ListProjectServiceAccountsParams = { readonly "limit"?: number; readonly "after"?: string }
export const ListProjectServiceAccountsParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "after": Schema.optionalKey(Schema.String)
})
export type ListProjectServiceAccounts200 = ProjectServiceAccountListResponse
export const ListProjectServiceAccounts200 = ProjectServiceAccountListResponse
export type ListProjectServiceAccounts400 = ErrorResponse
export const ListProjectServiceAccounts400 = ErrorResponse
export type CreateProjectServiceAccountRequestJson = ProjectServiceAccountCreateRequest
export const CreateProjectServiceAccountRequestJson = ProjectServiceAccountCreateRequest
export type CreateProjectServiceAccount200 = ProjectServiceAccountCreateResponse
export const CreateProjectServiceAccount200 = ProjectServiceAccountCreateResponse
export type CreateProjectServiceAccount400 = ErrorResponse
export const CreateProjectServiceAccount400 = ErrorResponse
export type RetrieveProjectServiceAccount200 = ProjectServiceAccount
export const RetrieveProjectServiceAccount200 = ProjectServiceAccount
export type DeleteProjectServiceAccount200 = ProjectServiceAccountDeleteResponse
export const DeleteProjectServiceAccount200 = ProjectServiceAccountDeleteResponse
export type ListProjectUsersParams = { readonly "limit"?: number; readonly "after"?: string }
export const ListProjectUsersParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "after": Schema.optionalKey(Schema.String)
})
export type ListProjectUsers200 = ProjectUserListResponse
export const ListProjectUsers200 = ProjectUserListResponse
export type ListProjectUsers400 = ErrorResponse
export const ListProjectUsers400 = ErrorResponse
export type CreateProjectUserRequestJson = ProjectUserCreateRequest
export const CreateProjectUserRequestJson = ProjectUserCreateRequest
export type CreateProjectUser200 = ProjectUser
export const CreateProjectUser200 = ProjectUser
export type CreateProjectUser400 = ErrorResponse
export const CreateProjectUser400 = ErrorResponse
export type RetrieveProjectUser200 = ProjectUser
export const RetrieveProjectUser200 = ProjectUser
export type ModifyProjectUserRequestJson = ProjectUserUpdateRequest
export const ModifyProjectUserRequestJson = ProjectUserUpdateRequest
export type ModifyProjectUser200 = ProjectUser
export const ModifyProjectUser200 = ProjectUser
export type ModifyProjectUser400 = ErrorResponse
export const ModifyProjectUser400 = ErrorResponse
export type DeleteProjectUser200 = ProjectUserDeleteResponse
export const DeleteProjectUser200 = ProjectUserDeleteResponse
export type DeleteProjectUser400 = ErrorResponse
export const DeleteProjectUser400 = ErrorResponse
export type ListRolesParams = {
  readonly "limit"?: number
  readonly "after"?: string
  readonly "order"?: "asc" | "desc"
}
export const ListRolesParams = Schema.Struct({
  "limit": Schema.optionalKey(
    Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1000))
  ),
  "after": Schema.optionalKey(Schema.String),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]))
})
export type ListRoles200 = PublicRoleListResource
export const ListRoles200 = PublicRoleListResource
export type CreateRoleRequestJson = PublicCreateOrganizationRoleBody
export const CreateRoleRequestJson = PublicCreateOrganizationRoleBody
export type CreateRole200 = Role
export const CreateRole200 = Role
export type UpdateRoleRequestJson = PublicUpdateOrganizationRoleBody
export const UpdateRoleRequestJson = PublicUpdateOrganizationRoleBody
export type UpdateRole200 = Role
export const UpdateRole200 = Role
export type DeleteRole200 = RoleDeletedResource
export const DeleteRole200 = RoleDeletedResource
export type UsageAudioSpeechesParams = {
  readonly "start_time": number
  readonly "end_time"?: number
  readonly "bucket_width"?: "1m" | "1h" | "1d"
  readonly "project_ids"?: ReadonlyArray<string>
  readonly "user_ids"?: ReadonlyArray<string>
  readonly "api_key_ids"?: ReadonlyArray<string>
  readonly "models"?: ReadonlyArray<string>
  readonly "group_by"?: ReadonlyArray<"project_id" | "user_id" | "api_key_id" | "model">
  readonly "limit"?: number
  readonly "page"?: string
}
export const UsageAudioSpeechesParams = Schema.Struct({
  "start_time": Schema.Number.check(Schema.isInt()),
  "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "bucket_width": Schema.optionalKey(Schema.Literals(["1m", "1h", "1d"])),
  "project_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "user_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "api_key_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "models": Schema.optionalKey(Schema.Array(Schema.String)),
  "group_by": Schema.optionalKey(Schema.Array(Schema.Literals(["project_id", "user_id", "api_key_id", "model"]))),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "page": Schema.optionalKey(Schema.String)
})
export type UsageAudioSpeeches200 = UsageResponse
export const UsageAudioSpeeches200 = UsageResponse
export type UsageAudioTranscriptionsParams = {
  readonly "start_time": number
  readonly "end_time"?: number
  readonly "bucket_width"?: "1m" | "1h" | "1d"
  readonly "project_ids"?: ReadonlyArray<string>
  readonly "user_ids"?: ReadonlyArray<string>
  readonly "api_key_ids"?: ReadonlyArray<string>
  readonly "models"?: ReadonlyArray<string>
  readonly "group_by"?: ReadonlyArray<"project_id" | "user_id" | "api_key_id" | "model">
  readonly "limit"?: number
  readonly "page"?: string
}
export const UsageAudioTranscriptionsParams = Schema.Struct({
  "start_time": Schema.Number.check(Schema.isInt()),
  "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "bucket_width": Schema.optionalKey(Schema.Literals(["1m", "1h", "1d"])),
  "project_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "user_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "api_key_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "models": Schema.optionalKey(Schema.Array(Schema.String)),
  "group_by": Schema.optionalKey(Schema.Array(Schema.Literals(["project_id", "user_id", "api_key_id", "model"]))),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "page": Schema.optionalKey(Schema.String)
})
export type UsageAudioTranscriptions200 = UsageResponse
export const UsageAudioTranscriptions200 = UsageResponse
export type UsageCodeInterpreterSessionsParams = {
  readonly "start_time": number
  readonly "end_time"?: number
  readonly "bucket_width"?: "1m" | "1h" | "1d"
  readonly "project_ids"?: ReadonlyArray<string>
  readonly "group_by"?: ReadonlyArray<"project_id">
  readonly "limit"?: number
  readonly "page"?: string
}
export const UsageCodeInterpreterSessionsParams = Schema.Struct({
  "start_time": Schema.Number.check(Schema.isInt()),
  "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "bucket_width": Schema.optionalKey(Schema.Literals(["1m", "1h", "1d"])),
  "project_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "group_by": Schema.optionalKey(Schema.Array(Schema.Literal("project_id"))),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "page": Schema.optionalKey(Schema.String)
})
export type UsageCodeInterpreterSessions200 = UsageResponse
export const UsageCodeInterpreterSessions200 = UsageResponse
export type UsageCompletionsParams = {
  readonly "start_time": number
  readonly "end_time"?: number
  readonly "bucket_width"?: "1m" | "1h" | "1d"
  readonly "project_ids"?: ReadonlyArray<string>
  readonly "user_ids"?: ReadonlyArray<string>
  readonly "api_key_ids"?: ReadonlyArray<string>
  readonly "models"?: ReadonlyArray<string>
  readonly "batch"?: boolean
  readonly "group_by"?: ReadonlyArray<"project_id" | "user_id" | "api_key_id" | "model" | "batch" | "service_tier">
  readonly "limit"?: number
  readonly "page"?: string
}
export const UsageCompletionsParams = Schema.Struct({
  "start_time": Schema.Number.check(Schema.isInt()),
  "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "bucket_width": Schema.optionalKey(Schema.Literals(["1m", "1h", "1d"])),
  "project_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "user_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "api_key_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "models": Schema.optionalKey(Schema.Array(Schema.String)),
  "batch": Schema.optionalKey(Schema.Boolean),
  "group_by": Schema.optionalKey(
    Schema.Array(Schema.Literals(["project_id", "user_id", "api_key_id", "model", "batch", "service_tier"]))
  ),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "page": Schema.optionalKey(Schema.String)
})
export type UsageCompletions200 = UsageResponse
export const UsageCompletions200 = UsageResponse
export type UsageEmbeddingsParams = {
  readonly "start_time": number
  readonly "end_time"?: number
  readonly "bucket_width"?: "1m" | "1h" | "1d"
  readonly "project_ids"?: ReadonlyArray<string>
  readonly "user_ids"?: ReadonlyArray<string>
  readonly "api_key_ids"?: ReadonlyArray<string>
  readonly "models"?: ReadonlyArray<string>
  readonly "group_by"?: ReadonlyArray<"project_id" | "user_id" | "api_key_id" | "model">
  readonly "limit"?: number
  readonly "page"?: string
}
export const UsageEmbeddingsParams = Schema.Struct({
  "start_time": Schema.Number.check(Schema.isInt()),
  "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "bucket_width": Schema.optionalKey(Schema.Literals(["1m", "1h", "1d"])),
  "project_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "user_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "api_key_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "models": Schema.optionalKey(Schema.Array(Schema.String)),
  "group_by": Schema.optionalKey(Schema.Array(Schema.Literals(["project_id", "user_id", "api_key_id", "model"]))),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "page": Schema.optionalKey(Schema.String)
})
export type UsageEmbeddings200 = UsageResponse
export const UsageEmbeddings200 = UsageResponse
export type UsageImagesParams = {
  readonly "start_time": number
  readonly "end_time"?: number
  readonly "bucket_width"?: "1m" | "1h" | "1d"
  readonly "sources"?: ReadonlyArray<"image.generation" | "image.edit" | "image.variation">
  readonly "sizes"?: ReadonlyArray<"256x256" | "512x512" | "1024x1024" | "1792x1792" | "1024x1792">
  readonly "project_ids"?: ReadonlyArray<string>
  readonly "user_ids"?: ReadonlyArray<string>
  readonly "api_key_ids"?: ReadonlyArray<string>
  readonly "models"?: ReadonlyArray<string>
  readonly "group_by"?: ReadonlyArray<"project_id" | "user_id" | "api_key_id" | "model" | "size" | "source">
  readonly "limit"?: number
  readonly "page"?: string
}
export const UsageImagesParams = Schema.Struct({
  "start_time": Schema.Number.check(Schema.isInt()),
  "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "bucket_width": Schema.optionalKey(Schema.Literals(["1m", "1h", "1d"])),
  "sources": Schema.optionalKey(Schema.Array(Schema.Literals(["image.generation", "image.edit", "image.variation"]))),
  "sizes": Schema.optionalKey(
    Schema.Array(Schema.Literals(["256x256", "512x512", "1024x1024", "1792x1792", "1024x1792"]))
  ),
  "project_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "user_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "api_key_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "models": Schema.optionalKey(Schema.Array(Schema.String)),
  "group_by": Schema.optionalKey(
    Schema.Array(Schema.Literals(["project_id", "user_id", "api_key_id", "model", "size", "source"]))
  ),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "page": Schema.optionalKey(Schema.String)
})
export type UsageImages200 = UsageResponse
export const UsageImages200 = UsageResponse
export type UsageModerationsParams = {
  readonly "start_time": number
  readonly "end_time"?: number
  readonly "bucket_width"?: "1m" | "1h" | "1d"
  readonly "project_ids"?: ReadonlyArray<string>
  readonly "user_ids"?: ReadonlyArray<string>
  readonly "api_key_ids"?: ReadonlyArray<string>
  readonly "models"?: ReadonlyArray<string>
  readonly "group_by"?: ReadonlyArray<"project_id" | "user_id" | "api_key_id" | "model">
  readonly "limit"?: number
  readonly "page"?: string
}
export const UsageModerationsParams = Schema.Struct({
  "start_time": Schema.Number.check(Schema.isInt()),
  "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "bucket_width": Schema.optionalKey(Schema.Literals(["1m", "1h", "1d"])),
  "project_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "user_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "api_key_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "models": Schema.optionalKey(Schema.Array(Schema.String)),
  "group_by": Schema.optionalKey(Schema.Array(Schema.Literals(["project_id", "user_id", "api_key_id", "model"]))),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "page": Schema.optionalKey(Schema.String)
})
export type UsageModerations200 = UsageResponse
export const UsageModerations200 = UsageResponse
export type UsageVectorStoresParams = {
  readonly "start_time": number
  readonly "end_time"?: number
  readonly "bucket_width"?: "1m" | "1h" | "1d"
  readonly "project_ids"?: ReadonlyArray<string>
  readonly "group_by"?: ReadonlyArray<"project_id">
  readonly "limit"?: number
  readonly "page"?: string
}
export const UsageVectorStoresParams = Schema.Struct({
  "start_time": Schema.Number.check(Schema.isInt()),
  "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "bucket_width": Schema.optionalKey(Schema.Literals(["1m", "1h", "1d"])),
  "project_ids": Schema.optionalKey(Schema.Array(Schema.String)),
  "group_by": Schema.optionalKey(Schema.Array(Schema.Literal("project_id"))),
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "page": Schema.optionalKey(Schema.String)
})
export type UsageVectorStores200 = UsageResponse
export const UsageVectorStores200 = UsageResponse
export type ListUsersParams = {
  readonly "limit"?: number
  readonly "after"?: string
  readonly "emails"?: ReadonlyArray<string>
}
export const ListUsersParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "after": Schema.optionalKey(Schema.String),
  "emails": Schema.optionalKey(Schema.Array(Schema.String))
})
export type ListUsers200 = UserListResponse
export const ListUsers200 = UserListResponse
export type RetrieveUser200 = User
export const RetrieveUser200 = User
export type ModifyUserRequestJson = UserRoleUpdateRequest
export const ModifyUserRequestJson = UserRoleUpdateRequest
export type ModifyUser200 = User
export const ModifyUser200 = User
export type DeleteUser200 = UserDeleteResponse
export const DeleteUser200 = UserDeleteResponse
export type ListUserRoleAssignmentsParams = {
  readonly "limit"?: number
  readonly "after"?: string
  readonly "order"?: "asc" | "desc"
}
export const ListUserRoleAssignmentsParams = Schema.Struct({
  "limit": Schema.optionalKey(
    Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1000))
  ),
  "after": Schema.optionalKey(Schema.String),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]))
})
export type ListUserRoleAssignments200 = RoleListResource
export const ListUserRoleAssignments200 = RoleListResource
export type AssignUserRoleRequestJson = PublicAssignOrganizationGroupRoleBody
export const AssignUserRoleRequestJson = PublicAssignOrganizationGroupRoleBody
export type AssignUserRole200 = UserRoleAssignment
export const AssignUserRole200 = UserRoleAssignment
export type UnassignUserRole200 = DeletedRoleAssignmentResource
export const UnassignUserRole200 = DeletedRoleAssignmentResource
export type ListProjectGroupRoleAssignmentsParams = {
  readonly "limit"?: number
  readonly "after"?: string
  readonly "order"?: "asc" | "desc"
}
export const ListProjectGroupRoleAssignmentsParams = Schema.Struct({
  "limit": Schema.optionalKey(
    Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1000))
  ),
  "after": Schema.optionalKey(Schema.String),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]))
})
export type ListProjectGroupRoleAssignments200 = RoleListResource
export const ListProjectGroupRoleAssignments200 = RoleListResource
export type AssignProjectGroupRoleRequestJson = PublicAssignOrganizationGroupRoleBody
export const AssignProjectGroupRoleRequestJson = PublicAssignOrganizationGroupRoleBody
export type AssignProjectGroupRole200 = GroupRoleAssignment
export const AssignProjectGroupRole200 = GroupRoleAssignment
export type UnassignProjectGroupRole200 = DeletedRoleAssignmentResource
export const UnassignProjectGroupRole200 = DeletedRoleAssignmentResource
export type ListProjectRolesParams = {
  readonly "limit"?: number
  readonly "after"?: string
  readonly "order"?: "asc" | "desc"
}
export const ListProjectRolesParams = Schema.Struct({
  "limit": Schema.optionalKey(
    Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1000))
  ),
  "after": Schema.optionalKey(Schema.String),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]))
})
export type ListProjectRoles200 = PublicRoleListResource
export const ListProjectRoles200 = PublicRoleListResource
export type CreateProjectRoleRequestJson = PublicCreateOrganizationRoleBody
export const CreateProjectRoleRequestJson = PublicCreateOrganizationRoleBody
export type CreateProjectRole200 = Role
export const CreateProjectRole200 = Role
export type UpdateProjectRoleRequestJson = PublicUpdateOrganizationRoleBody
export const UpdateProjectRoleRequestJson = PublicUpdateOrganizationRoleBody
export type UpdateProjectRole200 = Role
export const UpdateProjectRole200 = Role
export type DeleteProjectRole200 = RoleDeletedResource
export const DeleteProjectRole200 = RoleDeletedResource
export type ListProjectUserRoleAssignmentsParams = {
  readonly "limit"?: number
  readonly "after"?: string
  readonly "order"?: "asc" | "desc"
}
export const ListProjectUserRoleAssignmentsParams = Schema.Struct({
  "limit": Schema.optionalKey(
    Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(1000))
  ),
  "after": Schema.optionalKey(Schema.String),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]))
})
export type ListProjectUserRoleAssignments200 = RoleListResource
export const ListProjectUserRoleAssignments200 = RoleListResource
export type AssignProjectUserRoleRequestJson = PublicAssignOrganizationGroupRoleBody
export const AssignProjectUserRoleRequestJson = PublicAssignOrganizationGroupRoleBody
export type AssignProjectUserRole200 = UserRoleAssignment
export const AssignProjectUserRole200 = UserRoleAssignment
export type UnassignProjectUserRole200 = DeletedRoleAssignmentResource
export const UnassignProjectUserRole200 = DeletedRoleAssignmentResource
export type CreateRealtimeCallRequestFormData = RealtimeCallCreateRequest
export const CreateRealtimeCallRequestFormData = RealtimeCallCreateRequest
export type AcceptRealtimeCallRequestJson = RealtimeSessionCreateRequestGA
export const AcceptRealtimeCallRequestJson = RealtimeSessionCreateRequestGA
export type ReferRealtimeCallRequestJson = RealtimeCallReferRequest
export const ReferRealtimeCallRequestJson = RealtimeCallReferRequest
export type RejectRealtimeCallRequestJson = RealtimeCallRejectRequest
export const RejectRealtimeCallRequestJson = RealtimeCallRejectRequest
export type CreateRealtimeClientSecretRequestJson = RealtimeCreateClientSecretRequest
export const CreateRealtimeClientSecretRequestJson = RealtimeCreateClientSecretRequest
export type CreateRealtimeClientSecret200 = RealtimeCreateClientSecretResponse
export const CreateRealtimeClientSecret200 = RealtimeCreateClientSecretResponse
export type CreateRealtimeSessionRequestJson = RealtimeSessionCreateRequest
export const CreateRealtimeSessionRequestJson = RealtimeSessionCreateRequest
export type CreateRealtimeSession200 = RealtimeSessionCreateResponse
export const CreateRealtimeSession200 = RealtimeSessionCreateResponse
export type CreateRealtimeTranscriptionSessionRequestJson = RealtimeTranscriptionSessionCreateRequest
export const CreateRealtimeTranscriptionSessionRequestJson = RealtimeTranscriptionSessionCreateRequest
export type CreateRealtimeTranscriptionSession200 = RealtimeTranscriptionSessionCreateResponse
export const CreateRealtimeTranscriptionSession200 = RealtimeTranscriptionSessionCreateResponse
export type CreateResponseRequestJson = CreateResponse
export const CreateResponseRequestJson = CreateResponse
export type CreateResponse200 = Response
export const CreateResponse200 = Response
export type CreateResponse200Sse = ResponseStreamEvent
export const CreateResponse200Sse = ResponseStreamEvent
export type GetResponseParams = {
  readonly "include"?: ReadonlyArray<IncludeEnum>
  readonly "stream"?: boolean
  readonly "starting_after"?: number
  readonly "include_obfuscation"?: boolean
}
export const GetResponseParams = Schema.Struct({
  "include": Schema.optionalKey(Schema.Array(IncludeEnum)),
  "stream": Schema.optionalKey(Schema.Boolean),
  "starting_after": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "include_obfuscation": Schema.optionalKey(Schema.Boolean)
})
export type GetResponse200 = Response
export const GetResponse200 = Response
export type DeleteResponse404 = Error
export const DeleteResponse404 = Error
export type CancelResponse200 = Response
export const CancelResponse200 = Response
export type CancelResponse404 = Error
export const CancelResponse404 = Error
export type ListInputItemsParams = {
  readonly "limit"?: number
  readonly "order"?: "asc" | "desc"
  readonly "after"?: string
  readonly "include"?: ReadonlyArray<IncludeEnum>
}
export const ListInputItemsParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])),
  "after": Schema.optionalKey(Schema.String),
  "include": Schema.optionalKey(Schema.Array(IncludeEnum))
})
export type ListInputItems200 = ResponseItemList
export const ListInputItems200 = ResponseItemList
export type CreateThreadRequestJson = CreateThreadRequest
export const CreateThreadRequestJson = CreateThreadRequest
export type CreateThread200 = ThreadObject
export const CreateThread200 = ThreadObject
export type CreateThreadAndRunRequestJson = CreateThreadAndRunRequest
export const CreateThreadAndRunRequestJson = CreateThreadAndRunRequest
export type CreateThreadAndRun200 = RunObject
export const CreateThreadAndRun200 = RunObject
export type GetThread200 = ThreadObject
export const GetThread200 = ThreadObject
export type ModifyThreadRequestJson = ModifyThreadRequest
export const ModifyThreadRequestJson = ModifyThreadRequest
export type ModifyThread200 = ThreadObject
export const ModifyThread200 = ThreadObject
export type DeleteThread200 = DeleteThreadResponse
export const DeleteThread200 = DeleteThreadResponse
export type ListMessagesParams = {
  readonly "limit"?: number
  readonly "order"?: "asc" | "desc"
  readonly "after"?: string
  readonly "before"?: string
  readonly "run_id"?: string
}
export const ListMessagesParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])),
  "after": Schema.optionalKey(Schema.String),
  "before": Schema.optionalKey(Schema.String),
  "run_id": Schema.optionalKey(Schema.String)
})
export type ListMessages200 = ListMessagesResponse
export const ListMessages200 = ListMessagesResponse
export type CreateMessageRequestJson = CreateMessageRequest
export const CreateMessageRequestJson = CreateMessageRequest
export type CreateMessage200 = MessageObject
export const CreateMessage200 = MessageObject
export type GetMessage200 = MessageObject
export const GetMessage200 = MessageObject
export type ModifyMessageRequestJson = ModifyMessageRequest
export const ModifyMessageRequestJson = ModifyMessageRequest
export type ModifyMessage200 = MessageObject
export const ModifyMessage200 = MessageObject
export type DeleteMessage200 = DeleteMessageResponse
export const DeleteMessage200 = DeleteMessageResponse
export type ListRunsParams = {
  readonly "limit"?: number
  readonly "order"?: "asc" | "desc"
  readonly "after"?: string
  readonly "before"?: string
}
export const ListRunsParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])),
  "after": Schema.optionalKey(Schema.String),
  "before": Schema.optionalKey(Schema.String)
})
export type ListRuns200 = ListRunsResponse
export const ListRuns200 = ListRunsResponse
export type CreateRunParams = {
  readonly "include[]"?: ReadonlyArray<"step_details.tool_calls[*].file_search.results[*].content">
}
export const CreateRunParams = Schema.Struct({
  "include[]": Schema.optionalKey(
    Schema.Array(Schema.Literal("step_details.tool_calls[*].file_search.results[*].content"))
  )
})
export type CreateRunRequestJson = CreateRunRequest
export const CreateRunRequestJson = CreateRunRequest
export type CreateRun200 = RunObject
export const CreateRun200 = RunObject
export type GetRun200 = RunObject
export const GetRun200 = RunObject
export type ModifyRunRequestJson = ModifyRunRequest
export const ModifyRunRequestJson = ModifyRunRequest
export type ModifyRun200 = RunObject
export const ModifyRun200 = RunObject
export type CancelRun200 = RunObject
export const CancelRun200 = RunObject
export type ListRunStepsParams = {
  readonly "limit"?: number
  readonly "order"?: "asc" | "desc"
  readonly "after"?: string
  readonly "before"?: string
  readonly "include[]"?: ReadonlyArray<"step_details.tool_calls[*].file_search.results[*].content">
}
export const ListRunStepsParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])),
  "after": Schema.optionalKey(Schema.String),
  "before": Schema.optionalKey(Schema.String),
  "include[]": Schema.optionalKey(
    Schema.Array(Schema.Literal("step_details.tool_calls[*].file_search.results[*].content"))
  )
})
export type ListRunSteps200 = ListRunStepsResponse
export const ListRunSteps200 = ListRunStepsResponse
export type GetRunStepParams = {
  readonly "include[]"?: ReadonlyArray<"step_details.tool_calls[*].file_search.results[*].content">
}
export const GetRunStepParams = Schema.Struct({
  "include[]": Schema.optionalKey(
    Schema.Array(Schema.Literal("step_details.tool_calls[*].file_search.results[*].content"))
  )
})
export type GetRunStep200 = RunStepObject
export const GetRunStep200 = RunStepObject
export type SubmitToolOuputsToRunRequestJson = SubmitToolOutputsRunRequest
export const SubmitToolOuputsToRunRequestJson = SubmitToolOutputsRunRequest
export type SubmitToolOuputsToRun200 = RunObject
export const SubmitToolOuputsToRun200 = RunObject
export type CreateUploadRequestJson = CreateUploadRequest
export const CreateUploadRequestJson = CreateUploadRequest
export type CreateUpload200 = Upload
export const CreateUpload200 = Upload
export type CancelUpload200 = Upload
export const CancelUpload200 = Upload
export type CompleteUploadRequestJson = CompleteUploadRequest
export const CompleteUploadRequestJson = CompleteUploadRequest
export type CompleteUpload200 = Upload
export const CompleteUpload200 = Upload
export type AddUploadPartRequestFormData = AddUploadPartRequest
export const AddUploadPartRequestFormData = AddUploadPartRequest
export type AddUploadPart200 = UploadPart
export const AddUploadPart200 = UploadPart
export type ListVectorStoresParams = {
  readonly "limit"?: number
  readonly "order"?: "asc" | "desc"
  readonly "after"?: string
  readonly "before"?: string
}
export const ListVectorStoresParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])),
  "after": Schema.optionalKey(Schema.String),
  "before": Schema.optionalKey(Schema.String)
})
export type ListVectorStores200 = ListVectorStoresResponse
export const ListVectorStores200 = ListVectorStoresResponse
export type CreateVectorStoreRequestJson = CreateVectorStoreRequest
export const CreateVectorStoreRequestJson = CreateVectorStoreRequest
export type CreateVectorStore200 = VectorStoreObject
export const CreateVectorStore200 = VectorStoreObject
export type GetVectorStore200 = VectorStoreObject
export const GetVectorStore200 = VectorStoreObject
export type ModifyVectorStoreRequestJson = UpdateVectorStoreRequest
export const ModifyVectorStoreRequestJson = UpdateVectorStoreRequest
export type ModifyVectorStore200 = VectorStoreObject
export const ModifyVectorStore200 = VectorStoreObject
export type DeleteVectorStore200 = DeleteVectorStoreResponse
export const DeleteVectorStore200 = DeleteVectorStoreResponse
export type CreateVectorStoreFileBatchRequestJson = CreateVectorStoreFileBatchRequest
export const CreateVectorStoreFileBatchRequestJson = CreateVectorStoreFileBatchRequest
export type CreateVectorStoreFileBatch200 = VectorStoreFileBatchObject
export const CreateVectorStoreFileBatch200 = VectorStoreFileBatchObject
export type GetVectorStoreFileBatch200 = VectorStoreFileBatchObject
export const GetVectorStoreFileBatch200 = VectorStoreFileBatchObject
export type CancelVectorStoreFileBatch200 = VectorStoreFileBatchObject
export const CancelVectorStoreFileBatch200 = VectorStoreFileBatchObject
export type ListFilesInVectorStoreBatchParams = {
  readonly "limit"?: number
  readonly "order"?: "asc" | "desc"
  readonly "after"?: string
  readonly "before"?: string
  readonly "filter"?: "in_progress" | "completed" | "failed" | "cancelled"
}
export const ListFilesInVectorStoreBatchParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])),
  "after": Schema.optionalKey(Schema.String),
  "before": Schema.optionalKey(Schema.String),
  "filter": Schema.optionalKey(Schema.Literals(["in_progress", "completed", "failed", "cancelled"]))
})
export type ListFilesInVectorStoreBatch200 = ListVectorStoreFilesResponse
export const ListFilesInVectorStoreBatch200 = ListVectorStoreFilesResponse
export type ListVectorStoreFilesParams = {
  readonly "limit"?: number
  readonly "order"?: "asc" | "desc"
  readonly "after"?: string
  readonly "before"?: string
  readonly "filter"?: "in_progress" | "completed" | "failed" | "cancelled"
}
export const ListVectorStoreFilesParams = Schema.Struct({
  "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())),
  "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])),
  "after": Schema.optionalKey(Schema.String),
  "before": Schema.optionalKey(Schema.String),
  "filter": Schema.optionalKey(Schema.Literals(["in_progress", "completed", "failed", "cancelled"]))
})
export type ListVectorStoreFiles200 = ListVectorStoreFilesResponse
export const ListVectorStoreFiles200 = ListVectorStoreFilesResponse
export type CreateVectorStoreFileRequestJson = CreateVectorStoreFileRequest
export const CreateVectorStoreFileRequestJson = CreateVectorStoreFileRequest
export type CreateVectorStoreFile200 = VectorStoreFileObject
export const CreateVectorStoreFile200 = VectorStoreFileObject
export type GetVectorStoreFile200 = VectorStoreFileObject
export const GetVectorStoreFile200 = VectorStoreFileObject
export type UpdateVectorStoreFileAttributesRequestJson = UpdateVectorStoreFileAttributesRequest
export const UpdateVectorStoreFileAttributesRequestJson = UpdateVectorStoreFileAttributesRequest
export type UpdateVectorStoreFileAttributes200 = VectorStoreFileObject
export const UpdateVectorStoreFileAttributes200 = VectorStoreFileObject
export type DeleteVectorStoreFile200 = DeleteVectorStoreFileResponse
export const DeleteVectorStoreFile200 = DeleteVectorStoreFileResponse
export type RetrieveVectorStoreFileContent200 = VectorStoreFileContentResponse
export const RetrieveVectorStoreFileContent200 = VectorStoreFileContentResponse
export type SearchVectorStoreRequestJson = VectorStoreSearchRequest
export const SearchVectorStoreRequestJson = VectorStoreSearchRequest
export type SearchVectorStore200 = VectorStoreSearchResultsPage
export const SearchVectorStore200 = VectorStoreSearchResultsPage
export type CreateConversationRequestJson = CreateConversationBody
export const CreateConversationRequestJson = CreateConversationBody
export type CreateConversation200 = ConversationResource
export const CreateConversation200 = ConversationResource
export type GetConversation200 = ConversationResource
export const GetConversation200 = ConversationResource
export type UpdateConversationRequestJson = UpdateConversationBody
export const UpdateConversationRequestJson = UpdateConversationBody
export type UpdateConversation200 = ConversationResource
export const UpdateConversation200 = ConversationResource
export type DeleteConversation200 = DeletedConversationResource
export const DeleteConversation200 = DeletedConversationResource
export type ListVideosParams = { readonly "limit"?: number; readonly "order"?: OrderEnum; readonly "after"?: string }
export const ListVideosParams = Schema.Struct({
  "limit": Schema.optionalKey(
    Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(100))
  ),
  "order": Schema.optionalKey(OrderEnum),
  "after": Schema.optionalKey(
    Schema.String.annotate({ "description": "Identifier for the last item from the previous pagination request" })
  )
})
export type ListVideos200 = VideoListResource
export const ListVideos200 = VideoListResource
export type CreateVideoRequestJson = CreateVideoBody
export const CreateVideoRequestJson = CreateVideoBody
export type CreateVideoRequestFormData = CreateVideoBody
export const CreateVideoRequestFormData = CreateVideoBody
export type CreateVideo200 = VideoResource
export const CreateVideo200 = VideoResource
export type GetVideo200 = VideoResource
export const GetVideo200 = VideoResource
export type DeleteVideo200 = DeletedVideoResource
export const DeleteVideo200 = DeletedVideoResource
export type RetrieveVideoContentParams = { readonly "variant"?: VideoContentVariant }
export const RetrieveVideoContentParams = Schema.Struct({ "variant": Schema.optionalKey(VideoContentVariant) })
export type RetrieveVideoContent200 = string
export const RetrieveVideoContent200 = Schema.String
export type CreateVideoRemixRequestJson = CreateVideoRemixBody
export const CreateVideoRemixRequestJson = CreateVideoRemixBody
export type CreateVideoRemixRequestFormData = CreateVideoRemixBody
export const CreateVideoRemixRequestFormData = CreateVideoRemixBody
export type CreateVideoRemix200 = VideoResource
export const CreateVideoRemix200 = VideoResource
export type GetinputtokencountsRequestJson = TokenCountsBody
export const GetinputtokencountsRequestJson = TokenCountsBody
export type Getinputtokencounts200 = TokenCountsResource
export const Getinputtokencounts200 = TokenCountsResource
export type CompactconversationRequestJson = CompactResponseMethodPublicBody
export const CompactconversationRequestJson = CompactResponseMethodPublicBody
export type Compactconversation200 = CompactResource
export const Compactconversation200 = CompactResource
export type ListSkillsParams = { readonly "limit"?: number; readonly "order"?: OrderEnum; readonly "after"?: string }
export const ListSkillsParams = Schema.Struct({
  "limit": Schema.optionalKey(
    Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(100))
  ),
  "order": Schema.optionalKey(OrderEnum),
  "after": Schema.optionalKey(
    Schema.String.annotate({ "description": "Identifier for the last item from the previous pagination request" })
  )
})
export type ListSkills200 = SkillListResource
export const ListSkills200 = SkillListResource
export type CreateSkillRequestJson = CreateSkillBody
export const CreateSkillRequestJson = CreateSkillBody
export type CreateSkillRequestFormData = CreateSkillBody
export const CreateSkillRequestFormData = CreateSkillBody
export type CreateSkill200 = SkillResource
export const CreateSkill200 = SkillResource
export type GetSkill200 = SkillResource
export const GetSkill200 = SkillResource
export type UpdateSkillDefaultVersionRequestJson = SetDefaultSkillVersionBody
export const UpdateSkillDefaultVersionRequestJson = SetDefaultSkillVersionBody
export type UpdateSkillDefaultVersion200 = SkillResource
export const UpdateSkillDefaultVersion200 = SkillResource
export type DeleteSkill200 = DeletedSkillResource
export const DeleteSkill200 = DeletedSkillResource
export type GetSkillContent200 = string
export const GetSkillContent200 = Schema.String
export type ListSkillVersionsParams = {
  readonly "limit"?: number
  readonly "order"?: OrderEnum
  readonly "after"?: string
}
export const ListSkillVersionsParams = Schema.Struct({
  "limit": Schema.optionalKey(
    Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(100))
  ),
  "order": Schema.optionalKey(OrderEnum),
  "after": Schema.optionalKey(Schema.String)
})
export type ListSkillVersions200 = SkillVersionListResource
export const ListSkillVersions200 = SkillVersionListResource
export type CreateSkillVersionRequestJson = CreateSkillVersionBody
export const CreateSkillVersionRequestJson = CreateSkillVersionBody
export type CreateSkillVersionRequestFormData = CreateSkillVersionBody
export const CreateSkillVersionRequestFormData = CreateSkillVersionBody
export type CreateSkillVersion200 = SkillVersionResource
export const CreateSkillVersion200 = SkillVersionResource
export type GetSkillVersion200 = SkillVersionResource
export const GetSkillVersion200 = SkillVersionResource
export type DeleteSkillVersion200 = DeletedSkillVersionResource
export const DeleteSkillVersion200 = DeletedSkillVersionResource
export type GetSkillVersionContent200 = string
export const GetSkillVersionContent200 = Schema.String
export type CancelChatSessionMethod200 = ChatSessionResource
export const CancelChatSessionMethod200 = ChatSessionResource
export type CreateChatSessionMethodRequestJson = CreateChatSessionBody
export const CreateChatSessionMethodRequestJson = CreateChatSessionBody
export type CreateChatSessionMethod200 = ChatSessionResource
export const CreateChatSessionMethod200 = ChatSessionResource
export type ListThreadItemsMethodParams = {
  readonly "limit"?: number
  readonly "order"?: OrderEnum
  readonly "after"?: string
  readonly "before"?: string
}
export const ListThreadItemsMethodParams = Schema.Struct({
  "limit": Schema.optionalKey(
    Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(100))
  ),
  "order": Schema.optionalKey(OrderEnum),
  "after": Schema.optionalKey(
    Schema.String.annotate({
      "description": "List items created after this thread item ID. Defaults to null for the first page."
    })
  ),
  "before": Schema.optionalKey(
    Schema.String.annotate({
      "description": "List items created before this thread item ID. Defaults to null for the newest results."
    })
  )
})
export type ListThreadItemsMethod200 = ThreadItemListResource
export const ListThreadItemsMethod200 = ThreadItemListResource
export type GetThreadMethod200 = ThreadResource
export const GetThreadMethod200 = ThreadResource
export type DeleteThreadMethod200 = DeletedThreadResource
export const DeleteThreadMethod200 = DeletedThreadResource
export type ListThreadsMethodParams = {
  readonly "limit"?: number
  readonly "order"?: OrderEnum
  readonly "after"?: string
  readonly "before"?: string
  readonly "user"?: string
}
export const ListThreadsMethodParams = Schema.Struct({
  "limit": Schema.optionalKey(
    Schema.Number.check(Schema.isInt()).check(Schema.isGreaterThanOrEqualTo(0)).check(Schema.isLessThanOrEqualTo(100))
  ),
  "order": Schema.optionalKey(OrderEnum),
  "after": Schema.optionalKey(
    Schema.String.annotate({
      "description": "List items created after this thread item ID. Defaults to null for the first page."
    })
  ),
  "before": Schema.optionalKey(
    Schema.String.annotate({
      "description": "List items created before this thread item ID. Defaults to null for the newest results."
    })
  ),
  "user": Schema.optionalKey(
    Schema.String.annotate({
      "description": "Filter threads that belong to this user identifier. Defaults to null to return all users."
    }).check(Schema.isMinLength(1)).check(Schema.isMaxLength(512))
  )
})
export type ListThreadsMethod200 = ThreadListResource
export const ListThreadsMethod200 = ThreadListResource

export interface OperationConfig {
  /**
   * Whether or not the response should be included in the value returned from
   * an operation.
   *
   * If set to `true`, a tuple of `[A, HttpClientResponse]` will be returned,
   * where `A` is the success type of the operation.
   *
   * If set to `false`, only the success type of the operation will be returned.
   */
  readonly includeResponse?: boolean | undefined
}

/**
 * A utility type which optionally includes the response in the return result
 * of an operation based upon the value of the `includeResponse` configuration
 * option.
 */
export type WithOptionalResponse<A, Config extends OperationConfig> = Config extends {
  readonly includeResponse: true
} ? [A, HttpClientResponse.HttpClientResponse] :
  A

export const make = (
  httpClient: HttpClient.HttpClient,
  options: {
    readonly transformClient?: ((client: HttpClient.HttpClient) => Effect.Effect<HttpClient.HttpClient>) | undefined
  } = {}
): OpenAiClient => {
  const unexpectedStatus = (response: HttpClientResponse.HttpClientResponse) =>
    Effect.flatMap(
      Effect.orElseSucceed(response.json, () => "Unexpected status code"),
      (description) =>
        Effect.fail(
          new HttpClientError.HttpClientError({
            reason: new HttpClientError.StatusCodeError({
              request: response.request,
              response,
              description: typeof description === "string" ? description : JSON.stringify(description)
            })
          })
        )
    )
  const withResponse = <Config extends OperationConfig>(config: Config | undefined) =>
  (
    f: (response: HttpClientResponse.HttpClientResponse) => Effect.Effect<any, any>
  ): (request: HttpClientRequest.HttpClientRequest) => Effect.Effect<any, any> => {
    const withOptionalResponse = (
      config?.includeResponse
        ? (response: HttpClientResponse.HttpClientResponse) => Effect.map(f(response), (a) => [a, response])
        : (response: HttpClientResponse.HttpClientResponse) => f(response)
    ) as any
    return options?.transformClient
      ? (request) =>
        Effect.flatMap(
          Effect.flatMap(options.transformClient!(httpClient), (client) => client.execute(request)),
          withOptionalResponse
        )
      : (request) => Effect.flatMap(httpClient.execute(request), withOptionalResponse)
  }
  const sseRequest = <
    Type,
    DecodingServices
  >(
    schema: Schema.Decoder<Type, DecodingServices>
  ) =>
  (
    request: HttpClientRequest.HttpClientRequest
  ): Stream.Stream<
    { readonly event: string; readonly id: string | undefined; readonly data: Type },
    HttpClientError.HttpClientError | SchemaError | Sse.Retry,
    DecodingServices
  > =>
    HttpClient.filterStatusOk(httpClient).execute(request).pipe(
      Effect.map((response) => response.stream),
      Stream.unwrap,
      Stream.decodeText(),
      Stream.pipeThroughChannel(Sse.decodeDataSchema(schema))
    )
  const binaryRequest = (
    request: HttpClientRequest.HttpClientRequest
  ): Stream.Stream<Uint8Array, HttpClientError.HttpClientError> =>
    HttpClient.filterStatusOk(httpClient).execute(request).pipe(
      Effect.map((response) => response.stream),
      Stream.unwrap
    )
  const decodeSuccess =
    <Schema extends Schema.Top>(schema: Schema) => (response: HttpClientResponse.HttpClientResponse) =>
      HttpClientResponse.schemaBodyJson(schema)(response)
  const decodeError =
    <const Tag extends string, Schema extends Schema.Top>(tag: Tag, schema: Schema) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      Effect.flatMap(
        HttpClientResponse.schemaBodyJson(schema)(response),
        (cause) => Effect.fail(OpenAiClientError(tag, cause, response))
      )
  return {
    httpClient,
    "listAssistants": (options) =>
      HttpClientRequest.get(`/assistants`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any,
          "before": options?.params?.["before"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListAssistants200),
          orElse: unexpectedStatus
        }))
      ),
    "createAssistant": (options) =>
      HttpClientRequest.post(`/assistants`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateAssistant200),
          orElse: unexpectedStatus
        }))
      ),
    "getAssistant": (assistantId, options) =>
      HttpClientRequest.get(`/assistants/${assistantId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetAssistant200),
          orElse: unexpectedStatus
        }))
      ),
    "modifyAssistant": (assistantId, options) =>
      HttpClientRequest.post(`/assistants/${assistantId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ModifyAssistant200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteAssistant": (assistantId, options) =>
      HttpClientRequest.delete(`/assistants/${assistantId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteAssistant200),
          orElse: unexpectedStatus
        }))
      ),
    "createSpeech": (options) =>
      HttpClientRequest.post(`/audio/speech`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          orElse: unexpectedStatus
        }))
      ),
    "createSpeechSse": (options) =>
      HttpClientRequest.post(`/audio/speech`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        sseRequest(CreateSpeech200Sse)
      ),
    "createSpeechStream": (options) =>
      HttpClientRequest.post(`/audio/speech`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        binaryRequest
      ),
    "createTranscription": (options) =>
      HttpClientRequest.post(`/audio/transcriptions`).pipe(
        HttpClientRequest.bodyFormData(options.payload as any),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateTranscription200),
          orElse: unexpectedStatus
        }))
      ),
    "createTranscriptionSse": (options) =>
      HttpClientRequest.post(`/audio/transcriptions`).pipe(
        HttpClientRequest.bodyFormData(options.payload as any),
        sseRequest(CreateTranscription200Sse)
      ),
    "createTranslation": (options) =>
      HttpClientRequest.post(`/audio/translations`).pipe(
        HttpClientRequest.bodyFormData(options.payload as any),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateTranslation200),
          orElse: unexpectedStatus
        }))
      ),
    "listVoiceConsents": (options) =>
      HttpClientRequest.get(`/audio/voice_consents`).pipe(
        HttpClientRequest.setUrlParams({
          "after": options?.params?.["after"] as any,
          "limit": options?.params?.["limit"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListVoiceConsents200),
          orElse: unexpectedStatus
        }))
      ),
    "createVoiceConsent": (options) =>
      HttpClientRequest.post(`/audio/voice_consents`).pipe(
        HttpClientRequest.bodyFormData(options.payload as any),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateVoiceConsent200),
          orElse: unexpectedStatus
        }))
      ),
    "getVoiceConsent": (consentId, options) =>
      HttpClientRequest.get(`/audio/voice_consents/${consentId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetVoiceConsent200),
          orElse: unexpectedStatus
        }))
      ),
    "updateVoiceConsent": (consentId, options) =>
      HttpClientRequest.post(`/audio/voice_consents/${consentId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UpdateVoiceConsent200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteVoiceConsent": (consentId, options) =>
      HttpClientRequest.delete(`/audio/voice_consents/${consentId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteVoiceConsent200),
          orElse: unexpectedStatus
        }))
      ),
    "createVoice": (options) =>
      HttpClientRequest.post(`/audio/voices`).pipe(
        HttpClientRequest.bodyFormData(options.payload as any),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateVoice200),
          orElse: unexpectedStatus
        }))
      ),
    "listBatches": (options) =>
      HttpClientRequest.get(`/batches`).pipe(
        HttpClientRequest.setUrlParams({
          "after": options?.params?.["after"] as any,
          "limit": options?.params?.["limit"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListBatches200),
          orElse: unexpectedStatus
        }))
      ),
    "createBatch": (options) =>
      HttpClientRequest.post(`/batches`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateBatch200),
          orElse: unexpectedStatus
        }))
      ),
    "retrieveBatch": (batchId, options) =>
      HttpClientRequest.get(`/batches/${batchId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RetrieveBatch200),
          orElse: unexpectedStatus
        }))
      ),
    "cancelBatch": (batchId, options) =>
      HttpClientRequest.post(`/batches/${batchId}/cancel`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CancelBatch200),
          orElse: unexpectedStatus
        }))
      ),
    "listChatCompletions": (options) =>
      HttpClientRequest.get(`/chat/completions`).pipe(
        HttpClientRequest.setUrlParams({
          "model": options?.params?.["model"] as any,
          "metadata": options?.params?.["metadata"] as any,
          "after": options?.params?.["after"] as any,
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListChatCompletions200),
          orElse: unexpectedStatus
        }))
      ),
    "createChatCompletion": (options) =>
      HttpClientRequest.post(`/chat/completions`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateChatCompletion200),
          orElse: unexpectedStatus
        }))
      ),
    "createChatCompletionSse": (options) =>
      HttpClientRequest.post(`/chat/completions`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        sseRequest(CreateChatCompletion200Sse)
      ),
    "getChatCompletion": (completionId, options) =>
      HttpClientRequest.get(`/chat/completions/${completionId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetChatCompletion200),
          orElse: unexpectedStatus
        }))
      ),
    "updateChatCompletion": (completionId, options) =>
      HttpClientRequest.post(`/chat/completions/${completionId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UpdateChatCompletion200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteChatCompletion": (completionId, options) =>
      HttpClientRequest.delete(`/chat/completions/${completionId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteChatCompletion200),
          orElse: unexpectedStatus
        }))
      ),
    "getChatCompletionMessages": (completionId, options) =>
      HttpClientRequest.get(`/chat/completions/${completionId}/messages`).pipe(
        HttpClientRequest.setUrlParams({
          "after": options?.params?.["after"] as any,
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetChatCompletionMessages200),
          orElse: unexpectedStatus
        }))
      ),
    "createCompletion": (options) =>
      HttpClientRequest.post(`/completions`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateCompletion200),
          orElse: unexpectedStatus
        }))
      ),
    "ListContainers": (options) =>
      HttpClientRequest.get(`/containers`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any,
          "name": options?.params?.["name"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListContainers200),
          orElse: unexpectedStatus
        }))
      ),
    "CreateContainer": (options) =>
      HttpClientRequest.post(`/containers`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateContainer200),
          orElse: unexpectedStatus
        }))
      ),
    "RetrieveContainer": (containerId, options) =>
      HttpClientRequest.get(`/containers/${containerId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RetrieveContainer200),
          orElse: unexpectedStatus
        }))
      ),
    "DeleteContainer": (containerId, options) =>
      HttpClientRequest.delete(`/containers/${containerId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "200": () => Effect.void,
          orElse: unexpectedStatus
        }))
      ),
    "ListContainerFiles": (containerId, options) =>
      HttpClientRequest.get(`/containers/${containerId}/files`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListContainerFiles200),
          orElse: unexpectedStatus
        }))
      ),
    "CreateContainerFile": (containerId, options) =>
      HttpClientRequest.post(`/containers/${containerId}/files`).pipe(
        HttpClientRequest.bodyFormData(options.payload as any),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateContainerFile200),
          orElse: unexpectedStatus
        }))
      ),
    "RetrieveContainerFile": (containerId, fileId, options) =>
      HttpClientRequest.get(`/containers/${containerId}/files/${fileId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RetrieveContainerFile200),
          orElse: unexpectedStatus
        }))
      ),
    "DeleteContainerFile": (containerId, fileId, options) =>
      HttpClientRequest.delete(`/containers/${containerId}/files/${fileId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "200": () => Effect.void,
          orElse: unexpectedStatus
        }))
      ),
    "RetrieveContainerFileContent": (containerId, fileId, options) =>
      HttpClientRequest.get(`/containers/${containerId}/files/${fileId}/content`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "200": () => Effect.void,
          orElse: unexpectedStatus
        }))
      ),
    "listConversationItems": (conversationId, options) =>
      HttpClientRequest.get(`/conversations/${conversationId}/items`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any,
          "include": options?.params?.["include"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListConversationItems200),
          orElse: unexpectedStatus
        }))
      ),
    "createConversationItems": (conversationId, options) =>
      HttpClientRequest.post(`/conversations/${conversationId}/items`).pipe(
        HttpClientRequest.setUrlParams({ "include": options.params?.["include"] as any }),
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateConversationItems200),
          orElse: unexpectedStatus
        }))
      ),
    "getConversationItem": (conversationId, itemId, options) =>
      HttpClientRequest.get(`/conversations/${conversationId}/items/${itemId}`).pipe(
        HttpClientRequest.setUrlParams({ "include": options?.params?.["include"] as any }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetConversationItem200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteConversationItem": (conversationId, itemId, options) =>
      HttpClientRequest.delete(`/conversations/${conversationId}/items/${itemId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteConversationItem200),
          orElse: unexpectedStatus
        }))
      ),
    "createEmbedding": (options) =>
      HttpClientRequest.post(`/embeddings`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateEmbedding200),
          orElse: unexpectedStatus
        }))
      ),
    "listEvals": (options) =>
      HttpClientRequest.get(`/evals`).pipe(
        HttpClientRequest.setUrlParams({
          "after": options?.params?.["after"] as any,
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "order_by": options?.params?.["order_by"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListEvals200),
          orElse: unexpectedStatus
        }))
      ),
    "createEval": (options) =>
      HttpClientRequest.post(`/evals`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateEval201),
          orElse: unexpectedStatus
        }))
      ),
    "getEval": (evalId, options) =>
      HttpClientRequest.get(`/evals/${evalId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetEval200),
          orElse: unexpectedStatus
        }))
      ),
    "updateEval": (evalId, options) =>
      HttpClientRequest.post(`/evals/${evalId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UpdateEval200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteEval": (evalId, options) =>
      HttpClientRequest.delete(`/evals/${evalId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteEval200),
          "404": decodeError("DeleteEval404", DeleteEval404),
          orElse: unexpectedStatus
        }))
      ),
    "getEvalRuns": (evalId, options) =>
      HttpClientRequest.get(`/evals/${evalId}/runs`).pipe(
        HttpClientRequest.setUrlParams({
          "after": options?.params?.["after"] as any,
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "status": options?.params?.["status"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetEvalRuns200),
          orElse: unexpectedStatus
        }))
      ),
    "createEvalRun": (evalId, options) =>
      HttpClientRequest.post(`/evals/${evalId}/runs`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateEvalRun201),
          "400": decodeError("CreateEvalRun400", CreateEvalRun400),
          orElse: unexpectedStatus
        }))
      ),
    "getEvalRun": (evalId, runId, options) =>
      HttpClientRequest.get(`/evals/${evalId}/runs/${runId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetEvalRun200),
          orElse: unexpectedStatus
        }))
      ),
    "cancelEvalRun": (evalId, runId, options) =>
      HttpClientRequest.post(`/evals/${evalId}/runs/${runId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CancelEvalRun200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteEvalRun": (evalId, runId, options) =>
      HttpClientRequest.delete(`/evals/${evalId}/runs/${runId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteEvalRun200),
          "404": decodeError("DeleteEvalRun404", DeleteEvalRun404),
          orElse: unexpectedStatus
        }))
      ),
    "getEvalRunOutputItems": (evalId, runId, options) =>
      HttpClientRequest.get(`/evals/${evalId}/runs/${runId}/output_items`).pipe(
        HttpClientRequest.setUrlParams({
          "after": options?.params?.["after"] as any,
          "limit": options?.params?.["limit"] as any,
          "status": options?.params?.["status"] as any,
          "order": options?.params?.["order"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetEvalRunOutputItems200),
          orElse: unexpectedStatus
        }))
      ),
    "getEvalRunOutputItem": (evalId, runId, outputItemId, options) =>
      HttpClientRequest.get(`/evals/${evalId}/runs/${runId}/output_items/${outputItemId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetEvalRunOutputItem200),
          orElse: unexpectedStatus
        }))
      ),
    "listFiles": (options) =>
      HttpClientRequest.get(`/files`).pipe(
        HttpClientRequest.setUrlParams({
          "purpose": options?.params?.["purpose"] as any,
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListFiles200),
          orElse: unexpectedStatus
        }))
      ),
    "createFile": (options) =>
      HttpClientRequest.post(`/files`).pipe(
        HttpClientRequest.bodyFormData(options.payload as any),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateFile200),
          orElse: unexpectedStatus
        }))
      ),
    "retrieveFile": (fileId, options) =>
      HttpClientRequest.get(`/files/${fileId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RetrieveFile200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteFile": (fileId, options) =>
      HttpClientRequest.delete(`/files/${fileId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteFile200),
          orElse: unexpectedStatus
        }))
      ),
    "downloadFile": (fileId, options) =>
      HttpClientRequest.get(`/files/${fileId}/content`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DownloadFile200),
          orElse: unexpectedStatus
        }))
      ),
    "runGrader": (options) =>
      HttpClientRequest.post(`/fine_tuning/alpha/graders/run`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RunGrader200),
          orElse: unexpectedStatus
        }))
      ),
    "validateGrader": (options) =>
      HttpClientRequest.post(`/fine_tuning/alpha/graders/validate`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ValidateGrader200),
          orElse: unexpectedStatus
        }))
      ),
    "listFineTuningCheckpointPermissions": (fineTunedModelCheckpoint, options) =>
      HttpClientRequest.get(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`).pipe(
        HttpClientRequest.setUrlParams({
          "project_id": options?.params?.["project_id"] as any,
          "after": options?.params?.["after"] as any,
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListFineTuningCheckpointPermissions200),
          orElse: unexpectedStatus
        }))
      ),
    "createFineTuningCheckpointPermission": (fineTunedModelCheckpoint, options) =>
      HttpClientRequest.post(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateFineTuningCheckpointPermission200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteFineTuningCheckpointPermission": (fineTunedModelCheckpoint, permissionId, options) =>
      HttpClientRequest.delete(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions/${permissionId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteFineTuningCheckpointPermission200),
          orElse: unexpectedStatus
        }))
      ),
    "listPaginatedFineTuningJobs": (options) =>
      HttpClientRequest.get(`/fine_tuning/jobs`).pipe(
        HttpClientRequest.setUrlParams({
          "after": options?.params?.["after"] as any,
          "limit": options?.params?.["limit"] as any,
          "metadata": options?.params?.["metadata"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListPaginatedFineTuningJobs200),
          orElse: unexpectedStatus
        }))
      ),
    "createFineTuningJob": (options) =>
      HttpClientRequest.post(`/fine_tuning/jobs`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateFineTuningJob200),
          orElse: unexpectedStatus
        }))
      ),
    "retrieveFineTuningJob": (fineTuningJobId, options) =>
      HttpClientRequest.get(`/fine_tuning/jobs/${fineTuningJobId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RetrieveFineTuningJob200),
          orElse: unexpectedStatus
        }))
      ),
    "cancelFineTuningJob": (fineTuningJobId, options) =>
      HttpClientRequest.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CancelFineTuningJob200),
          orElse: unexpectedStatus
        }))
      ),
    "listFineTuningJobCheckpoints": (fineTuningJobId, options) =>
      HttpClientRequest.get(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`).pipe(
        HttpClientRequest.setUrlParams({
          "after": options?.params?.["after"] as any,
          "limit": options?.params?.["limit"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListFineTuningJobCheckpoints200),
          orElse: unexpectedStatus
        }))
      ),
    "listFineTuningEvents": (fineTuningJobId, options) =>
      HttpClientRequest.get(`/fine_tuning/jobs/${fineTuningJobId}/events`).pipe(
        HttpClientRequest.setUrlParams({
          "after": options?.params?.["after"] as any,
          "limit": options?.params?.["limit"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListFineTuningEvents200),
          orElse: unexpectedStatus
        }))
      ),
    "pauseFineTuningJob": (fineTuningJobId, options) =>
      HttpClientRequest.post(`/fine_tuning/jobs/${fineTuningJobId}/pause`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(PauseFineTuningJob200),
          orElse: unexpectedStatus
        }))
      ),
    "resumeFineTuningJob": (fineTuningJobId, options) =>
      HttpClientRequest.post(`/fine_tuning/jobs/${fineTuningJobId}/resume`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ResumeFineTuningJob200),
          orElse: unexpectedStatus
        }))
      ),
    "createImageEdit": (options) =>
      HttpClientRequest.post(`/images/edits`).pipe(
        HttpClientRequest.bodyFormData(options.payload as any),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateImageEdit200),
          orElse: unexpectedStatus
        }))
      ),
    "createImageEditSse": (options) =>
      HttpClientRequest.post(`/images/edits`).pipe(
        HttpClientRequest.bodyFormData(options.payload as any),
        sseRequest(CreateImageEdit200Sse)
      ),
    "createImage": (options) =>
      HttpClientRequest.post(`/images/generations`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateImage200),
          orElse: unexpectedStatus
        }))
      ),
    "createImageSse": (options) =>
      HttpClientRequest.post(`/images/generations`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        sseRequest(CreateImage200Sse)
      ),
    "createImageVariation": (options) =>
      HttpClientRequest.post(`/images/variations`).pipe(
        HttpClientRequest.bodyFormData(options.payload as any),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateImageVariation200),
          orElse: unexpectedStatus
        }))
      ),
    "listModels": (options) =>
      HttpClientRequest.get(`/models`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListModels200),
          orElse: unexpectedStatus
        }))
      ),
    "retrieveModel": (model, options) =>
      HttpClientRequest.get(`/models/${model}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RetrieveModel200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteModel": (model, options) =>
      HttpClientRequest.delete(`/models/${model}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteModel200),
          orElse: unexpectedStatus
        }))
      ),
    "createModeration": (options) =>
      HttpClientRequest.post(`/moderations`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateModeration200),
          orElse: unexpectedStatus
        }))
      ),
    "adminApiKeysList": (options) =>
      HttpClientRequest.get(`/organization/admin_api_keys`).pipe(
        HttpClientRequest.setUrlParams({
          "after": options?.params?.["after"] as any,
          "order": options?.params?.["order"] as any,
          "limit": options?.params?.["limit"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(AdminApiKeysList200),
          orElse: unexpectedStatus
        }))
      ),
    "adminApiKeysCreate": (options) =>
      HttpClientRequest.post(`/organization/admin_api_keys`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(AdminApiKeysCreate200),
          orElse: unexpectedStatus
        }))
      ),
    "adminApiKeysGet": (keyId, options) =>
      HttpClientRequest.get(`/organization/admin_api_keys/${keyId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(AdminApiKeysGet200),
          orElse: unexpectedStatus
        }))
      ),
    "adminApiKeysDelete": (keyId, options) =>
      HttpClientRequest.delete(`/organization/admin_api_keys/${keyId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(AdminApiKeysDelete200),
          orElse: unexpectedStatus
        }))
      ),
    "listAuditLogs": (options) =>
      HttpClientRequest.get(`/organization/audit_logs`).pipe(
        HttpClientRequest.setUrlParams({
          "effective_at[gt]": options?.params?.["effective_at[gt]"] as any,
          "effective_at[gte]": options?.params?.["effective_at[gte]"] as any,
          "effective_at[lt]": options?.params?.["effective_at[lt]"] as any,
          "effective_at[lte]": options?.params?.["effective_at[lte]"] as any,
          "project_ids[]": options?.params?.["project_ids[]"] as any,
          "event_types[]": options?.params?.["event_types[]"] as any,
          "actor_ids[]": options?.params?.["actor_ids[]"] as any,
          "actor_emails[]": options?.params?.["actor_emails[]"] as any,
          "resource_ids[]": options?.params?.["resource_ids[]"] as any,
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any,
          "before": options?.params?.["before"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListAuditLogs200),
          orElse: unexpectedStatus
        }))
      ),
    "listOrganizationCertificates": (options) =>
      HttpClientRequest.get(`/organization/certificates`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any,
          "order": options?.params?.["order"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListOrganizationCertificates200),
          orElse: unexpectedStatus
        }))
      ),
    "uploadCertificate": (options) =>
      HttpClientRequest.post(`/organization/certificates`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UploadCertificate200),
          orElse: unexpectedStatus
        }))
      ),
    "activateOrganizationCertificates": (options) =>
      HttpClientRequest.post(`/organization/certificates/activate`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ActivateOrganizationCertificates200),
          orElse: unexpectedStatus
        }))
      ),
    "deactivateOrganizationCertificates": (options) =>
      HttpClientRequest.post(`/organization/certificates/deactivate`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeactivateOrganizationCertificates200),
          orElse: unexpectedStatus
        }))
      ),
    "getCertificate": (certificateId, options) =>
      HttpClientRequest.get(`/organization/certificates/${certificateId}`).pipe(
        HttpClientRequest.setUrlParams({ "include": options?.params?.["include"] as any }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetCertificate200),
          orElse: unexpectedStatus
        }))
      ),
    "modifyCertificate": (certificateId, options) =>
      HttpClientRequest.post(`/organization/certificates/${certificateId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ModifyCertificate200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteCertificate": (certificateId, options) =>
      HttpClientRequest.delete(`/organization/certificates/${certificateId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteCertificate200),
          orElse: unexpectedStatus
        }))
      ),
    "usageCosts": (options) =>
      HttpClientRequest.get(`/organization/costs`).pipe(
        HttpClientRequest.setUrlParams({
          "start_time": options.params["start_time"] as any,
          "end_time": options.params["end_time"] as any,
          "bucket_width": options.params["bucket_width"] as any,
          "project_ids": options.params["project_ids"] as any,
          "group_by": options.params["group_by"] as any,
          "limit": options.params["limit"] as any,
          "page": options.params["page"] as any
        }),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UsageCosts200),
          orElse: unexpectedStatus
        }))
      ),
    "listGroups": (options) =>
      HttpClientRequest.get(`/organization/groups`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any,
          "order": options?.params?.["order"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListGroups200),
          orElse: unexpectedStatus
        }))
      ),
    "createGroup": (options) =>
      HttpClientRequest.post(`/organization/groups`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateGroup200),
          orElse: unexpectedStatus
        }))
      ),
    "updateGroup": (groupId, options) =>
      HttpClientRequest.post(`/organization/groups/${groupId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UpdateGroup200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteGroup": (groupId, options) =>
      HttpClientRequest.delete(`/organization/groups/${groupId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteGroup200),
          orElse: unexpectedStatus
        }))
      ),
    "listGroupRoleAssignments": (groupId, options) =>
      HttpClientRequest.get(`/organization/groups/${groupId}/roles`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any,
          "order": options?.params?.["order"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListGroupRoleAssignments200),
          orElse: unexpectedStatus
        }))
      ),
    "assignGroupRole": (groupId, options) =>
      HttpClientRequest.post(`/organization/groups/${groupId}/roles`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(AssignGroupRole200),
          orElse: unexpectedStatus
        }))
      ),
    "unassignGroupRole": (groupId, roleId, options) =>
      HttpClientRequest.delete(`/organization/groups/${groupId}/roles/${roleId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UnassignGroupRole200),
          orElse: unexpectedStatus
        }))
      ),
    "listGroupUsers": (groupId, options) =>
      HttpClientRequest.get(`/organization/groups/${groupId}/users`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any,
          "order": options?.params?.["order"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListGroupUsers200),
          orElse: unexpectedStatus
        }))
      ),
    "addGroupUser": (groupId, options) =>
      HttpClientRequest.post(`/organization/groups/${groupId}/users`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(AddGroupUser200),
          orElse: unexpectedStatus
        }))
      ),
    "removeGroupUser": (groupId, userId, options) =>
      HttpClientRequest.delete(`/organization/groups/${groupId}/users/${userId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RemoveGroupUser200),
          orElse: unexpectedStatus
        }))
      ),
    "listInvites": (options) =>
      HttpClientRequest.get(`/organization/invites`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListInvites200),
          orElse: unexpectedStatus
        }))
      ),
    "inviteUser": (options) =>
      HttpClientRequest.post(`/organization/invites`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(InviteUser200),
          orElse: unexpectedStatus
        }))
      ),
    "retrieveInvite": (inviteId, options) =>
      HttpClientRequest.get(`/organization/invites/${inviteId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RetrieveInvite200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteInvite": (inviteId, options) =>
      HttpClientRequest.delete(`/organization/invites/${inviteId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteInvite200),
          orElse: unexpectedStatus
        }))
      ),
    "listProjects": (options) =>
      HttpClientRequest.get(`/organization/projects`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any,
          "include_archived": options?.params?.["include_archived"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListProjects200),
          orElse: unexpectedStatus
        }))
      ),
    "createProject": (options) =>
      HttpClientRequest.post(`/organization/projects`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateProject200),
          orElse: unexpectedStatus
        }))
      ),
    "retrieveProject": (projectId, options) =>
      HttpClientRequest.get(`/organization/projects/${projectId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RetrieveProject200),
          orElse: unexpectedStatus
        }))
      ),
    "modifyProject": (projectId, options) =>
      HttpClientRequest.post(`/organization/projects/${projectId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ModifyProject200),
          "400": decodeError("ModifyProject400", ModifyProject400),
          orElse: unexpectedStatus
        }))
      ),
    "listProjectApiKeys": (projectId, options) =>
      HttpClientRequest.get(`/organization/projects/${projectId}/api_keys`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListProjectApiKeys200),
          orElse: unexpectedStatus
        }))
      ),
    "retrieveProjectApiKey": (projectId, keyId, options) =>
      HttpClientRequest.get(`/organization/projects/${projectId}/api_keys/${keyId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RetrieveProjectApiKey200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteProjectApiKey": (projectId, keyId, options) =>
      HttpClientRequest.delete(`/organization/projects/${projectId}/api_keys/${keyId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteProjectApiKey200),
          "400": decodeError("DeleteProjectApiKey400", DeleteProjectApiKey400),
          orElse: unexpectedStatus
        }))
      ),
    "archiveProject": (projectId, options) =>
      HttpClientRequest.post(`/organization/projects/${projectId}/archive`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ArchiveProject200),
          orElse: unexpectedStatus
        }))
      ),
    "listProjectCertificates": (projectId, options) =>
      HttpClientRequest.get(`/organization/projects/${projectId}/certificates`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any,
          "order": options?.params?.["order"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListProjectCertificates200),
          orElse: unexpectedStatus
        }))
      ),
    "activateProjectCertificates": (projectId, options) =>
      HttpClientRequest.post(`/organization/projects/${projectId}/certificates/activate`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ActivateProjectCertificates200),
          orElse: unexpectedStatus
        }))
      ),
    "deactivateProjectCertificates": (projectId, options) =>
      HttpClientRequest.post(`/organization/projects/${projectId}/certificates/deactivate`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeactivateProjectCertificates200),
          orElse: unexpectedStatus
        }))
      ),
    "listProjectGroups": (projectId, options) =>
      HttpClientRequest.get(`/organization/projects/${projectId}/groups`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any,
          "order": options?.params?.["order"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListProjectGroups200),
          orElse: unexpectedStatus
        }))
      ),
    "addProjectGroup": (projectId, options) =>
      HttpClientRequest.post(`/organization/projects/${projectId}/groups`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(AddProjectGroup200),
          orElse: unexpectedStatus
        }))
      ),
    "removeProjectGroup": (projectId, groupId, options) =>
      HttpClientRequest.delete(`/organization/projects/${projectId}/groups/${groupId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RemoveProjectGroup200),
          orElse: unexpectedStatus
        }))
      ),
    "listProjectRateLimits": (projectId, options) =>
      HttpClientRequest.get(`/organization/projects/${projectId}/rate_limits`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any,
          "before": options?.params?.["before"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListProjectRateLimits200),
          orElse: unexpectedStatus
        }))
      ),
    "updateProjectRateLimits": (projectId, rateLimitId, options) =>
      HttpClientRequest.post(`/organization/projects/${projectId}/rate_limits/${rateLimitId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UpdateProjectRateLimits200),
          "400": decodeError("UpdateProjectRateLimits400", UpdateProjectRateLimits400),
          orElse: unexpectedStatus
        }))
      ),
    "listProjectServiceAccounts": (projectId, options) =>
      HttpClientRequest.get(`/organization/projects/${projectId}/service_accounts`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListProjectServiceAccounts200),
          "400": decodeError("ListProjectServiceAccounts400", ListProjectServiceAccounts400),
          orElse: unexpectedStatus
        }))
      ),
    "createProjectServiceAccount": (projectId, options) =>
      HttpClientRequest.post(`/organization/projects/${projectId}/service_accounts`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateProjectServiceAccount200),
          "400": decodeError("CreateProjectServiceAccount400", CreateProjectServiceAccount400),
          orElse: unexpectedStatus
        }))
      ),
    "retrieveProjectServiceAccount": (projectId, serviceAccountId, options) =>
      HttpClientRequest.get(`/organization/projects/${projectId}/service_accounts/${serviceAccountId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RetrieveProjectServiceAccount200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteProjectServiceAccount": (projectId, serviceAccountId, options) =>
      HttpClientRequest.delete(`/organization/projects/${projectId}/service_accounts/${serviceAccountId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteProjectServiceAccount200),
          orElse: unexpectedStatus
        }))
      ),
    "listProjectUsers": (projectId, options) =>
      HttpClientRequest.get(`/organization/projects/${projectId}/users`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListProjectUsers200),
          "400": decodeError("ListProjectUsers400", ListProjectUsers400),
          orElse: unexpectedStatus
        }))
      ),
    "createProjectUser": (projectId, options) =>
      HttpClientRequest.post(`/organization/projects/${projectId}/users`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateProjectUser200),
          "400": decodeError("CreateProjectUser400", CreateProjectUser400),
          orElse: unexpectedStatus
        }))
      ),
    "retrieveProjectUser": (projectId, userId, options) =>
      HttpClientRequest.get(`/organization/projects/${projectId}/users/${userId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RetrieveProjectUser200),
          orElse: unexpectedStatus
        }))
      ),
    "modifyProjectUser": (projectId, userId, options) =>
      HttpClientRequest.post(`/organization/projects/${projectId}/users/${userId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ModifyProjectUser200),
          "400": decodeError("ModifyProjectUser400", ModifyProjectUser400),
          orElse: unexpectedStatus
        }))
      ),
    "deleteProjectUser": (projectId, userId, options) =>
      HttpClientRequest.delete(`/organization/projects/${projectId}/users/${userId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteProjectUser200),
          "400": decodeError("DeleteProjectUser400", DeleteProjectUser400),
          orElse: unexpectedStatus
        }))
      ),
    "listRoles": (options) =>
      HttpClientRequest.get(`/organization/roles`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any,
          "order": options?.params?.["order"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListRoles200),
          orElse: unexpectedStatus
        }))
      ),
    "createRole": (options) =>
      HttpClientRequest.post(`/organization/roles`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateRole200),
          orElse: unexpectedStatus
        }))
      ),
    "updateRole": (roleId, options) =>
      HttpClientRequest.post(`/organization/roles/${roleId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UpdateRole200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteRole": (roleId, options) =>
      HttpClientRequest.delete(`/organization/roles/${roleId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteRole200),
          orElse: unexpectedStatus
        }))
      ),
    "usageAudioSpeeches": (options) =>
      HttpClientRequest.get(`/organization/usage/audio_speeches`).pipe(
        HttpClientRequest.setUrlParams({
          "start_time": options.params["start_time"] as any,
          "end_time": options.params["end_time"] as any,
          "bucket_width": options.params["bucket_width"] as any,
          "project_ids": options.params["project_ids"] as any,
          "user_ids": options.params["user_ids"] as any,
          "api_key_ids": options.params["api_key_ids"] as any,
          "models": options.params["models"] as any,
          "group_by": options.params["group_by"] as any,
          "limit": options.params["limit"] as any,
          "page": options.params["page"] as any
        }),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UsageAudioSpeeches200),
          orElse: unexpectedStatus
        }))
      ),
    "usageAudioTranscriptions": (options) =>
      HttpClientRequest.get(`/organization/usage/audio_transcriptions`).pipe(
        HttpClientRequest.setUrlParams({
          "start_time": options.params["start_time"] as any,
          "end_time": options.params["end_time"] as any,
          "bucket_width": options.params["bucket_width"] as any,
          "project_ids": options.params["project_ids"] as any,
          "user_ids": options.params["user_ids"] as any,
          "api_key_ids": options.params["api_key_ids"] as any,
          "models": options.params["models"] as any,
          "group_by": options.params["group_by"] as any,
          "limit": options.params["limit"] as any,
          "page": options.params["page"] as any
        }),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UsageAudioTranscriptions200),
          orElse: unexpectedStatus
        }))
      ),
    "usageCodeInterpreterSessions": (options) =>
      HttpClientRequest.get(`/organization/usage/code_interpreter_sessions`).pipe(
        HttpClientRequest.setUrlParams({
          "start_time": options.params["start_time"] as any,
          "end_time": options.params["end_time"] as any,
          "bucket_width": options.params["bucket_width"] as any,
          "project_ids": options.params["project_ids"] as any,
          "group_by": options.params["group_by"] as any,
          "limit": options.params["limit"] as any,
          "page": options.params["page"] as any
        }),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UsageCodeInterpreterSessions200),
          orElse: unexpectedStatus
        }))
      ),
    "usageCompletions": (options) =>
      HttpClientRequest.get(`/organization/usage/completions`).pipe(
        HttpClientRequest.setUrlParams({
          "start_time": options.params["start_time"] as any,
          "end_time": options.params["end_time"] as any,
          "bucket_width": options.params["bucket_width"] as any,
          "project_ids": options.params["project_ids"] as any,
          "user_ids": options.params["user_ids"] as any,
          "api_key_ids": options.params["api_key_ids"] as any,
          "models": options.params["models"] as any,
          "batch": options.params["batch"] as any,
          "group_by": options.params["group_by"] as any,
          "limit": options.params["limit"] as any,
          "page": options.params["page"] as any
        }),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UsageCompletions200),
          orElse: unexpectedStatus
        }))
      ),
    "usageEmbeddings": (options) =>
      HttpClientRequest.get(`/organization/usage/embeddings`).pipe(
        HttpClientRequest.setUrlParams({
          "start_time": options.params["start_time"] as any,
          "end_time": options.params["end_time"] as any,
          "bucket_width": options.params["bucket_width"] as any,
          "project_ids": options.params["project_ids"] as any,
          "user_ids": options.params["user_ids"] as any,
          "api_key_ids": options.params["api_key_ids"] as any,
          "models": options.params["models"] as any,
          "group_by": options.params["group_by"] as any,
          "limit": options.params["limit"] as any,
          "page": options.params["page"] as any
        }),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UsageEmbeddings200),
          orElse: unexpectedStatus
        }))
      ),
    "usageImages": (options) =>
      HttpClientRequest.get(`/organization/usage/images`).pipe(
        HttpClientRequest.setUrlParams({
          "start_time": options.params["start_time"] as any,
          "end_time": options.params["end_time"] as any,
          "bucket_width": options.params["bucket_width"] as any,
          "sources": options.params["sources"] as any,
          "sizes": options.params["sizes"] as any,
          "project_ids": options.params["project_ids"] as any,
          "user_ids": options.params["user_ids"] as any,
          "api_key_ids": options.params["api_key_ids"] as any,
          "models": options.params["models"] as any,
          "group_by": options.params["group_by"] as any,
          "limit": options.params["limit"] as any,
          "page": options.params["page"] as any
        }),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UsageImages200),
          orElse: unexpectedStatus
        }))
      ),
    "usageModerations": (options) =>
      HttpClientRequest.get(`/organization/usage/moderations`).pipe(
        HttpClientRequest.setUrlParams({
          "start_time": options.params["start_time"] as any,
          "end_time": options.params["end_time"] as any,
          "bucket_width": options.params["bucket_width"] as any,
          "project_ids": options.params["project_ids"] as any,
          "user_ids": options.params["user_ids"] as any,
          "api_key_ids": options.params["api_key_ids"] as any,
          "models": options.params["models"] as any,
          "group_by": options.params["group_by"] as any,
          "limit": options.params["limit"] as any,
          "page": options.params["page"] as any
        }),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UsageModerations200),
          orElse: unexpectedStatus
        }))
      ),
    "usageVectorStores": (options) =>
      HttpClientRequest.get(`/organization/usage/vector_stores`).pipe(
        HttpClientRequest.setUrlParams({
          "start_time": options.params["start_time"] as any,
          "end_time": options.params["end_time"] as any,
          "bucket_width": options.params["bucket_width"] as any,
          "project_ids": options.params["project_ids"] as any,
          "group_by": options.params["group_by"] as any,
          "limit": options.params["limit"] as any,
          "page": options.params["page"] as any
        }),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UsageVectorStores200),
          orElse: unexpectedStatus
        }))
      ),
    "listUsers": (options) =>
      HttpClientRequest.get(`/organization/users`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any,
          "emails": options?.params?.["emails"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListUsers200),
          orElse: unexpectedStatus
        }))
      ),
    "retrieveUser": (userId, options) =>
      HttpClientRequest.get(`/organization/users/${userId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RetrieveUser200),
          orElse: unexpectedStatus
        }))
      ),
    "modifyUser": (userId, options) =>
      HttpClientRequest.post(`/organization/users/${userId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ModifyUser200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteUser": (userId, options) =>
      HttpClientRequest.delete(`/organization/users/${userId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteUser200),
          orElse: unexpectedStatus
        }))
      ),
    "listUserRoleAssignments": (userId, options) =>
      HttpClientRequest.get(`/organization/users/${userId}/roles`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any,
          "order": options?.params?.["order"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListUserRoleAssignments200),
          orElse: unexpectedStatus
        }))
      ),
    "assignUserRole": (userId, options) =>
      HttpClientRequest.post(`/organization/users/${userId}/roles`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(AssignUserRole200),
          orElse: unexpectedStatus
        }))
      ),
    "unassignUserRole": (userId, roleId, options) =>
      HttpClientRequest.delete(`/organization/users/${userId}/roles/${roleId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UnassignUserRole200),
          orElse: unexpectedStatus
        }))
      ),
    "listProjectGroupRoleAssignments": (projectId, groupId, options) =>
      HttpClientRequest.get(`/projects/${projectId}/groups/${groupId}/roles`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any,
          "order": options?.params?.["order"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListProjectGroupRoleAssignments200),
          orElse: unexpectedStatus
        }))
      ),
    "assignProjectGroupRole": (projectId, groupId, options) =>
      HttpClientRequest.post(`/projects/${projectId}/groups/${groupId}/roles`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(AssignProjectGroupRole200),
          orElse: unexpectedStatus
        }))
      ),
    "unassignProjectGroupRole": (projectId, groupId, roleId, options) =>
      HttpClientRequest.delete(`/projects/${projectId}/groups/${groupId}/roles/${roleId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UnassignProjectGroupRole200),
          orElse: unexpectedStatus
        }))
      ),
    "listProjectRoles": (projectId, options) =>
      HttpClientRequest.get(`/projects/${projectId}/roles`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any,
          "order": options?.params?.["order"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListProjectRoles200),
          orElse: unexpectedStatus
        }))
      ),
    "createProjectRole": (projectId, options) =>
      HttpClientRequest.post(`/projects/${projectId}/roles`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateProjectRole200),
          orElse: unexpectedStatus
        }))
      ),
    "updateProjectRole": (projectId, roleId, options) =>
      HttpClientRequest.post(`/projects/${projectId}/roles/${roleId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UpdateProjectRole200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteProjectRole": (projectId, roleId, options) =>
      HttpClientRequest.delete(`/projects/${projectId}/roles/${roleId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteProjectRole200),
          orElse: unexpectedStatus
        }))
      ),
    "listProjectUserRoleAssignments": (projectId, userId, options) =>
      HttpClientRequest.get(`/projects/${projectId}/users/${userId}/roles`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "after": options?.params?.["after"] as any,
          "order": options?.params?.["order"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListProjectUserRoleAssignments200),
          orElse: unexpectedStatus
        }))
      ),
    "assignProjectUserRole": (projectId, userId, options) =>
      HttpClientRequest.post(`/projects/${projectId}/users/${userId}/roles`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(AssignProjectUserRole200),
          orElse: unexpectedStatus
        }))
      ),
    "unassignProjectUserRole": (projectId, userId, roleId, options) =>
      HttpClientRequest.delete(`/projects/${projectId}/users/${userId}/roles/${roleId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UnassignProjectUserRole200),
          orElse: unexpectedStatus
        }))
      ),
    "createRealtimeCall": (options) =>
      HttpClientRequest.post(`/realtime/calls`).pipe(
        HttpClientRequest.bodyFormData(options.payload as any),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          orElse: unexpectedStatus
        }))
      ),
    "acceptRealtimeCall": (callId, options) =>
      HttpClientRequest.post(`/realtime/calls/${callId}/accept`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "200": () => Effect.void,
          orElse: unexpectedStatus
        }))
      ),
    "hangupRealtimeCall": (callId, options) =>
      HttpClientRequest.post(`/realtime/calls/${callId}/hangup`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "200": () => Effect.void,
          orElse: unexpectedStatus
        }))
      ),
    "referRealtimeCall": (callId, options) =>
      HttpClientRequest.post(`/realtime/calls/${callId}/refer`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "200": () => Effect.void,
          orElse: unexpectedStatus
        }))
      ),
    "rejectRealtimeCall": (callId, options) =>
      HttpClientRequest.post(`/realtime/calls/${callId}/reject`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "200": () => Effect.void,
          orElse: unexpectedStatus
        }))
      ),
    "createRealtimeClientSecret": (options) =>
      HttpClientRequest.post(`/realtime/client_secrets`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateRealtimeClientSecret200),
          orElse: unexpectedStatus
        }))
      ),
    "createRealtimeSession": (options) =>
      HttpClientRequest.post(`/realtime/sessions`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateRealtimeSession200),
          orElse: unexpectedStatus
        }))
      ),
    "createRealtimeTranscriptionSession": (options) =>
      HttpClientRequest.post(`/realtime/transcription_sessions`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateRealtimeTranscriptionSession200),
          orElse: unexpectedStatus
        }))
      ),
    "createResponse": (options) =>
      HttpClientRequest.post(`/responses`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateResponse200),
          orElse: unexpectedStatus
        }))
      ),
    "createResponseSse": (options) =>
      HttpClientRequest.post(`/responses`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        sseRequest(CreateResponse200Sse)
      ),
    "getResponse": (responseId, options) =>
      HttpClientRequest.get(`/responses/${responseId}`).pipe(
        HttpClientRequest.setUrlParams({
          "include": options?.params?.["include"] as any,
          "stream": options?.params?.["stream"] as any,
          "starting_after": options?.params?.["starting_after"] as any,
          "include_obfuscation": options?.params?.["include_obfuscation"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetResponse200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteResponse": (responseId, options) =>
      HttpClientRequest.delete(`/responses/${responseId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "404": decodeError("DeleteResponse404", DeleteResponse404),
          "200": () => Effect.void,
          orElse: unexpectedStatus
        }))
      ),
    "cancelResponse": (responseId, options) =>
      HttpClientRequest.post(`/responses/${responseId}/cancel`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CancelResponse200),
          "404": decodeError("CancelResponse404", CancelResponse404),
          orElse: unexpectedStatus
        }))
      ),
    "listInputItems": (responseId, options) =>
      HttpClientRequest.get(`/responses/${responseId}/input_items`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any,
          "include": options?.params?.["include"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListInputItems200),
          orElse: unexpectedStatus
        }))
      ),
    "createThread": (options) =>
      HttpClientRequest.post(`/threads`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateThread200),
          orElse: unexpectedStatus
        }))
      ),
    "createThreadAndRun": (options) =>
      HttpClientRequest.post(`/threads/runs`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateThreadAndRun200),
          orElse: unexpectedStatus
        }))
      ),
    "getThread": (threadId, options) =>
      HttpClientRequest.get(`/threads/${threadId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetThread200),
          orElse: unexpectedStatus
        }))
      ),
    "modifyThread": (threadId, options) =>
      HttpClientRequest.post(`/threads/${threadId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ModifyThread200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteThread": (threadId, options) =>
      HttpClientRequest.delete(`/threads/${threadId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteThread200),
          orElse: unexpectedStatus
        }))
      ),
    "listMessages": (threadId, options) =>
      HttpClientRequest.get(`/threads/${threadId}/messages`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any,
          "before": options?.params?.["before"] as any,
          "run_id": options?.params?.["run_id"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListMessages200),
          orElse: unexpectedStatus
        }))
      ),
    "createMessage": (threadId, options) =>
      HttpClientRequest.post(`/threads/${threadId}/messages`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateMessage200),
          orElse: unexpectedStatus
        }))
      ),
    "getMessage": (threadId, messageId, options) =>
      HttpClientRequest.get(`/threads/${threadId}/messages/${messageId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetMessage200),
          orElse: unexpectedStatus
        }))
      ),
    "modifyMessage": (threadId, messageId, options) =>
      HttpClientRequest.post(`/threads/${threadId}/messages/${messageId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ModifyMessage200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteMessage": (threadId, messageId, options) =>
      HttpClientRequest.delete(`/threads/${threadId}/messages/${messageId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteMessage200),
          orElse: unexpectedStatus
        }))
      ),
    "listRuns": (threadId, options) =>
      HttpClientRequest.get(`/threads/${threadId}/runs`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any,
          "before": options?.params?.["before"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListRuns200),
          orElse: unexpectedStatus
        }))
      ),
    "createRun": (threadId, options) =>
      HttpClientRequest.post(`/threads/${threadId}/runs`).pipe(
        HttpClientRequest.setUrlParams({ "include[]": options.params?.["include[]"] as any }),
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateRun200),
          orElse: unexpectedStatus
        }))
      ),
    "getRun": (threadId, runId, options) =>
      HttpClientRequest.get(`/threads/${threadId}/runs/${runId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetRun200),
          orElse: unexpectedStatus
        }))
      ),
    "modifyRun": (threadId, runId, options) =>
      HttpClientRequest.post(`/threads/${threadId}/runs/${runId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ModifyRun200),
          orElse: unexpectedStatus
        }))
      ),
    "cancelRun": (threadId, runId, options) =>
      HttpClientRequest.post(`/threads/${threadId}/runs/${runId}/cancel`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CancelRun200),
          orElse: unexpectedStatus
        }))
      ),
    "listRunSteps": (threadId, runId, options) =>
      HttpClientRequest.get(`/threads/${threadId}/runs/${runId}/steps`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any,
          "before": options?.params?.["before"] as any,
          "include[]": options?.params?.["include[]"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListRunSteps200),
          orElse: unexpectedStatus
        }))
      ),
    "getRunStep": (threadId, runId, stepId, options) =>
      HttpClientRequest.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`).pipe(
        HttpClientRequest.setUrlParams({ "include[]": options?.params?.["include[]"] as any }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetRunStep200),
          orElse: unexpectedStatus
        }))
      ),
    "submitToolOuputsToRun": (threadId, runId, options) =>
      HttpClientRequest.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(SubmitToolOuputsToRun200),
          orElse: unexpectedStatus
        }))
      ),
    "createUpload": (options) =>
      HttpClientRequest.post(`/uploads`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateUpload200),
          orElse: unexpectedStatus
        }))
      ),
    "cancelUpload": (uploadId, options) =>
      HttpClientRequest.post(`/uploads/${uploadId}/cancel`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CancelUpload200),
          orElse: unexpectedStatus
        }))
      ),
    "completeUpload": (uploadId, options) =>
      HttpClientRequest.post(`/uploads/${uploadId}/complete`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CompleteUpload200),
          orElse: unexpectedStatus
        }))
      ),
    "addUploadPart": (uploadId, options) =>
      HttpClientRequest.post(`/uploads/${uploadId}/parts`).pipe(
        HttpClientRequest.bodyFormData(options.payload as any),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(AddUploadPart200),
          orElse: unexpectedStatus
        }))
      ),
    "listVectorStores": (options) =>
      HttpClientRequest.get(`/vector_stores`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any,
          "before": options?.params?.["before"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListVectorStores200),
          orElse: unexpectedStatus
        }))
      ),
    "createVectorStore": (options) =>
      HttpClientRequest.post(`/vector_stores`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateVectorStore200),
          orElse: unexpectedStatus
        }))
      ),
    "getVectorStore": (vectorStoreId, options) =>
      HttpClientRequest.get(`/vector_stores/${vectorStoreId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetVectorStore200),
          orElse: unexpectedStatus
        }))
      ),
    "modifyVectorStore": (vectorStoreId, options) =>
      HttpClientRequest.post(`/vector_stores/${vectorStoreId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ModifyVectorStore200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteVectorStore": (vectorStoreId, options) =>
      HttpClientRequest.delete(`/vector_stores/${vectorStoreId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteVectorStore200),
          orElse: unexpectedStatus
        }))
      ),
    "createVectorStoreFileBatch": (vectorStoreId, options) =>
      HttpClientRequest.post(`/vector_stores/${vectorStoreId}/file_batches`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateVectorStoreFileBatch200),
          orElse: unexpectedStatus
        }))
      ),
    "getVectorStoreFileBatch": (vectorStoreId, batchId, options) =>
      HttpClientRequest.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetVectorStoreFileBatch200),
          orElse: unexpectedStatus
        }))
      ),
    "cancelVectorStoreFileBatch": (vectorStoreId, batchId, options) =>
      HttpClientRequest.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CancelVectorStoreFileBatch200),
          orElse: unexpectedStatus
        }))
      ),
    "listFilesInVectorStoreBatch": (vectorStoreId, batchId, options) =>
      HttpClientRequest.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any,
          "before": options?.params?.["before"] as any,
          "filter": options?.params?.["filter"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListFilesInVectorStoreBatch200),
          orElse: unexpectedStatus
        }))
      ),
    "listVectorStoreFiles": (vectorStoreId, options) =>
      HttpClientRequest.get(`/vector_stores/${vectorStoreId}/files`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any,
          "before": options?.params?.["before"] as any,
          "filter": options?.params?.["filter"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListVectorStoreFiles200),
          orElse: unexpectedStatus
        }))
      ),
    "createVectorStoreFile": (vectorStoreId, options) =>
      HttpClientRequest.post(`/vector_stores/${vectorStoreId}/files`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateVectorStoreFile200),
          orElse: unexpectedStatus
        }))
      ),
    "getVectorStoreFile": (vectorStoreId, fileId, options) =>
      HttpClientRequest.get(`/vector_stores/${vectorStoreId}/files/${fileId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetVectorStoreFile200),
          orElse: unexpectedStatus
        }))
      ),
    "updateVectorStoreFileAttributes": (vectorStoreId, fileId, options) =>
      HttpClientRequest.post(`/vector_stores/${vectorStoreId}/files/${fileId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UpdateVectorStoreFileAttributes200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteVectorStoreFile": (vectorStoreId, fileId, options) =>
      HttpClientRequest.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteVectorStoreFile200),
          orElse: unexpectedStatus
        }))
      ),
    "retrieveVectorStoreFileContent": (vectorStoreId, fileId, options) =>
      HttpClientRequest.get(`/vector_stores/${vectorStoreId}/files/${fileId}/content`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RetrieveVectorStoreFileContent200),
          orElse: unexpectedStatus
        }))
      ),
    "searchVectorStore": (vectorStoreId, options) =>
      HttpClientRequest.post(`/vector_stores/${vectorStoreId}/search`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(SearchVectorStore200),
          orElse: unexpectedStatus
        }))
      ),
    "createConversation": (options) =>
      HttpClientRequest.post(`/conversations`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateConversation200),
          orElse: unexpectedStatus
        }))
      ),
    "getConversation": (conversationId, options) =>
      HttpClientRequest.get(`/conversations/${conversationId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetConversation200),
          orElse: unexpectedStatus
        }))
      ),
    "updateConversation": (conversationId, options) =>
      HttpClientRequest.post(`/conversations/${conversationId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UpdateConversation200),
          orElse: unexpectedStatus
        }))
      ),
    "deleteConversation": (conversationId, options) =>
      HttpClientRequest.delete(`/conversations/${conversationId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteConversation200),
          orElse: unexpectedStatus
        }))
      ),
    "ListVideos": (options) =>
      HttpClientRequest.get(`/videos`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListVideos200),
          orElse: unexpectedStatus
        }))
      ),
    "createVideo": (options) =>
      HttpClientRequest.post(`/videos`).pipe(
        HttpClientRequest.bodyFormData(options.payload as any),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateVideo200),
          orElse: unexpectedStatus
        }))
      ),
    "GetVideo": (videoId, options) =>
      HttpClientRequest.get(`/videos/${videoId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetVideo200),
          orElse: unexpectedStatus
        }))
      ),
    "DeleteVideo": (videoId, options) =>
      HttpClientRequest.delete(`/videos/${videoId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteVideo200),
          orElse: unexpectedStatus
        }))
      ),
    "RetrieveVideoContent": (videoId, options) =>
      HttpClientRequest.get(`/videos/${videoId}/content`).pipe(
        HttpClientRequest.setUrlParams({ "variant": options?.params?.["variant"] as any }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(RetrieveVideoContent200),
          orElse: unexpectedStatus
        }))
      ),
    "CreateVideoRemix": (videoId, options) =>
      HttpClientRequest.post(`/videos/${videoId}/remix`).pipe(
        HttpClientRequest.bodyFormData(options.payload as any),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateVideoRemix200),
          orElse: unexpectedStatus
        }))
      ),
    "Getinputtokencounts": (options) =>
      HttpClientRequest.post(`/responses/input_tokens`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(Getinputtokencounts200),
          orElse: unexpectedStatus
        }))
      ),
    "Compactconversation": (options) =>
      HttpClientRequest.post(`/responses/compact`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(Compactconversation200),
          orElse: unexpectedStatus
        }))
      ),
    "ListSkills": (options) =>
      HttpClientRequest.get(`/skills`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListSkills200),
          orElse: unexpectedStatus
        }))
      ),
    "CreateSkill": (options) =>
      HttpClientRequest.post(`/skills`).pipe(
        HttpClientRequest.bodyFormData(options.payload as any),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateSkill200),
          orElse: unexpectedStatus
        }))
      ),
    "GetSkill": (skillId, options) =>
      HttpClientRequest.get(`/skills/${skillId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetSkill200),
          orElse: unexpectedStatus
        }))
      ),
    "UpdateSkillDefaultVersion": (skillId, options) =>
      HttpClientRequest.post(`/skills/${skillId}`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UpdateSkillDefaultVersion200),
          orElse: unexpectedStatus
        }))
      ),
    "DeleteSkill": (skillId, options) =>
      HttpClientRequest.delete(`/skills/${skillId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteSkill200),
          orElse: unexpectedStatus
        }))
      ),
    "GetSkillContent": (skillId, options) =>
      HttpClientRequest.get(`/skills/${skillId}/content`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetSkillContent200),
          orElse: unexpectedStatus
        }))
      ),
    "ListSkillVersions": (skillId, options) =>
      HttpClientRequest.get(`/skills/${skillId}/versions`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListSkillVersions200),
          orElse: unexpectedStatus
        }))
      ),
    "CreateSkillVersion": (skillId, options) =>
      HttpClientRequest.post(`/skills/${skillId}/versions`).pipe(
        HttpClientRequest.bodyFormData(options.payload as any),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateSkillVersion200),
          orElse: unexpectedStatus
        }))
      ),
    "GetSkillVersion": (skillId, version, options) =>
      HttpClientRequest.get(`/skills/${skillId}/versions/${version}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetSkillVersion200),
          orElse: unexpectedStatus
        }))
      ),
    "DeleteSkillVersion": (skillId, version, options) =>
      HttpClientRequest.delete(`/skills/${skillId}/versions/${version}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteSkillVersion200),
          orElse: unexpectedStatus
        }))
      ),
    "GetSkillVersionContent": (skillId, version, options) =>
      HttpClientRequest.get(`/skills/${skillId}/versions/${version}/content`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetSkillVersionContent200),
          orElse: unexpectedStatus
        }))
      ),
    "CancelChatSessionMethod": (sessionId, options) =>
      HttpClientRequest.post(`/chatkit/sessions/${sessionId}/cancel`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CancelChatSessionMethod200),
          orElse: unexpectedStatus
        }))
      ),
    "CreateChatSessionMethod": (options) =>
      HttpClientRequest.post(`/chatkit/sessions`).pipe(
        HttpClientRequest.bodyJsonUnsafe(options.payload),
        withResponse(options.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CreateChatSessionMethod200),
          orElse: unexpectedStatus
        }))
      ),
    "ListThreadItemsMethod": (threadId, options) =>
      HttpClientRequest.get(`/chatkit/threads/${threadId}/items`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any,
          "before": options?.params?.["before"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListThreadItemsMethod200),
          orElse: unexpectedStatus
        }))
      ),
    "GetThreadMethod": (threadId, options) =>
      HttpClientRequest.get(`/chatkit/threads/${threadId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(GetThreadMethod200),
          orElse: unexpectedStatus
        }))
      ),
    "DeleteThreadMethod": (threadId, options) =>
      HttpClientRequest.delete(`/chatkit/threads/${threadId}`).pipe(
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeleteThreadMethod200),
          orElse: unexpectedStatus
        }))
      ),
    "ListThreadsMethod": (options) =>
      HttpClientRequest.get(`/chatkit/threads`).pipe(
        HttpClientRequest.setUrlParams({
          "limit": options?.params?.["limit"] as any,
          "order": options?.params?.["order"] as any,
          "after": options?.params?.["after"] as any,
          "before": options?.params?.["before"] as any,
          "user": options?.params?.["user"] as any
        }),
        withResponse(options?.config)(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ListThreadsMethod200),
          orElse: unexpectedStatus
        }))
      )
  }
}

export interface OpenAiClient {
  readonly httpClient: HttpClient.HttpClient
  /**
   * Returns a list of assistants.
   */
  readonly "listAssistants": <Config extends OperationConfig>(
    options:
      | { readonly params?: typeof ListAssistantsParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListAssistants200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create an assistant with a model and instructions.
   */
  readonly "createAssistant": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateAssistantRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateAssistant200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieves an assistant.
   */
  readonly "getAssistant": <Config extends OperationConfig>(
    assistantId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetAssistant200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Modifies an assistant.
   */
  readonly "modifyAssistant": <Config extends OperationConfig>(
    assistantId: string,
    options: { readonly payload: typeof ModifyAssistantRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof ModifyAssistant200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete an assistant.
   */
  readonly "deleteAssistant": <Config extends OperationConfig>(
    assistantId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteAssistant200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Generates audio from the input text.
   *
   * Returns the audio file content, or a stream of audio events.
   */
  readonly "createSpeech": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateSpeechRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<WithOptionalResponse<void, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
   * Generates audio from the input text.
   *
   * Returns the audio file content, or a stream of audio events.
   */
  readonly "createSpeechSse": (
    options: { readonly payload: typeof CreateSpeechRequestJson.Encoded }
  ) => Stream.Stream<
    { readonly event: string; readonly id: string | undefined; readonly data: typeof CreateSpeech200Sse.Type },
    HttpClientError.HttpClientError | SchemaError | Sse.Retry,
    typeof CreateSpeech200Sse.DecodingServices
  >
  /**
   * Generates audio from the input text.
   *
   * Returns the audio file content, or a stream of audio events.
   */
  readonly "createSpeechStream": (
    options: { readonly payload: typeof CreateSpeechRequestJson.Encoded }
  ) => Stream.Stream<Uint8Array, HttpClientError.HttpClientError>
  /**
   * Transcribes audio into the input language.
   *
   * Returns a transcription object in `json`, `diarized_json`, or `verbose_json`
   * format, or a stream of transcript events.
   */
  readonly "createTranscription": <Config extends OperationConfig>(
    options: {
      readonly payload: typeof CreateTranscriptionRequestFormData.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateTranscription200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Transcribes audio into the input language.
   *
   * Returns a transcription object in `json`, `diarized_json`, or `verbose_json`
   * format, or a stream of transcript events.
   */
  readonly "createTranscriptionSse": (
    options: { readonly payload: typeof CreateTranscriptionRequestFormData.Encoded }
  ) => Stream.Stream<
    { readonly event: string; readonly id: string | undefined; readonly data: typeof CreateTranscription200Sse.Type },
    HttpClientError.HttpClientError | SchemaError | Sse.Retry,
    typeof CreateTranscription200Sse.DecodingServices
  >
  /**
   * Translates audio into English.
   */
  readonly "createTranslation": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateTranslationRequestFormData.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateTranslation200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * List consent recordings available to your organization for creating custom voices.
   *
   * See the [custom voices guide](/docs/guides/text-to-speech#custom-voices). Custom voices are limited to eligible customers.
   */
  readonly "listVoiceConsents": <Config extends OperationConfig>(
    options: {
      readonly params?: typeof ListVoiceConsentsParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListVoiceConsents200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Upload a consent recording that authorizes creation of a custom voice.
   *
   * See the [custom voices guide](/docs/guides/text-to-speech#custom-voices) for requirements and best practices. Custom voices are limited to eligible customers.
   */
  readonly "createVoiceConsent": <Config extends OperationConfig>(
    options: {
      readonly payload: typeof CreateVoiceConsentRequestFormData.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateVoiceConsent200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieve consent recording metadata used for creating custom voices.
   *
   * See the [custom voices guide](/docs/guides/text-to-speech#custom-voices). Custom voices are limited to eligible customers.
   */
  readonly "getVoiceConsent": <Config extends OperationConfig>(
    consentId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetVoiceConsent200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Update consent recording metadata used for creating custom voices. This endpoint updates metadata only and does not replace the underlying audio.
   *
   * See the [custom voices guide](/docs/guides/text-to-speech#custom-voices). Custom voices are limited to eligible customers.
   */
  readonly "updateVoiceConsent": <Config extends OperationConfig>(
    consentId: string,
    options: { readonly payload: typeof UpdateVoiceConsentRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UpdateVoiceConsent200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete a consent recording that was uploaded for creating custom voices.
   *
   * See the [custom voices guide](/docs/guides/text-to-speech#custom-voices). Custom voices are limited to eligible customers.
   */
  readonly "deleteVoiceConsent": <Config extends OperationConfig>(
    consentId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteVoiceConsent200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create a custom voice you can use for audio output (for example, in Text-to-Speech and the Realtime API). This requires an audio sample and a previously uploaded consent recording.
   *
   * See the [custom voices guide](/docs/guides/text-to-speech#custom-voices) for requirements and best practices. Custom voices are limited to eligible customers.
   */
  readonly "createVoice": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateVoiceRequestFormData.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateVoice200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * List your organization's batches.
   */
  readonly "listBatches": <Config extends OperationConfig>(
    options:
      | { readonly params?: typeof ListBatchesParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListBatches200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  readonly "createBatch": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateBatchRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateBatch200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieves a batch.
   */
  readonly "retrieveBatch": <Config extends OperationConfig>(
    batchId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof RetrieveBatch200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to 10 minutes, before changing to `cancelled`, where it will have partial results (if any) available in the output file.
   */
  readonly "cancelBatch": <Config extends OperationConfig>(
    batchId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof CancelBatch200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * List stored Chat Completions. Only Chat Completions that have been stored
   * with the `store` parameter set to `true` will be returned.
   */
  readonly "listChatCompletions": <Config extends OperationConfig>(
    options: {
      readonly params?: typeof ListChatCompletionsParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListChatCompletions200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * **Starting a new project?** We recommend trying [Responses](/docs/api-reference/responses)
   * to take advantage of the latest OpenAI platform features. Compare
   * [Chat Completions with Responses](/docs/guides/responses-vs-chat-completions?api-mode=responses).
   *
   * ---
   *
   * Creates a model response for the given chat conversation. Learn more in the
   * [text generation](/docs/guides/text-generation), [vision](/docs/guides/vision),
   * and [audio](/docs/guides/audio) guides.
   *
   * Parameter support can differ depending on the model used to generate the
   * response, particularly for newer reasoning models. Parameters that are only
   * supported for reasoning models are noted below. For the current state of
   * unsupported parameters in reasoning models,
   * [refer to the reasoning guide](/docs/guides/reasoning).
   *
   * Returns a chat completion object, or a streamed sequence of chat completion
   * chunk objects if the request is streamed.
   */
  readonly "createChatCompletion": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateChatCompletionRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateChatCompletion200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * **Starting a new project?** We recommend trying [Responses](/docs/api-reference/responses)
   * to take advantage of the latest OpenAI platform features. Compare
   * [Chat Completions with Responses](/docs/guides/responses-vs-chat-completions?api-mode=responses).
   *
   * ---
   *
   * Creates a model response for the given chat conversation. Learn more in the
   * [text generation](/docs/guides/text-generation), [vision](/docs/guides/vision),
   * and [audio](/docs/guides/audio) guides.
   *
   * Parameter support can differ depending on the model used to generate the
   * response, particularly for newer reasoning models. Parameters that are only
   * supported for reasoning models are noted below. For the current state of
   * unsupported parameters in reasoning models,
   * [refer to the reasoning guide](/docs/guides/reasoning).
   *
   * Returns a chat completion object, or a streamed sequence of chat completion
   * chunk objects if the request is streamed.
   */
  readonly "createChatCompletionSse": (
    options: { readonly payload: typeof CreateChatCompletionRequestJson.Encoded }
  ) => Stream.Stream<
    { readonly event: string; readonly id: string | undefined; readonly data: typeof CreateChatCompletion200Sse.Type },
    HttpClientError.HttpClientError | SchemaError | Sse.Retry,
    typeof CreateChatCompletion200Sse.DecodingServices
  >
  /**
   * Get a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` will be returned.
   */
  readonly "getChatCompletion": <Config extends OperationConfig>(
    completionId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetChatCompletion200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Modify a stored chat completion. Only Chat Completions that have been
   * created with the `store` parameter set to `true` can be modified. Currently,
   * the only supported modification is to update the `metadata` field.
   */
  readonly "updateChatCompletion": <Config extends OperationConfig>(
    completionId: string,
    options: { readonly payload: typeof UpdateChatCompletionRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UpdateChatCompletion200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete a stored chat completion. Only Chat Completions that have been
   * created with the `store` parameter set to `true` can be deleted.
   */
  readonly "deleteChatCompletion": <Config extends OperationConfig>(
    completionId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteChatCompletion200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get the messages in a stored chat completion. Only Chat Completions that
   * have been created with the `store` parameter set to `true` will be
   * returned.
   */
  readonly "getChatCompletionMessages": <Config extends OperationConfig>(
    completionId: string,
    options: {
      readonly params?: typeof GetChatCompletionMessagesParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetChatCompletionMessages200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Creates a completion for the provided prompt and parameters.
   *
   * Returns a completion object, or a sequence of completion objects if the request is streamed.
   */
  readonly "createCompletion": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateCompletionRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateCompletion200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Lists containers.
   */
  readonly "ListContainers": <Config extends OperationConfig>(
    options:
      | { readonly params?: typeof ListContainersParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListContainers200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Creates a container.
   */
  readonly "CreateContainer": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateContainerRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateContainer200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieves a container.
   */
  readonly "RetrieveContainer": <Config extends OperationConfig>(
    containerId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof RetrieveContainer200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete a container.
   */
  readonly "DeleteContainer": <Config extends OperationConfig>(
    containerId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<WithOptionalResponse<void, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
   * Lists container files.
   */
  readonly "ListContainerFiles": <Config extends OperationConfig>(
    containerId: string,
    options: {
      readonly params?: typeof ListContainerFilesParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListContainerFiles200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Creates a container file.
   */
  readonly "CreateContainerFile": <Config extends OperationConfig>(
    containerId: string,
    options: {
      readonly payload: typeof CreateContainerFileRequestFormData.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateContainerFile200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieves a container file.
   */
  readonly "RetrieveContainerFile": <Config extends OperationConfig>(
    containerId: string,
    fileId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof RetrieveContainerFile200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete a container file.
   */
  readonly "DeleteContainerFile": <Config extends OperationConfig>(
    containerId: string,
    fileId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<WithOptionalResponse<void, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
   * Retrieves a container file content.
   */
  readonly "RetrieveContainerFileContent": <Config extends OperationConfig>(
    containerId: string,
    fileId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<WithOptionalResponse<void, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
   * List all items for a conversation with the given ID.
   */
  readonly "listConversationItems": <Config extends OperationConfig>(
    conversationId: string,
    options: {
      readonly params?: typeof ListConversationItemsParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListConversationItems200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create items in a conversation with the given ID.
   */
  readonly "createConversationItems": <Config extends OperationConfig>(
    conversationId: string,
    options: {
      readonly params?: typeof CreateConversationItemsParams.Encoded | undefined
      readonly payload: typeof CreateConversationItemsRequestJson.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateConversationItems200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get a single item from a conversation with the given IDs.
   */
  readonly "getConversationItem": <Config extends OperationConfig>(
    conversationId: string,
    itemId: string,
    options: {
      readonly params?: typeof GetConversationItemParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetConversationItem200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete an item from a conversation with the given IDs.
   */
  readonly "deleteConversationItem": <Config extends OperationConfig>(
    conversationId: string,
    itemId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteConversationItem200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Creates an embedding vector representing the input text.
   */
  readonly "createEmbedding": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateEmbeddingRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateEmbedding200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * List evaluations for a project.
   */
  readonly "listEvals": <Config extends OperationConfig>(
    options:
      | { readonly params?: typeof ListEvalsParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListEvals200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create the structure of an evaluation that can be used to test a model's performance.
   * An evaluation is a set of testing criteria and the config for a data source, which dictates the schema of the data used in the evaluation. After creating an evaluation, you can run it on different models and model parameters. We support several types of graders and datasources.
   * For more information, see the [Evals guide](/docs/guides/evals).
   */
  readonly "createEval": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateEvalRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateEval201.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get an evaluation by ID.
   */
  readonly "getEval": <Config extends OperationConfig>(
    evalId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetEval200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Update certain properties of an evaluation.
   */
  readonly "updateEval": <Config extends OperationConfig>(
    evalId: string,
    options: { readonly payload: typeof UpdateEvalRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UpdateEval200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete an evaluation.
   */
  readonly "deleteEval": <Config extends OperationConfig>(
    evalId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteEval200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError | OpenAiClientError<"DeleteEval404", typeof DeleteEval404.Type>
  >
  /**
   * Get a list of runs for an evaluation.
   */
  readonly "getEvalRuns": <Config extends OperationConfig>(
    evalId: string,
    options:
      | { readonly params?: typeof GetEvalRunsParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetEvalRuns200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Kicks off a new run for a given evaluation, specifying the data source, and what model configuration to use to test. The datasource will be validated against the schema specified in the config of the evaluation.
   */
  readonly "createEvalRun": <Config extends OperationConfig>(
    evalId: string,
    options: { readonly payload: typeof CreateEvalRunRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateEvalRun201.Type, Config>,
    HttpClientError.HttpClientError | SchemaError | OpenAiClientError<"CreateEvalRun400", typeof CreateEvalRun400.Type>
  >
  /**
   * Get an evaluation run by ID.
   */
  readonly "getEvalRun": <Config extends OperationConfig>(
    evalId: string,
    runId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetEvalRun200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Cancel an ongoing evaluation run.
   */
  readonly "cancelEvalRun": <Config extends OperationConfig>(
    evalId: string,
    runId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof CancelEvalRun200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete an eval run.
   */
  readonly "deleteEvalRun": <Config extends OperationConfig>(
    evalId: string,
    runId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteEvalRun200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError | OpenAiClientError<"DeleteEvalRun404", typeof DeleteEvalRun404.Type>
  >
  /**
   * Get a list of output items for an evaluation run.
   */
  readonly "getEvalRunOutputItems": <Config extends OperationConfig>(
    evalId: string,
    runId: string,
    options: {
      readonly params?: typeof GetEvalRunOutputItemsParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetEvalRunOutputItems200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get an evaluation run output item by ID.
   */
  readonly "getEvalRunOutputItem": <Config extends OperationConfig>(
    evalId: string,
    runId: string,
    outputItemId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetEvalRunOutputItem200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Returns a list of files.
   */
  readonly "listFiles": <Config extends OperationConfig>(
    options:
      | { readonly params?: typeof ListFilesParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListFiles200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Upload a file that can be used across various endpoints. Individual files
   * can be up to 512 MB, and each project can store up to 2.5 TB of files in
   * total. There is no organization-wide storage limit.
   *
   * - The Assistants API supports files up to 2 million tokens and of specific
   *   file types. See the [Assistants Tools guide](/docs/assistants/tools) for
   *   details.
   * - The Fine-tuning API only supports `.jsonl` files. The input also has
   *   certain required formats for fine-tuning
   *   [chat](/docs/api-reference/fine-tuning/chat-input) or
   *   [completions](/docs/api-reference/fine-tuning/completions-input) models.
   * - The Batch API only supports `.jsonl` files up to 200 MB in size. The input
   *   also has a specific required
   *   [format](/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  readonly "createFile": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateFileRequestFormData.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateFile200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Returns information about a specific file.
   */
  readonly "retrieveFile": <Config extends OperationConfig>(
    fileId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof RetrieveFile200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete a file and remove it from all vector stores.
   */
  readonly "deleteFile": <Config extends OperationConfig>(
    fileId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteFile200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Returns the contents of the specified file.
   */
  readonly "downloadFile": <Config extends OperationConfig>(
    fileId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DownloadFile200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Run a grader.
   */
  readonly "runGrader": <Config extends OperationConfig>(
    options: { readonly payload: typeof RunGraderRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof RunGrader200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Validate a grader.
   */
  readonly "validateGrader": <Config extends OperationConfig>(
    options: { readonly payload: typeof ValidateGraderRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof ValidateGrader200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to view all permissions for a fine-tuned model checkpoint.
   */
  readonly "listFineTuningCheckpointPermissions": <Config extends OperationConfig>(
    fineTunedModelCheckpoint: string,
    options: {
      readonly params?: typeof ListFineTuningCheckpointPermissionsParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListFineTuningCheckpointPermissions200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
   *
   * This enables organization owners to share fine-tuned models with other projects in their organization.
   */
  readonly "createFineTuningCheckpointPermission": <Config extends OperationConfig>(
    fineTunedModelCheckpoint: string,
    options: {
      readonly payload: typeof CreateFineTuningCheckpointPermissionRequestJson.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateFineTuningCheckpointPermission200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to delete a permission for a fine-tuned model checkpoint.
   */
  readonly "deleteFineTuningCheckpointPermission": <Config extends OperationConfig>(
    fineTunedModelCheckpoint: string,
    permissionId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteFineTuningCheckpointPermission200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * List your organization's fine-tuning jobs
   */
  readonly "listPaginatedFineTuningJobs": <Config extends OperationConfig>(
    options: {
      readonly params?: typeof ListPaginatedFineTuningJobsParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListPaginatedFineTuningJobs200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](/docs/guides/model-optimization)
   */
  readonly "createFineTuningJob": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateFineTuningJobRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateFineTuningJob200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](/docs/guides/model-optimization)
   */
  readonly "retrieveFineTuningJob": <Config extends OperationConfig>(
    fineTuningJobId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof RetrieveFineTuningJob200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Immediately cancel a fine-tune job.
   */
  readonly "cancelFineTuningJob": <Config extends OperationConfig>(
    fineTuningJobId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof CancelFineTuningJob200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * List checkpoints for a fine-tuning job.
   */
  readonly "listFineTuningJobCheckpoints": <Config extends OperationConfig>(
    fineTuningJobId: string,
    options: {
      readonly params?: typeof ListFineTuningJobCheckpointsParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListFineTuningJobCheckpoints200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get status updates for a fine-tuning job.
   */
  readonly "listFineTuningEvents": <Config extends OperationConfig>(
    fineTuningJobId: string,
    options: {
      readonly params?: typeof ListFineTuningEventsParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListFineTuningEvents200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Pause a fine-tune job.
   */
  readonly "pauseFineTuningJob": <Config extends OperationConfig>(
    fineTuningJobId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof PauseFineTuningJob200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Resume a fine-tune job.
   */
  readonly "resumeFineTuningJob": <Config extends OperationConfig>(
    fineTuningJobId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ResumeFineTuningJob200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * You can call this endpoint with either:
   *
   * - `multipart/form-data`: use binary uploads via `image` (and optional `mask`).
   * - `application/json`: use `images` (and optional `mask`) as references with either `image_url` or `file_id`.
   *
   * Note that JSON requests use `images` (array) instead of the multipart `image` field.
   */
  readonly "createImageEdit": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateImageEditRequestFormData.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateImageEdit200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * You can call this endpoint with either:
   *
   * - `multipart/form-data`: use binary uploads via `image` (and optional `mask`).
   * - `application/json`: use `images` (and optional `mask`) as references with either `image_url` or `file_id`.
   *
   * Note that JSON requests use `images` (array) instead of the multipart `image` field.
   */
  readonly "createImageEditSse": (
    options: { readonly payload: typeof CreateImageEditRequestFormData.Encoded }
  ) => Stream.Stream<
    { readonly event: string; readonly id: string | undefined; readonly data: typeof CreateImageEdit200Sse.Type },
    HttpClientError.HttpClientError | SchemaError | Sse.Retry,
    typeof CreateImageEdit200Sse.DecodingServices
  >
  /**
   * Creates an image given a prompt. [Learn more](/docs/guides/images).
   */
  readonly "createImage": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateImageRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateImage200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Creates an image given a prompt. [Learn more](/docs/guides/images).
   */
  readonly "createImageSse": (
    options: { readonly payload: typeof CreateImageRequestJson.Encoded }
  ) => Stream.Stream<
    { readonly event: string; readonly id: string | undefined; readonly data: typeof CreateImage200Sse.Type },
    HttpClientError.HttpClientError | SchemaError | Sse.Retry,
    typeof CreateImage200Sse.DecodingServices
  >
  /**
   * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
   */
  readonly "createImageVariation": <Config extends OperationConfig>(
    options: {
      readonly payload: typeof CreateImageVariationRequestFormData.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateImageVariation200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Lists the currently available models, and provides basic information about each one such as the owner and availability.
   */
  readonly "listModels": <Config extends OperationConfig>(
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListModels200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
   */
  readonly "retrieveModel": <Config extends OperationConfig>(
    model: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof RetrieveModel200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to delete a model.
   */
  readonly "deleteModel": <Config extends OperationConfig>(
    model: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteModel200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn
   * more in the [moderation guide](/docs/guides/moderation).
   */
  readonly "createModeration": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateModerationRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateModeration200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieve a paginated list of organization admin API keys.
   */
  readonly "adminApiKeysList": <Config extends OperationConfig>(
    options: {
      readonly params?: typeof AdminApiKeysListParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof AdminApiKeysList200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create a new admin-level API key for the organization.
   */
  readonly "adminApiKeysCreate": <Config extends OperationConfig>(
    options: { readonly payload: typeof AdminApiKeysCreateRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof AdminApiKeysCreate200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get details for a specific organization API key by its ID.
   */
  readonly "adminApiKeysGet": <Config extends OperationConfig>(
    keyId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof AdminApiKeysGet200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete the specified admin API key.
   */
  readonly "adminApiKeysDelete": <Config extends OperationConfig>(
    keyId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof AdminApiKeysDelete200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * List user actions and configuration changes within this organization.
   */
  readonly "listAuditLogs": <Config extends OperationConfig>(
    options:
      | { readonly params?: typeof ListAuditLogsParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListAuditLogs200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * List uploaded certificates for this organization.
   */
  readonly "listOrganizationCertificates": <Config extends OperationConfig>(
    options: {
      readonly params?: typeof ListOrganizationCertificatesParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListOrganizationCertificates200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Upload a certificate to the organization. This does **not** automatically activate the certificate.
   *
   * Organizations can upload up to 50 certificates.
   */
  readonly "uploadCertificate": <Config extends OperationConfig>(
    options: { readonly payload: typeof UploadCertificateRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UploadCertificate200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Activate certificates at the organization level.
   *
   * You can atomically and idempotently activate up to 10 certificates at a time.
   */
  readonly "activateOrganizationCertificates": <Config extends OperationConfig>(
    options: {
      readonly payload: typeof ActivateOrganizationCertificatesRequestJson.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof ActivateOrganizationCertificates200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Deactivate certificates at the organization level.
   *
   * You can atomically and idempotently deactivate up to 10 certificates at a time.
   */
  readonly "deactivateOrganizationCertificates": <Config extends OperationConfig>(
    options: {
      readonly payload: typeof DeactivateOrganizationCertificatesRequestJson.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeactivateOrganizationCertificates200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get a certificate that has been uploaded to the organization.
   *
   * You can get a certificate regardless of whether it is active or not.
   */
  readonly "getCertificate": <Config extends OperationConfig>(
    certificateId: string,
    options:
      | { readonly params?: typeof GetCertificateParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetCertificate200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Modify a certificate. Note that only the name can be modified.
   */
  readonly "modifyCertificate": <Config extends OperationConfig>(
    certificateId: string,
    options: { readonly payload: typeof ModifyCertificateRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof ModifyCertificate200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete a certificate from the organization.
   *
   * The certificate must be inactive for the organization and all projects.
   */
  readonly "deleteCertificate": <Config extends OperationConfig>(
    certificateId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteCertificate200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get costs details for the organization.
   */
  readonly "usageCosts": <Config extends OperationConfig>(
    options: { readonly params: typeof UsageCostsParams.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UsageCosts200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Lists all groups in the organization.
   */
  readonly "listGroups": <Config extends OperationConfig>(
    options:
      | { readonly params?: typeof ListGroupsParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListGroups200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Creates a new group in the organization.
   */
  readonly "createGroup": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateGroupRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateGroup200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Updates a group's information.
   */
  readonly "updateGroup": <Config extends OperationConfig>(
    groupId: string,
    options: { readonly payload: typeof UpdateGroupRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UpdateGroup200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Deletes a group from the organization.
   */
  readonly "deleteGroup": <Config extends OperationConfig>(
    groupId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteGroup200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Lists the organization roles assigned to a group within the organization.
   */
  readonly "listGroupRoleAssignments": <Config extends OperationConfig>(
    groupId: string,
    options: {
      readonly params?: typeof ListGroupRoleAssignmentsParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListGroupRoleAssignments200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Assigns an organization role to a group within the organization.
   */
  readonly "assignGroupRole": <Config extends OperationConfig>(
    groupId: string,
    options: { readonly payload: typeof AssignGroupRoleRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof AssignGroupRole200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Unassigns an organization role from a group within the organization.
   */
  readonly "unassignGroupRole": <Config extends OperationConfig>(
    groupId: string,
    roleId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof UnassignGroupRole200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Lists the users assigned to a group.
   */
  readonly "listGroupUsers": <Config extends OperationConfig>(
    groupId: string,
    options:
      | { readonly params?: typeof ListGroupUsersParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListGroupUsers200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Adds a user to a group.
   */
  readonly "addGroupUser": <Config extends OperationConfig>(
    groupId: string,
    options: { readonly payload: typeof AddGroupUserRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof AddGroupUser200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Removes a user from a group.
   */
  readonly "removeGroupUser": <Config extends OperationConfig>(
    groupId: string,
    userId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof RemoveGroupUser200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Returns a list of invites in the organization.
   */
  readonly "listInvites": <Config extends OperationConfig>(
    options:
      | { readonly params?: typeof ListInvitesParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListInvites200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create an invite for a user to the organization. The invite must be accepted by the user before they have access to the organization.
   */
  readonly "inviteUser": <Config extends OperationConfig>(
    options: { readonly payload: typeof InviteUserRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof InviteUser200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieves an invite.
   */
  readonly "retrieveInvite": <Config extends OperationConfig>(
    inviteId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof RetrieveInvite200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete an invite. If the invite has already been accepted, it cannot be deleted.
   */
  readonly "deleteInvite": <Config extends OperationConfig>(
    inviteId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteInvite200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Returns a list of projects.
   */
  readonly "listProjects": <Config extends OperationConfig>(
    options:
      | { readonly params?: typeof ListProjectsParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListProjects200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create a new project in the organization. Projects can be created and archived, but cannot be deleted.
   */
  readonly "createProject": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateProjectRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateProject200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieves a project.
   */
  readonly "retrieveProject": <Config extends OperationConfig>(
    projectId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof RetrieveProject200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Modifies a project in the organization.
   */
  readonly "modifyProject": <Config extends OperationConfig>(
    projectId: string,
    options: { readonly payload: typeof ModifyProjectRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof ModifyProject200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError | OpenAiClientError<"ModifyProject400", typeof ModifyProject400.Type>
  >
  /**
   * Returns a list of API keys in the project.
   */
  readonly "listProjectApiKeys": <Config extends OperationConfig>(
    projectId: string,
    options: {
      readonly params?: typeof ListProjectApiKeysParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListProjectApiKeys200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieves an API key in the project.
   */
  readonly "retrieveProjectApiKey": <Config extends OperationConfig>(
    projectId: string,
    keyId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof RetrieveProjectApiKey200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Deletes an API key from the project.
   *
   * Returns confirmation of the key deletion, or an error if the key belonged to
   * a service account.
   */
  readonly "deleteProjectApiKey": <Config extends OperationConfig>(
    projectId: string,
    keyId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteProjectApiKey200.Type, Config>,
    | HttpClientError.HttpClientError
    | SchemaError
    | OpenAiClientError<"DeleteProjectApiKey400", typeof DeleteProjectApiKey400.Type>
  >
  /**
   * Archives a project in the organization. Archived projects cannot be used or updated.
   */
  readonly "archiveProject": <Config extends OperationConfig>(
    projectId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ArchiveProject200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * List certificates for this project.
   */
  readonly "listProjectCertificates": <Config extends OperationConfig>(
    projectId: string,
    options: {
      readonly params?: typeof ListProjectCertificatesParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListProjectCertificates200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Activate certificates at the project level.
   *
   * You can atomically and idempotently activate up to 10 certificates at a time.
   */
  readonly "activateProjectCertificates": <Config extends OperationConfig>(
    projectId: string,
    options: {
      readonly payload: typeof ActivateProjectCertificatesRequestJson.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof ActivateProjectCertificates200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Deactivate certificates at the project level. You can atomically and
   * idempotently deactivate up to 10 certificates at a time.
   */
  readonly "deactivateProjectCertificates": <Config extends OperationConfig>(
    projectId: string,
    options: {
      readonly payload: typeof DeactivateProjectCertificatesRequestJson.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeactivateProjectCertificates200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Lists the groups that have access to a project.
   */
  readonly "listProjectGroups": <Config extends OperationConfig>(
    projectId: string,
    options: {
      readonly params?: typeof ListProjectGroupsParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListProjectGroups200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Grants a group access to a project.
   */
  readonly "addProjectGroup": <Config extends OperationConfig>(
    projectId: string,
    options: { readonly payload: typeof AddProjectGroupRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof AddProjectGroup200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Revokes a group's access to a project.
   */
  readonly "removeProjectGroup": <Config extends OperationConfig>(
    projectId: string,
    groupId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof RemoveProjectGroup200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Returns the rate limits per model for a project.
   */
  readonly "listProjectRateLimits": <Config extends OperationConfig>(
    projectId: string,
    options: {
      readonly params?: typeof ListProjectRateLimitsParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListProjectRateLimits200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Updates a project rate limit.
   */
  readonly "updateProjectRateLimits": <Config extends OperationConfig>(
    projectId: string,
    rateLimitId: string,
    options: {
      readonly payload: typeof UpdateProjectRateLimitsRequestJson.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UpdateProjectRateLimits200.Type, Config>,
    | HttpClientError.HttpClientError
    | SchemaError
    | OpenAiClientError<"UpdateProjectRateLimits400", typeof UpdateProjectRateLimits400.Type>
  >
  /**
   * Returns a list of service accounts in the project.
   */
  readonly "listProjectServiceAccounts": <Config extends OperationConfig>(
    projectId: string,
    options: {
      readonly params?: typeof ListProjectServiceAccountsParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListProjectServiceAccounts200.Type, Config>,
    | HttpClientError.HttpClientError
    | SchemaError
    | OpenAiClientError<"ListProjectServiceAccounts400", typeof ListProjectServiceAccounts400.Type>
  >
  /**
   * Creates a new service account in the project. This also returns an unredacted API key for the service account.
   */
  readonly "createProjectServiceAccount": <Config extends OperationConfig>(
    projectId: string,
    options: {
      readonly payload: typeof CreateProjectServiceAccountRequestJson.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateProjectServiceAccount200.Type, Config>,
    | HttpClientError.HttpClientError
    | SchemaError
    | OpenAiClientError<"CreateProjectServiceAccount400", typeof CreateProjectServiceAccount400.Type>
  >
  /**
   * Retrieves a service account in the project.
   */
  readonly "retrieveProjectServiceAccount": <Config extends OperationConfig>(
    projectId: string,
    serviceAccountId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof RetrieveProjectServiceAccount200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Deletes a service account from the project.
   *
   * Returns confirmation of service account deletion, or an error if the project
   * is archived (archived projects have no service accounts).
   */
  readonly "deleteProjectServiceAccount": <Config extends OperationConfig>(
    projectId: string,
    serviceAccountId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteProjectServiceAccount200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Returns a list of users in the project.
   */
  readonly "listProjectUsers": <Config extends OperationConfig>(
    projectId: string,
    options: {
      readonly params?: typeof ListProjectUsersParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListProjectUsers200.Type, Config>,
    | HttpClientError.HttpClientError
    | SchemaError
    | OpenAiClientError<"ListProjectUsers400", typeof ListProjectUsers400.Type>
  >
  /**
   * Adds a user to the project. Users must already be members of the organization to be added to a project.
   */
  readonly "createProjectUser": <Config extends OperationConfig>(
    projectId: string,
    options: { readonly payload: typeof CreateProjectUserRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateProjectUser200.Type, Config>,
    | HttpClientError.HttpClientError
    | SchemaError
    | OpenAiClientError<"CreateProjectUser400", typeof CreateProjectUser400.Type>
  >
  /**
   * Retrieves a user in the project.
   */
  readonly "retrieveProjectUser": <Config extends OperationConfig>(
    projectId: string,
    userId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof RetrieveProjectUser200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Modifies a user's role in the project.
   */
  readonly "modifyProjectUser": <Config extends OperationConfig>(
    projectId: string,
    userId: string,
    options: { readonly payload: typeof ModifyProjectUserRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof ModifyProjectUser200.Type, Config>,
    | HttpClientError.HttpClientError
    | SchemaError
    | OpenAiClientError<"ModifyProjectUser400", typeof ModifyProjectUser400.Type>
  >
  /**
   * Deletes a user from the project.
   *
   * Returns confirmation of project user deletion, or an error if the project is
   * archived (archived projects have no users).
   */
  readonly "deleteProjectUser": <Config extends OperationConfig>(
    projectId: string,
    userId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteProjectUser200.Type, Config>,
    | HttpClientError.HttpClientError
    | SchemaError
    | OpenAiClientError<"DeleteProjectUser400", typeof DeleteProjectUser400.Type>
  >
  /**
   * Lists the roles configured for the organization.
   */
  readonly "listRoles": <Config extends OperationConfig>(
    options:
      | { readonly params?: typeof ListRolesParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListRoles200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Creates a custom role for the organization.
   */
  readonly "createRole": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateRoleRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateRole200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Updates an existing organization role.
   */
  readonly "updateRole": <Config extends OperationConfig>(
    roleId: string,
    options: { readonly payload: typeof UpdateRoleRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UpdateRole200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Deletes a custom role from the organization.
   */
  readonly "deleteRole": <Config extends OperationConfig>(
    roleId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteRole200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get audio speeches usage details for the organization.
   */
  readonly "usageAudioSpeeches": <Config extends OperationConfig>(
    options: { readonly params: typeof UsageAudioSpeechesParams.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UsageAudioSpeeches200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get audio transcriptions usage details for the organization.
   */
  readonly "usageAudioTranscriptions": <Config extends OperationConfig>(
    options: { readonly params: typeof UsageAudioTranscriptionsParams.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UsageAudioTranscriptions200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get code interpreter sessions usage details for the organization.
   */
  readonly "usageCodeInterpreterSessions": <Config extends OperationConfig>(
    options: {
      readonly params: typeof UsageCodeInterpreterSessionsParams.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UsageCodeInterpreterSessions200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get completions usage details for the organization.
   */
  readonly "usageCompletions": <Config extends OperationConfig>(
    options: { readonly params: typeof UsageCompletionsParams.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UsageCompletions200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get embeddings usage details for the organization.
   */
  readonly "usageEmbeddings": <Config extends OperationConfig>(
    options: { readonly params: typeof UsageEmbeddingsParams.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UsageEmbeddings200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get images usage details for the organization.
   */
  readonly "usageImages": <Config extends OperationConfig>(
    options: { readonly params: typeof UsageImagesParams.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UsageImages200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get moderations usage details for the organization.
   */
  readonly "usageModerations": <Config extends OperationConfig>(
    options: { readonly params: typeof UsageModerationsParams.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UsageModerations200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get vector stores usage details for the organization.
   */
  readonly "usageVectorStores": <Config extends OperationConfig>(
    options: { readonly params: typeof UsageVectorStoresParams.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UsageVectorStores200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Lists all of the users in the organization.
   */
  readonly "listUsers": <Config extends OperationConfig>(
    options:
      | { readonly params?: typeof ListUsersParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListUsers200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieves a user by their identifier.
   */
  readonly "retrieveUser": <Config extends OperationConfig>(
    userId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof RetrieveUser200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Modifies a user's role in the organization.
   */
  readonly "modifyUser": <Config extends OperationConfig>(
    userId: string,
    options: { readonly payload: typeof ModifyUserRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof ModifyUser200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Deletes a user from the organization.
   */
  readonly "deleteUser": <Config extends OperationConfig>(
    userId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteUser200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Lists the organization roles assigned to a user within the organization.
   */
  readonly "listUserRoleAssignments": <Config extends OperationConfig>(
    userId: string,
    options: {
      readonly params?: typeof ListUserRoleAssignmentsParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListUserRoleAssignments200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Assigns an organization role to a user within the organization.
   */
  readonly "assignUserRole": <Config extends OperationConfig>(
    userId: string,
    options: { readonly payload: typeof AssignUserRoleRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof AssignUserRole200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Unassigns an organization role from a user within the organization.
   */
  readonly "unassignUserRole": <Config extends OperationConfig>(
    userId: string,
    roleId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof UnassignUserRole200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Lists the project roles assigned to a group within a project.
   */
  readonly "listProjectGroupRoleAssignments": <Config extends OperationConfig>(
    projectId: string,
    groupId: string,
    options: {
      readonly params?: typeof ListProjectGroupRoleAssignmentsParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListProjectGroupRoleAssignments200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Assigns a project role to a group within a project.
   */
  readonly "assignProjectGroupRole": <Config extends OperationConfig>(
    projectId: string,
    groupId: string,
    options: {
      readonly payload: typeof AssignProjectGroupRoleRequestJson.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof AssignProjectGroupRole200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Unassigns a project role from a group within a project.
   */
  readonly "unassignProjectGroupRole": <Config extends OperationConfig>(
    projectId: string,
    groupId: string,
    roleId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof UnassignProjectGroupRole200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Lists the roles configured for a project.
   */
  readonly "listProjectRoles": <Config extends OperationConfig>(
    projectId: string,
    options: {
      readonly params?: typeof ListProjectRolesParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListProjectRoles200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Creates a custom role for a project.
   */
  readonly "createProjectRole": <Config extends OperationConfig>(
    projectId: string,
    options: { readonly payload: typeof CreateProjectRoleRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateProjectRole200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Updates an existing project role.
   */
  readonly "updateProjectRole": <Config extends OperationConfig>(
    projectId: string,
    roleId: string,
    options: { readonly payload: typeof UpdateProjectRoleRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UpdateProjectRole200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Deletes a custom role from a project.
   */
  readonly "deleteProjectRole": <Config extends OperationConfig>(
    projectId: string,
    roleId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteProjectRole200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Lists the project roles assigned to a user within a project.
   */
  readonly "listProjectUserRoleAssignments": <Config extends OperationConfig>(
    projectId: string,
    userId: string,
    options: {
      readonly params?: typeof ListProjectUserRoleAssignmentsParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListProjectUserRoleAssignments200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Assigns a project role to a user within a project.
   */
  readonly "assignProjectUserRole": <Config extends OperationConfig>(
    projectId: string,
    userId: string,
    options: { readonly payload: typeof AssignProjectUserRoleRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof AssignProjectUserRole200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Unassigns a project role from a user within a project.
   */
  readonly "unassignProjectUserRole": <Config extends OperationConfig>(
    projectId: string,
    userId: string,
    roleId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof UnassignProjectUserRole200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create a new Realtime API call over WebRTC and receive the SDP answer needed
   * to complete the peer connection.
   */
  readonly "createRealtimeCall": <Config extends OperationConfig>(
    options: {
      readonly payload: typeof CreateRealtimeCallRequestFormData.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<WithOptionalResponse<void, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
   * Accept an incoming SIP call and configure the realtime session that will
   * handle it.
   */
  readonly "acceptRealtimeCall": <Config extends OperationConfig>(
    callId: string,
    options: { readonly payload: typeof AcceptRealtimeCallRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<WithOptionalResponse<void, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
   * End an active Realtime API call, whether it was initiated over SIP or
   * WebRTC.
   */
  readonly "hangupRealtimeCall": <Config extends OperationConfig>(
    callId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<WithOptionalResponse<void, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
   * Transfer an active SIP call to a new destination using the SIP REFER verb.
   */
  readonly "referRealtimeCall": <Config extends OperationConfig>(
    callId: string,
    options: { readonly payload: typeof ReferRealtimeCallRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<WithOptionalResponse<void, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
   * Decline an incoming SIP call by returning a SIP status code to the caller.
   */
  readonly "rejectRealtimeCall": <Config extends OperationConfig>(
    callId: string,
    options: { readonly payload: typeof RejectRealtimeCallRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<WithOptionalResponse<void, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
   * Create a Realtime client secret with an associated session configuration.
   *
   * Client secrets are short-lived tokens that can be passed to a client app,
   * such as a web frontend or mobile client, which grants access to the Realtime API without
   * leaking your main API key. You can configure a custom TTL for each client secret.
   *
   * You can also attach session configuration options to the client secret, which will be
   * applied to any sessions created using that client secret, but these can also be overridden
   * by the client connection.
   *
   * [Learn more about authentication with client secrets over WebRTC](/docs/guides/realtime-webrtc).
   *
   * Returns the created client secret and the effective session object. The client secret is a string that looks like `ek_1234`.
   */
  readonly "createRealtimeClientSecret": <Config extends OperationConfig>(
    options: {
      readonly payload: typeof CreateRealtimeClientSecretRequestJson.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateRealtimeClientSecret200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains
   * a usable ephemeral API token that can be used to authenticate browser clients
   * for the Realtime API.
   *
   * Returns the created Realtime session object, plus an ephemeral key.
   */
  readonly "createRealtimeSession": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateRealtimeSessionRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateRealtimeSession200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API specifically for realtime transcriptions.
   * Can be configured with the same session parameters as the `transcription_session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains
   * a usable ephemeral API token that can be used to authenticate browser clients
   * for the Realtime API.
   *
   * Returns the created Realtime transcription session object, plus an ephemeral key.
   */
  readonly "createRealtimeTranscriptionSession": <Config extends OperationConfig>(
    options: {
      readonly payload: typeof CreateRealtimeTranscriptionSessionRequestJson.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateRealtimeTranscriptionSession200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Creates a model response. Provide [text](/docs/guides/text) or
   * [image](/docs/guides/images) inputs to generate [text](/docs/guides/text)
   * or [JSON](/docs/guides/structured-outputs) outputs. Have the model call
   * your own [custom code](/docs/guides/function-calling) or use built-in
   * [tools](/docs/guides/tools) like [web search](/docs/guides/tools-web-search)
   * or [file search](/docs/guides/tools-file-search) to use your own data
   * as input for the model's response.
   */
  readonly "createResponse": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateResponseRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateResponse200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Creates a model response. Provide [text](/docs/guides/text) or
   * [image](/docs/guides/images) inputs to generate [text](/docs/guides/text)
   * or [JSON](/docs/guides/structured-outputs) outputs. Have the model call
   * your own [custom code](/docs/guides/function-calling) or use built-in
   * [tools](/docs/guides/tools) like [web search](/docs/guides/tools-web-search)
   * or [file search](/docs/guides/tools-file-search) to use your own data
   * as input for the model's response.
   */
  readonly "createResponseSse": (
    options: { readonly payload: typeof CreateResponseRequestJson.Encoded }
  ) => Stream.Stream<
    { readonly event: string; readonly id: string | undefined; readonly data: typeof CreateResponse200Sse.Type },
    HttpClientError.HttpClientError | SchemaError | Sse.Retry,
    typeof CreateResponse200Sse.DecodingServices
  >
  /**
   * Retrieves a model response with the given ID.
   */
  readonly "getResponse": <Config extends OperationConfig>(
    responseId: string,
    options:
      | { readonly params?: typeof GetResponseParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetResponse200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Deletes a model response with the given ID.
   */
  readonly "deleteResponse": <Config extends OperationConfig>(
    responseId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<void, Config>,
    | HttpClientError.HttpClientError
    | SchemaError
    | OpenAiClientError<"DeleteResponse404", typeof DeleteResponse404.Type>
  >
  /**
   * Cancels a model response with the given ID. Only responses created with
   * the `background` parameter set to `true` can be cancelled.
   * [Learn more](/docs/guides/background).
   */
  readonly "cancelResponse": <Config extends OperationConfig>(
    responseId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof CancelResponse200.Type, Config>,
    | HttpClientError.HttpClientError
    | SchemaError
    | OpenAiClientError<"CancelResponse404", typeof CancelResponse404.Type>
  >
  /**
   * Returns a list of input items for a given response.
   */
  readonly "listInputItems": <Config extends OperationConfig>(
    responseId: string,
    options:
      | { readonly params?: typeof ListInputItemsParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListInputItems200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create a thread.
   */
  readonly "createThread": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateThreadRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateThread200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create a thread and run it in one request.
   */
  readonly "createThreadAndRun": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateThreadAndRunRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateThreadAndRun200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieves a thread.
   */
  readonly "getThread": <Config extends OperationConfig>(
    threadId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetThread200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Modifies a thread.
   */
  readonly "modifyThread": <Config extends OperationConfig>(
    threadId: string,
    options: { readonly payload: typeof ModifyThreadRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof ModifyThread200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete a thread.
   */
  readonly "deleteThread": <Config extends OperationConfig>(
    threadId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteThread200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Returns a list of messages for a given thread.
   */
  readonly "listMessages": <Config extends OperationConfig>(
    threadId: string,
    options:
      | { readonly params?: typeof ListMessagesParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListMessages200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create a message.
   */
  readonly "createMessage": <Config extends OperationConfig>(
    threadId: string,
    options: { readonly payload: typeof CreateMessageRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateMessage200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieve a message.
   */
  readonly "getMessage": <Config extends OperationConfig>(
    threadId: string,
    messageId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetMessage200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Modifies a message.
   */
  readonly "modifyMessage": <Config extends OperationConfig>(
    threadId: string,
    messageId: string,
    options: { readonly payload: typeof ModifyMessageRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof ModifyMessage200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Deletes a message.
   */
  readonly "deleteMessage": <Config extends OperationConfig>(
    threadId: string,
    messageId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteMessage200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Returns a list of runs belonging to a thread.
   */
  readonly "listRuns": <Config extends OperationConfig>(
    threadId: string,
    options:
      | { readonly params?: typeof ListRunsParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListRuns200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create a run.
   */
  readonly "createRun": <Config extends OperationConfig>(
    threadId: string,
    options: {
      readonly params?: typeof CreateRunParams.Encoded | undefined
      readonly payload: typeof CreateRunRequestJson.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateRun200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieves a run.
   */
  readonly "getRun": <Config extends OperationConfig>(
    threadId: string,
    runId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<WithOptionalResponse<typeof GetRun200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
   * Modifies a run.
   */
  readonly "modifyRun": <Config extends OperationConfig>(
    threadId: string,
    runId: string,
    options: { readonly payload: typeof ModifyRunRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof ModifyRun200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Cancels a run that is `in_progress`.
   */
  readonly "cancelRun": <Config extends OperationConfig>(
    threadId: string,
    runId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof CancelRun200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Returns a list of run steps belonging to a run.
   */
  readonly "listRunSteps": <Config extends OperationConfig>(
    threadId: string,
    runId: string,
    options:
      | { readonly params?: typeof ListRunStepsParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListRunSteps200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieves a run step.
   */
  readonly "getRunStep": <Config extends OperationConfig>(
    threadId: string,
    runId: string,
    stepId: string,
    options:
      | { readonly params?: typeof GetRunStepParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetRunStep200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * When a run has the `status: "requires_action"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they're all completed. All outputs must be submitted in a single request.
   */
  readonly "submitToolOuputsToRun": <Config extends OperationConfig>(
    threadId: string,
    runId: string,
    options: { readonly payload: typeof SubmitToolOuputsToRunRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof SubmitToolOuputsToRun200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Creates an intermediate [Upload](/docs/api-reference/uploads/object) object
   * that you can add [Parts](/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an
   * hour after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](/docs/api-reference/files/object) object that contains all the parts
   * you uploaded. This File is usable in the rest of our platform as a regular
   * File object.
   *
   * For certain `purpose` values, the correct `mime_type` must be specified.
   * Please refer to documentation for the
   * [supported MIME types for your use case](/docs/assistants/tools/file-search#supported-files).
   *
   * For guidance on the proper filename extensions for each purpose, please
   * follow the documentation on [creating a
   * File](/docs/api-reference/files/create).
   *
   * Returns the Upload object with status `pending`.
   */
  readonly "createUpload": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateUploadRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateUpload200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   *
   * Returns the Upload object with status `cancelled`.
   */
  readonly "cancelUpload": <Config extends OperationConfig>(
    uploadId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof CancelUpload200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Completes the [Upload](/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested [File](/docs/api-reference/files/object) object that is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes initially specified when creating the Upload object. No Parts may be added after an Upload is completed.
   * Returns the Upload object with status `completed`, including an additional `file` property containing the created usable File object.
   */
  readonly "completeUpload": <Config extends OperationConfig>(
    uploadId: string,
    options: { readonly payload: typeof CompleteUploadRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CompleteUpload200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Adds a [Part](/docs/api-reference/uploads/part-object) to an [Upload](/docs/api-reference/uploads/object) object. A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended order of the Parts when you [complete the Upload](/docs/api-reference/uploads/complete).
   */
  readonly "addUploadPart": <Config extends OperationConfig>(
    uploadId: string,
    options: { readonly payload: typeof AddUploadPartRequestFormData.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof AddUploadPart200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Returns a list of vector stores.
   */
  readonly "listVectorStores": <Config extends OperationConfig>(
    options: {
      readonly params?: typeof ListVectorStoresParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListVectorStores200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create a vector store.
   */
  readonly "createVectorStore": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateVectorStoreRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateVectorStore200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieves a vector store.
   */
  readonly "getVectorStore": <Config extends OperationConfig>(
    vectorStoreId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetVectorStore200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Modifies a vector store.
   */
  readonly "modifyVectorStore": <Config extends OperationConfig>(
    vectorStoreId: string,
    options: { readonly payload: typeof ModifyVectorStoreRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof ModifyVectorStore200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete a vector store.
   */
  readonly "deleteVectorStore": <Config extends OperationConfig>(
    vectorStoreId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteVectorStore200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * The maximum number of files in a single batch request is 2000.
   */
  readonly "createVectorStoreFileBatch": <Config extends OperationConfig>(
    vectorStoreId: string,
    options: {
      readonly payload: typeof CreateVectorStoreFileBatchRequestJson.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateVectorStoreFileBatch200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieves a vector store file batch.
   */
  readonly "getVectorStoreFileBatch": <Config extends OperationConfig>(
    vectorStoreId: string,
    batchId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetVectorStoreFileBatch200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
   */
  readonly "cancelVectorStoreFileBatch": <Config extends OperationConfig>(
    vectorStoreId: string,
    batchId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof CancelVectorStoreFileBatch200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Returns a list of vector store files in a batch.
   */
  readonly "listFilesInVectorStoreBatch": <Config extends OperationConfig>(
    vectorStoreId: string,
    batchId: string,
    options: {
      readonly params?: typeof ListFilesInVectorStoreBatchParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListFilesInVectorStoreBatch200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Returns a list of vector store files.
   */
  readonly "listVectorStoreFiles": <Config extends OperationConfig>(
    vectorStoreId: string,
    options: {
      readonly params?: typeof ListVectorStoreFilesParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListVectorStoreFiles200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
   */
  readonly "createVectorStoreFile": <Config extends OperationConfig>(
    vectorStoreId: string,
    options: { readonly payload: typeof CreateVectorStoreFileRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateVectorStoreFile200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieves a vector store file.
   */
  readonly "getVectorStoreFile": <Config extends OperationConfig>(
    vectorStoreId: string,
    fileId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetVectorStoreFile200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Update attributes on a vector store file.
   */
  readonly "updateVectorStoreFileAttributes": <Config extends OperationConfig>(
    vectorStoreId: string,
    fileId: string,
    options: {
      readonly payload: typeof UpdateVectorStoreFileAttributesRequestJson.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UpdateVectorStoreFileAttributes200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
   */
  readonly "deleteVectorStoreFile": <Config extends OperationConfig>(
    vectorStoreId: string,
    fileId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteVectorStoreFile200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieve the parsed contents of a vector store file.
   */
  readonly "retrieveVectorStoreFileContent": <Config extends OperationConfig>(
    vectorStoreId: string,
    fileId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof RetrieveVectorStoreFileContent200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Search a vector store for relevant chunks based on a query and file attributes filter.
   */
  readonly "searchVectorStore": <Config extends OperationConfig>(
    vectorStoreId: string,
    options: { readonly payload: typeof SearchVectorStoreRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof SearchVectorStore200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create a conversation.
   */
  readonly "createConversation": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateConversationRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateConversation200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get a conversation
   */
  readonly "getConversation": <Config extends OperationConfig>(
    conversationId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetConversation200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Update a conversation
   */
  readonly "updateConversation": <Config extends OperationConfig>(
    conversationId: string,
    options: { readonly payload: typeof UpdateConversationRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UpdateConversation200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete a conversation. Items in the conversation will not be deleted.
   */
  readonly "deleteConversation": <Config extends OperationConfig>(
    conversationId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteConversation200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * List recently generated videos for the current project.
   */
  readonly "ListVideos": <Config extends OperationConfig>(
    options:
      | { readonly params?: typeof ListVideosParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListVideos200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create a new video generation job from a prompt and optional reference assets.
   */
  readonly "createVideo": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateVideoRequestFormData.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateVideo200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Fetch the latest metadata for a generated video.
   */
  readonly "GetVideo": <Config extends OperationConfig>(
    videoId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetVideo200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Permanently delete a completed or failed video and its stored assets.
   */
  readonly "DeleteVideo": <Config extends OperationConfig>(
    videoId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteVideo200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Download the generated video bytes or a derived preview asset.
   *
   * Streams the rendered video content for the specified video job.
   */
  readonly "RetrieveVideoContent": <Config extends OperationConfig>(
    videoId: string,
    options: {
      readonly params?: typeof RetrieveVideoContentParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof RetrieveVideoContent200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create a remix of a completed video using a refreshed prompt.
   */
  readonly "CreateVideoRemix": <Config extends OperationConfig>(
    videoId: string,
    options: { readonly payload: typeof CreateVideoRemixRequestFormData.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateVideoRemix200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Returns input token counts of the request.
   *
   * Returns an object with `object` set to `response.input_tokens` and an `input_tokens` count.
   */
  readonly "Getinputtokencounts": <Config extends OperationConfig>(
    options: { readonly payload: typeof GetinputtokencountsRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof Getinputtokencounts200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Compact a conversation. Returns a compacted response object.
   *
   * Learn when and how to compact long-running conversations in the [conversation state guide](/docs/guides/conversation-state#managing-the-context-window). For ZDR-compatible compaction details, see [Compaction (advanced)](/docs/guides/conversation-state#compaction-advanced).
   */
  readonly "Compactconversation": <Config extends OperationConfig>(
    options: { readonly payload: typeof CompactconversationRequestJson.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof Compactconversation200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * List all skills for the current project.
   */
  readonly "ListSkills": <Config extends OperationConfig>(
    options:
      | { readonly params?: typeof ListSkillsParams.Encoded | undefined; readonly config?: Config | undefined }
      | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListSkills200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create a new skill.
   */
  readonly "CreateSkill": <Config extends OperationConfig>(
    options: { readonly payload: typeof CreateSkillRequestFormData.Encoded; readonly config?: Config | undefined }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateSkill200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get a skill by its ID.
   */
  readonly "GetSkill": <Config extends OperationConfig>(
    skillId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetSkill200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Update the default version pointer for a skill.
   */
  readonly "UpdateSkillDefaultVersion": <Config extends OperationConfig>(
    skillId: string,
    options: {
      readonly payload: typeof UpdateSkillDefaultVersionRequestJson.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof UpdateSkillDefaultVersion200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete a skill by its ID.
   */
  readonly "DeleteSkill": <Config extends OperationConfig>(
    skillId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteSkill200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Download a skill zip bundle by its ID.
   */
  readonly "GetSkillContent": <Config extends OperationConfig>(
    skillId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetSkillContent200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * List skill versions for a skill.
   */
  readonly "ListSkillVersions": <Config extends OperationConfig>(
    skillId: string,
    options: {
      readonly params?: typeof ListSkillVersionsParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListSkillVersions200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create a new immutable skill version.
   */
  readonly "CreateSkillVersion": <Config extends OperationConfig>(
    skillId: string,
    options: {
      readonly payload: typeof CreateSkillVersionRequestFormData.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateSkillVersion200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Get a specific skill version.
   */
  readonly "GetSkillVersion": <Config extends OperationConfig>(
    skillId: string,
    version: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetSkillVersion200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete a skill version.
   */
  readonly "DeleteSkillVersion": <Config extends OperationConfig>(
    skillId: string,
    version: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteSkillVersion200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Download a skill version zip bundle.
   */
  readonly "GetSkillVersionContent": <Config extends OperationConfig>(
    skillId: string,
    version: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetSkillVersionContent200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Cancel an active ChatKit session and return its most recent metadata.
   *
   * Cancelling prevents new requests from using the issued client secret.
   */
  readonly "CancelChatSessionMethod": <Config extends OperationConfig>(
    sessionId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof CancelChatSessionMethod200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Create a ChatKit session.
   */
  readonly "CreateChatSessionMethod": <Config extends OperationConfig>(
    options: {
      readonly payload: typeof CreateChatSessionMethodRequestJson.Encoded
      readonly config?: Config | undefined
    }
  ) => Effect.Effect<
    WithOptionalResponse<typeof CreateChatSessionMethod200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * List items that belong to a ChatKit thread.
   */
  readonly "ListThreadItemsMethod": <Config extends OperationConfig>(
    threadId: string,
    options: {
      readonly params?: typeof ListThreadItemsMethodParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListThreadItemsMethod200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Retrieve a ChatKit thread by its identifier.
   */
  readonly "GetThreadMethod": <Config extends OperationConfig>(
    threadId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof GetThreadMethod200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * Delete a ChatKit thread along with its items and stored attachments.
   */
  readonly "DeleteThreadMethod": <Config extends OperationConfig>(
    threadId: string,
    options: { readonly config?: Config | undefined } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof DeleteThreadMethod200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
  /**
   * List ChatKit threads with optional pagination and user filters.
   */
  readonly "ListThreadsMethod": <Config extends OperationConfig>(
    options: {
      readonly params?: typeof ListThreadsMethodParams.Encoded | undefined
      readonly config?: Config | undefined
    } | undefined
  ) => Effect.Effect<
    WithOptionalResponse<typeof ListThreadsMethod200.Type, Config>,
    HttpClientError.HttpClientError | SchemaError
  >
}

export interface OpenAiClientError<Tag extends string, E> {
  readonly _tag: Tag
  readonly request: HttpClientRequest.HttpClientRequest
  readonly response: HttpClientResponse.HttpClientResponse
  readonly cause: E
}

class OpenAiClientErrorImpl extends Data.Error<{
  _tag: string
  cause: any
  request: HttpClientRequest.HttpClientRequest
  response: HttpClientResponse.HttpClientResponse
}> {}

export const OpenAiClientError = <Tag extends string, E>(
  tag: Tag,
  cause: E,
  response: HttpClientResponse.HttpClientResponse
): OpenAiClientError<Tag, E> =>
  new OpenAiClientErrorImpl({
    _tag: tag,
    cause,
    response,
    request: response.request
  }) as any
